import {
  KTe,
  Qs,
  XTe,
  abe,
  cbe,
  cn,
  dbe,
  lbe,
  ube
} from "./chunk-2ROGQ7VS.js";
import {
  H,
  I,
  J,
  K,
  W,
  X,
  z
} from "./chunk-D5GBAIJV.js";
import {
  z as z3
} from "./chunk-O46TZV6B.js";
import {
  B,
  D,
  G,
  H as H2,
  I as I2,
  J as J2,
  K as K2,
  L,
  M,
  O,
  OE,
  P,
  Q,
  TE,
  U,
  V,
  X as X2,
  Y,
  Z,
  b,
  d,
  e,
  j,
  l,
  m,
  p,
  q,
  r,
  w,
  x,
  z as z2
} from "./chunk-CD6FLOGV.js";
import {
  h,
  i,
  o,
  scope
} from "./chunk-2MX6Z6FM.js";
import {
  __require
} from "./chunk-KOPRMXR6.js";

// node_modules/.pnpm/storybook@9.0.16_@testing-library+dom@10.4.0_prettier@3.6.2/node_modules/storybook/dist/preview-errors.js
var ae = Object.defineProperty;
var t = (u, r2) => ae(u, "name", { value: r2, configurable: true });
function n(u) {
  for (var r2 = [], e2 = 1; e2 < arguments.length; e2++)
    r2[e2 - 1] = arguments[e2];
  var a = Array.from(typeof u == "string" ? [u] : u);
  a[a.length - 1] = a[a.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var y = a.reduce(function(i2, m2) {
    var p2 = m2.match(/\n([\t ]+|(?!\s).)/g);
    return p2 ? i2.concat(p2.map(function(E) {
      var d2, l2;
      return (l2 = (d2 = E.match(/[\t ]/g)) === null || d2 === void 0 ? void 0 : d2.length) !== null && l2 !== void 0 ? l2 : 0;
    })) : i2;
  }, []);
  if (y.length) {
    var h2 = new RegExp(`
[	 ]{` + Math.min.apply(Math, y) + "}", "g");
    a = a.map(function(i2) {
      return i2.replace(h2, `
`);
    });
  }
  a[0] = a[0].replace(/^\r?\n/, "");
  var c = a[0];
  return r2.forEach(function(i2, m2) {
    var p2 = c.match(/(?:^|\n)( *)$/), E = p2 ? p2[1] : "", d2 = i2;
    typeof i2 == "string" && i2.includes(`
`) && (d2 = String(i2).split(`
`).map(function(l2, ne) {
      return ne === 0 ? l2 : "" + E + l2;
    }).join(`
`)), c += d2 + a[m2 + 1];
  }), c;
}
t(n, "dedent");
function j2({
  code: u,
  category: r2
}) {
  let e2 = String(u).padStart(4, "0");
  return `SB_${r2}_${e2}`;
}
t(j2, "parseErrorCode");
var g = class g2 extends Error {
  constructor(e2) {
    super(g2.getFullMessage(e2));
    this.data = {};
    this.fromStorybook = true;
    this.category = e2.category, this.documentation = e2.documentation ?? false, this.code = e2.code;
  }
  get fullErrorCode() {
    return j2({ code: this.code, category: this.category });
  }
  /** Overrides the default `Error.name` property in the format: SB_<CATEGORY>_<CODE>. */
  get name() {
    let e2 = this.constructor.name;
    return `${this.fullErrorCode} (${e2})`;
  }
  /** Generates the error message along with additional documentation link (if applicable). */
  static getFullMessage({
    documentation: e2,
    code: a,
    category: y,
    message: h2
  }) {
    let c;
    return e2 === true ? c = `https://storybook.js.org/error/${j2({ code: a, category: y })}` : typeof e2 == "string" ? c = e2 : Array.isArray(e2) && (c = `
${e2.map((i2) => `	- ${i2}`).join(`
`)}`), `${h2}${c != null ? `

More info: ${c}
` : ""}`;
  }
};
t(g, "StorybookError");
var o2 = g;
var ie = ((s) => (s.BLOCKS = "BLOCKS", s.DOCS_TOOLS = "DOCS-TOOLS", s.PREVIEW_CLIENT_LOGGER = "PREVIEW_CLIENT-LOGGER", s.PREVIEW_CHANNELS = "PREVIEW_CHANNELS", s.PREVIEW_CORE_EVENTS = "PREVIEW_CORE-EVENTS", s.PREVIEW_INSTRUMENTER = "PREVIEW_INSTRUMENTER", s.PREVIEW_API = "PREVIEW_API", s.PREVIEW_REACT_DOM_SHIM = "PREVIEW_REACT-DOM-SHIM", s.PREVIEW_ROUTER = "PREVIEW_ROUTER", s.PREVIEW_THEMING = "PREVIEW_THEMING", s.RENDERER_HTML = "RENDERER_HTML", s.RENDERER_PREACT = "RENDERER_PREACT", s.RENDERER_REACT = "RENDERER_REACT", s.RENDERER_SERVER = "RENDERER_SERVER", s.RENDERER_SVELTE = "RENDERER_SVELTE", s.RENDERER_VUE = "RENDERER_VUE", s.RENDERER_VUE3 = "RENDERER_VUE3", s.RENDERER_WEB_COMPONENTS = "RENDERER_WEB-COMPONENTS", s.FRAMEWORK_NEXTJS = "FRAMEWORK_NEXTJS", s.ADDON_VITEST = "ADDON_VITEST", s.ADDON_A11Y = "ADDON_A11Y", s))(ie || {});
var f = class f2 extends o2 {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 1,
      message: n`
        Couldn't find story matching id '${e2.storyId}' after HMR.
        - Did you just rename a story?
        - Did you remove it from your CSF file?
        - Are you sure a story with the id '${e2.storyId}' exists?
        - Please check the values in the stories field of your main.js config and see if they would match your CSF File.
        - Also check the browser console and terminal for potential error messages.`
    });
    this.data = e2;
  }
};
t(f, "MissingStoryAfterHmrError");
var L2 = f;
var b2 = class b3 extends o2 {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 2,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#using-implicit-actions-during-rendering-is-deprecated-for-example-in-the-play-function",
      message: n`
        We detected that you use an implicit action arg while ${e2.phase} of your story.  
        ${e2.deprecated ? `
This is deprecated and won't work in Storybook 8 anymore.
` : ""}
        Please provide an explicit spy to your args like this:
          import { fn } from 'storybook/test';
          ... 
          args: {
           ${e2.name}: fn()
          }`
    });
    this.data = e2;
  }
};
t(b2, "ImplicitActionsDuringRendering");
var Y2 = b2;
var R = class R2 extends o2 {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 3,
      message: n`
        Cannot call \`storyStore.extract()\` without calling \`storyStore.cacheAllCsfFiles()\` first.

        You probably meant to call \`await preview.extract()\` which does the above for you.`
    });
  }
};
t(R, "CalledExtractOnStoreError");
var G2 = R;
var I3 = class I4 extends o2 {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 4,
      message: n`
        Expected your framework's preset to export a \`renderToCanvas\` field.

        Perhaps it needs to be upgraded for Storybook 7.0?`,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field"
    });
  }
};
t(I3, "MissingRenderToCanvasError");
var F = I3;
var x2 = class x3 extends o2 {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 5,
      message: n`
        Called \`Preview.${e2.methodName}()\` before initialization.
        
        The preview needs to load the story index before most methods can be called. If you want
        to call \`${e2.methodName}\`, try \`await preview.initializationPromise;\` first.
        
        If you didn't call the above code, then likely it was called by an addon that needs to
        do the above.`
    });
    this.data = e2;
  }
};
t(x2, "CalledPreviewMethodBeforeInitializationError");
var H3 = x2;
var P2 = class P3 extends o2 {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 6,
      message: n`
        Error fetching \`/index.json\`:
        
        ${e2.text}

        If you are in development, this likely indicates a problem with your Storybook process,
        check the terminal for errors.

        If you are in a deployed Storybook, there may have been an issue deploying the full Storybook
        build.`
    });
    this.data = e2;
  }
};
t(P2, "StoryIndexFetchError");
var M2 = P2;
var w2 = class w3 extends o2 {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 7,
      message: n`
        Tried to render docs entry ${e2.storyId} but it is a MDX file that has no CSF
        references, or autodocs for a CSF file that some doesn't refer to itself.
        
        This likely is an internal error in Storybook's indexing, or you've attached the
        \`attached-mdx\` tag to an MDX file that is not attached.`
    });
    this.data = e2;
  }
};
t(w2, "MdxFileWithNoCsfReferencesError");
var K3 = w2;
var T = class T2 extends o2 {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 8,
      message: n`
        Couldn't find any stories in your Storybook.

        - Please check your stories field of your main.js config: does it match correctly?
        - Also check the browser console and terminal for error messages.`
    });
  }
};
t(T, "EmptyIndexError");
var X3 = T;
var S = class S2 extends o2 {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 9,
      message: n`
        Couldn't find story matching '${e2.storySpecifier}'.

        - Are you sure a story with that id exists?
        - Please check your stories field of your main.js config.
        - Also check the browser console and terminal for error messages.`
    });
    this.data = e2;
  }
};
t(S, "NoStoryMatchError");
var U2 = S;
var k = class k2 extends o2 {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 10,
      message: n`
        Couldn't find story matching id '${e2.storyId}' after importing a CSF file.

        The file was indexed as if the story was there, but then after importing the file in the browser
        we didn't find the story. Possible reasons:
        - You are using a custom story indexer that is misbehaving.
        - You have a custom file loader that is removing or renaming exports.

        Please check your browser console and terminal for errors that may explain the issue.`
    });
    this.data = e2;
  }
};
t(k, "MissingStoryFromCsfFileError");
var J3 = k;
var v = class v2 extends o2 {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 11,
      message: n`
        Cannot access the Story Store until the index is ready.

        It is not recommended to use methods directly on the Story Store anyway, in Storybook 9 we will
        remove access to the store entirely`
    });
  }
};
t(v, "StoryStoreAccessedBeforeInitializationError");
var q2 = v;
var _ = class _2 extends o2 {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 12,
      message: n`
      Incorrect use of mount in the play function.
      
      To use mount in the play function, you must satisfy the following two requirements: 
      
      1. You *must* destructure the mount property from the \`context\` (the argument passed to your play function). 
         This makes sure that Storybook does not start rendering the story before the play function begins.
      
      2. Your Storybook framework or builder must be configured to transpile to ES2017 or newer. 
         This is because destructuring statements and async/await usages are otherwise transpiled away, 
         which prevents Storybook from recognizing your usage of \`mount\`.
      
      Note that Angular is not supported. As async/await is transpiled to support the zone.js polyfill. 
      
      More info: https://storybook.js.org/docs/writing-tests/interaction-testing#run-code-before-the-component-gets-rendered
      
      Received the following play function:
      ${e2.playFunction}`
    });
    this.data = e2;
  }
};
t(_, "MountMustBeDestructuredError");
var z4 = _;
var N = class N2 extends o2 {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 14,
      message: n`
        No render function available for storyId '${e2.id}'
      `
    });
    this.data = e2;
  }
};
t(N, "NoRenderFunctionError");
var B2 = N;
var V2 = class V3 extends o2 {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 15,
      message: n`
        No component is mounted in your story.
        
        This usually occurs when you destructure mount in the play function, but forget to call it.
        
        For example:

        async play({ mount, canvasElement }) {
          // 👈 mount should be called: await mount(); 
          const canvas = within(canvasElement);
          const button = await canvas.findByRole('button');
          await userEvent.click(button);
        };

        Make sure to either remove it or call mount in your play function.
      `
    });
  }
};
t(V2, "NoStoryMountedError");
var Q2 = V2;
var A = class A2 extends o2 {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 16,
      message: `Status has typeId "${e2.status.typeId}" but was added to store with typeId "${e2.typeId}". Full status: ${JSON.stringify(
        e2.status,
        null,
        2
      )}`
    });
    this.data = e2;
  }
};
t(A, "StatusTypeIdMismatchError");
var O2 = class O3 extends o2 {
  constructor() {
    super({
      category: "FRAMEWORK_NEXTJS",
      code: 1,
      documentation: "https://storybook.js.org/docs/get-started/nextjs#faq",
      message: n`
      You are importing avif images, but you don't have sharp installed.

      You have to install sharp in order to use image optimization features in Next.js.
      `
    });
  }
};
t(O2, "NextJsSharpError");
var W2 = class W3 extends o2 {
  constructor(e2) {
    super({
      category: "FRAMEWORK_NEXTJS",
      code: 2,
      message: n`
        Tried to access router mocks from "${e2.importType}" but they were not created yet. You might be running code in an unsupported environment.
      `
    });
    this.data = e2;
  }
};
t(W2, "NextjsRouterMocksNotAvailable");
var $ = class $2 extends o2 {
  constructor(e2) {
    super({
      category: "DOCS-TOOLS",
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/issues/26606",
      message: n`
        There was a failure when generating detailed ArgTypes in ${e2.language} for:
        ${JSON.stringify(e2.type, null, 2)} 
        
        Storybook will fall back to use a generic type description instead.

        This type is either not supported or it is a bug in the docgen generation in Storybook.
        If you think this is a bug, please detail it as much as possible in the Github issue.
      `
    });
    this.data = e2;
  }
};
t($, "UnknownArgTypesError");
var oe = $;
var D2 = class D3 extends o2 {
  constructor(e2) {
    super({
      category: "ADDON_VITEST",
      code: 1,
      // TODO: Add documentation about viewports support
      // documentation: '',
      message: n`
        Encountered an unsupported value "${e2.value}" when setting the viewport ${e2.dimension} dimension.
        
        The Storybook plugin only supports values in the following units:
        - px, vh, vw, em, rem and %.
        
        You can either change the viewport for this story to use one of the supported units or skip the test by adding '!test' to the story's tags per https://storybook.js.org/docs/writing-stories/tags
      `
    });
    this.data = e2;
  }
};
t(D2, "UnsupportedViewportDimensionError");
var se = D2;
var C = class C2 extends o2 {
  constructor() {
    super({
      category: "ADDON_A11Y",
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#a11y-addon-replace-element-parameter-with-context-parameter",
      message: 'The "element" parameter in parameters.a11y has been removed. Use "context" instead.'
    });
  }
};
t(C, "ElementA11yParameterError");
var re = C;

// node_modules/.pnpm/storybook@9.0.16_@testing-library+dom@10.4.0_prettier@3.6.2/node_modules/storybook/dist/preview-api/index.js
var qs = Object.create;
var lt = Object.defineProperty;
var Hs = Object.getOwnPropertyDescriptor;
var $s = Object.getOwnPropertyNames;
var Bs = Object.getPrototypeOf;
var Gs = Object.prototype.hasOwnProperty;
var n2 = (t2, e2) => lt(t2, "name", { value: e2, configurable: true });
var $e = ((t2) => typeof __require < "u" ? __require : typeof Proxy < "u" ? new Proxy(t2, {
  get: (e2, r2) => (typeof __require < "u" ? __require : e2)[r2]
}) : t2)(function(t2) {
  if (typeof __require < "u") return __require.apply(this, arguments);
  throw Error('Dynamic require of "' + t2 + '" is not supported');
});
var q3 = (t2, e2) => () => (e2 || t2((e2 = { exports: {} }).exports, e2), e2.exports);
var Eo = (t2, e2) => {
  for (var r2 in e2)
    lt(t2, r2, { get: e2[r2], enumerable: true });
};
var zs = (t2, e2, r2, o3) => {
  if (e2 && typeof e2 == "object" || typeof e2 == "function")
    for (let i2 of $s(e2))
      !Gs.call(t2, i2) && i2 !== r2 && lt(t2, i2, { get: () => e2[i2], enumerable: !(o3 = Hs(e2, i2)) || o3.enumerable });
  return t2;
};
var ve = (t2, e2, r2) => (r2 = t2 != null ? qs(Bs(t2)) : {}, zs(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  e2 || !t2 || !t2.__esModule ? lt(r2, "default", { value: t2, enumerable: true }) : r2,
  t2
));
var cr = q3((nn, lr) => {
  (function(t2) {
    if (typeof nn == "object" && typeof lr < "u")
      lr.exports = t2();
    else if (typeof define == "function" && define.amd)
      define([], t2);
    else {
      var e2;
      typeof window < "u" ? e2 = window : typeof global < "u" ? e2 = global : typeof self < "u" ? e2 = self : e2 = this, e2.memoizerific = t2();
    }
  })(function() {
    var t2, e2, r2;
    return n2(function o3(i2, s, a) {
      function l2(p2, u) {
        if (!s[p2]) {
          if (!i2[p2]) {
            var f3 = typeof $e == "function" && $e;
            if (!u && f3) return f3(p2, true);
            if (c) return c(p2, true);
            var h2 = new Error("Cannot find module '" + p2 + "'");
            throw h2.code = "MODULE_NOT_FOUND", h2;
          }
          var g3 = s[p2] = { exports: {} };
          i2[p2][0].call(g3.exports, function(T3) {
            var x4 = i2[p2][1][T3];
            return l2(x4 || T3);
          }, g3, g3.exports, o3, i2, s, a);
        }
        return s[p2].exports;
      }
      n2(l2, "s");
      for (var c = typeof $e == "function" && $e, d2 = 0; d2 < a.length; d2++) l2(a[d2]);
      return l2;
    }, "e")({ 1: [function(o3, i2, s) {
      i2.exports = function(a) {
        if (typeof Map != "function" || a) {
          var l2 = o3("./similar");
          return new l2();
        } else
          return /* @__PURE__ */ new Map();
      };
    }, { "./similar": 2 }], 2: [function(o3, i2, s) {
      function a() {
        return this.list = [], this.lastItem = void 0, this.size = 0, this;
      }
      n2(a, "Similar"), a.prototype.get = function(l2) {
        var c;
        if (this.lastItem && this.isEqual(this.lastItem.key, l2))
          return this.lastItem.val;
        if (c = this.indexOf(l2), c >= 0)
          return this.lastItem = this.list[c], this.list[c].val;
      }, a.prototype.set = function(l2, c) {
        var d2;
        return this.lastItem && this.isEqual(this.lastItem.key, l2) ? (this.lastItem.val = c, this) : (d2 = this.indexOf(l2), d2 >= 0 ? (this.lastItem = this.list[d2], this.list[d2].val = c, this) : (this.lastItem = { key: l2, val: c }, this.list.push(this.lastItem), this.size++, this));
      }, a.prototype.delete = function(l2) {
        var c;
        if (this.lastItem && this.isEqual(this.lastItem.key, l2) && (this.lastItem = void 0), c = this.indexOf(l2), c >= 0)
          return this.size--, this.list.splice(c, 1)[0];
      }, a.prototype.has = function(l2) {
        var c;
        return this.lastItem && this.isEqual(this.lastItem.key, l2) ? true : (c = this.indexOf(l2), c >= 0 ? (this.lastItem = this.list[c], true) : false);
      }, a.prototype.forEach = function(l2, c) {
        var d2;
        for (d2 = 0; d2 < this.size; d2++)
          l2.call(c || this, this.list[d2].val, this.list[d2].key, this);
      }, a.prototype.indexOf = function(l2) {
        var c;
        for (c = 0; c < this.size; c++)
          if (this.isEqual(this.list[c].key, l2))
            return c;
        return -1;
      }, a.prototype.isEqual = function(l2, c) {
        return l2 === c || l2 !== l2 && c !== c;
      }, i2.exports = a;
    }, {}], 3: [function(o3, i2, s) {
      var a = o3("map-or-similar");
      i2.exports = function(p2) {
        var u = new a(false), f3 = [];
        return function(h2) {
          var g3 = n2(function() {
            var T3 = u, x4, v3, E = arguments.length - 1, y = Array(E + 1), w4 = true, A3;
            if ((g3.numArgs || g3.numArgs === 0) && g3.numArgs !== E + 1)
              throw new Error("Memoizerific functions should always be called with the same number of arguments");
            for (A3 = 0; A3 < E; A3++) {
              if (y[A3] = {
                cacheItem: T3,
                arg: arguments[A3]
              }, T3.has(arguments[A3])) {
                T3 = T3.get(arguments[A3]);
                continue;
              }
              w4 = false, x4 = new a(false), T3.set(arguments[A3], x4), T3 = x4;
            }
            return w4 && (T3.has(arguments[E]) ? v3 = T3.get(arguments[E]) : w4 = false), w4 || (v3 = h2.apply(null, arguments), T3.set(arguments[E], v3)), p2 > 0 && (y[E] = {
              cacheItem: T3,
              arg: arguments[E]
            }, w4 ? l2(f3, y) : f3.push(y), f3.length > p2 && c(f3.shift())), g3.wasMemoized = w4, g3.numArgs = E + 1, v3;
          }, "memoizerific");
          return g3.limit = p2, g3.wasMemoized = false, g3.cache = u, g3.lru = f3, g3;
        };
      };
      function l2(p2, u) {
        var f3 = p2.length, h2 = u.length, g3, T3, x4;
        for (T3 = 0; T3 < f3; T3++) {
          for (g3 = true, x4 = 0; x4 < h2; x4++)
            if (!d2(p2[T3][x4].arg, u[x4].arg)) {
              g3 = false;
              break;
            }
          if (g3)
            break;
        }
        p2.push(p2.splice(T3, 1)[0]);
      }
      n2(l2, "moveToMostRecentLru");
      function c(p2) {
        var u = p2.length, f3 = p2[u - 1], h2, g3;
        for (f3.cacheItem.delete(f3.arg), g3 = u - 2; g3 >= 0 && (f3 = p2[g3], h2 = f3.cacheItem.get(f3.arg), !h2 || !h2.size); g3--)
          f3.cacheItem.delete(f3.arg);
      }
      n2(c, "removeCachedResult");
      function d2(p2, u) {
        return p2 === u || p2 !== p2 && u !== u;
      }
      n2(d2, "isEqual");
    }, { "map-or-similar": 1 }] }, {}, [3])(3);
  });
});
var no = q3((oo) => {
  "use strict";
  Object.defineProperty(oo, "__esModule", { value: true });
  oo.encodeString = ad;
  var Q3 = Array.from({ length: 256 }, (t2, e2) => "%" + ((e2 < 16 ? "0" : "") + e2.toString(16)).toUpperCase()), sd = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
  ]);
  function ad(t2) {
    let e2 = t2.length;
    if (e2 === 0)
      return "";
    let r2 = "", o3 = 0, i2 = 0;
    e: for (; i2 < e2; i2++) {
      let s = t2.charCodeAt(i2);
      for (; s < 128; ) {
        if (sd[s] !== 1 && (o3 < i2 && (r2 += t2.slice(o3, i2)), o3 = i2 + 1, r2 += Q3[s]), ++i2 === e2)
          break e;
        s = t2.charCodeAt(i2);
      }
      if (o3 < i2 && (r2 += t2.slice(o3, i2)), s < 2048) {
        o3 = i2 + 1, r2 += Q3[192 | s >> 6] + Q3[128 | s & 63];
        continue;
      }
      if (s < 55296 || s >= 57344) {
        o3 = i2 + 1, r2 += Q3[224 | s >> 12] + Q3[128 | s >> 6 & 63] + Q3[128 | s & 63];
        continue;
      }
      if (++i2, i2 >= e2)
        throw new Error("URI malformed");
      let a = t2.charCodeAt(i2) & 1023;
      o3 = i2 + 1, s = 65536 + ((s & 1023) << 10 | a), r2 += Q3[240 | s >> 18] + Q3[128 | s >> 12 & 63] + Q3[128 | s >> 6 & 63] + Q3[128 | s & 63];
    }
    return o3 === 0 ? t2 : o3 < e2 ? r2 + t2.slice(o3) : r2;
  }
  n2(ad, "encodeString");
});
var kt = q3((ee) => {
  "use strict";
  Object.defineProperty(ee, "__esModule", { value: true });
  ee.defaultOptions = ee.defaultShouldSerializeObject = ee.defaultValueSerializer = void 0;
  var io = no(), ld = n2((t2) => {
    switch (typeof t2) {
      case "string":
        return (0, io.encodeString)(t2);
      case "bigint":
      case "boolean":
        return "" + t2;
      case "number":
        if (Number.isFinite(t2))
          return t2 < 1e21 ? "" + t2 : (0, io.encodeString)("" + t2);
        break;
    }
    return t2 instanceof Date ? (0, io.encodeString)(t2.toISOString()) : "";
  }, "defaultValueSerializer");
  ee.defaultValueSerializer = ld;
  var cd = n2((t2) => t2 instanceof Date, "defaultShouldSerializeObject");
  ee.defaultShouldSerializeObject = cd;
  var _i = n2((t2) => t2, "identityFunc");
  ee.defaultOptions = {
    nesting: true,
    nestingSyntax: "dot",
    arrayRepeat: false,
    arrayRepeatSyntax: "repeat",
    delimiter: 38,
    valueDeserializer: _i,
    valueSerializer: ee.defaultValueSerializer,
    keyDeserializer: _i,
    shouldSerializeObject: ee.defaultShouldSerializeObject
  };
});
var so = q3((Dt) => {
  "use strict";
  Object.defineProperty(Dt, "__esModule", { value: true });
  Dt.getDeepObject = ud;
  Dt.stringifyObject = ji;
  var we = kt(), dd = no();
  function pd(t2) {
    return t2 === "__proto__" || t2 === "constructor" || t2 === "prototype";
  }
  n2(pd, "isPrototypeKey");
  function ud(t2, e2, r2, o3, i2) {
    if (pd(e2))
      return t2;
    let s = t2[e2];
    return typeof s == "object" && s !== null ? s : !o3 && (i2 || typeof r2 == "number" || typeof r2 == "string" && r2 * 0 === 0 && r2.indexOf(".") === -1) ? t2[e2] = [] : t2[e2] = {};
  }
  n2(ud, "getDeepObject");
  var fd = 20, md = "[]", yd = "[", hd = "]", gd = ".";
  function ji(t2, e2, r2 = 0, o3, i2) {
    let { nestingSyntax: s = we.defaultOptions.nestingSyntax, arrayRepeat: a = we.defaultOptions.arrayRepeat, arrayRepeatSyntax: l2 = we.defaultOptions.arrayRepeatSyntax, nesting: c = we.defaultOptions.nesting, delimiter: d2 = we.defaultOptions.delimiter, valueSerializer: p2 = we.defaultOptions.valueSerializer, shouldSerializeObject: u = we.defaultOptions.shouldSerializeObject } = e2, f3 = typeof d2 == "number" ? String.fromCharCode(
      d2
    ) : d2, h2 = i2 === true && a, g3 = s === "dot" || s === "js" && !i2;
    if (r2 > fd)
      return "";
    let T3 = "", x4 = true, v3 = false;
    for (let E in t2) {
      let y = t2[E], w4;
      o3 ? (w4 = o3, h2 ? l2 === "bracket" && (w4 += md) : g3 ? (w4 += gd, w4 += E) : (w4 += yd, w4 += E, w4 += hd)) : w4 = E, x4 || (T3 += f3), typeof y == "object" && y !== null && !u(y) ? (v3 = y.pop !== void 0, (c || a && v3) && (T3 += ji(y, e2, r2 + 1, w4, v3))) : (T3 += (0, dd.encodeString)(w4), T3 += "=", T3 += p2(y, E)), x4 && (x4 = false);
    }
    return T3;
  }
  n2(ji, "stringifyObject");
});
var $i = q3((Eb, Hi) => {
  "use strict";
  var Ni = 12, bd = 0, ao = [
    // The first part of the table maps bytes to character to a transition.
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    // The second part of the table maps a state to a new state when adding a
    // transition.
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // The third part maps the current transition to a mask that needs to apply
    // to the byte.
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  function Sd(t2) {
    var e2 = t2.indexOf("%");
    if (e2 === -1) return t2;
    for (var r2 = t2.length, o3 = "", i2 = 0, s = 0, a = e2, l2 = Ni; e2 > -1 && e2 < r2; ) {
      var c = qi(t2[e2 + 1], 4), d2 = qi(t2[e2 + 2], 0), p2 = c | d2, u = ao[p2];
      if (l2 = ao[256 + l2 + u], s = s << 6 | p2 & ao[364 + u], l2 === Ni)
        o3 += t2.slice(i2, a), o3 += s <= 65535 ? String.fromCharCode(s) : String.fromCharCode(
          55232 + (s >> 10),
          56320 + (s & 1023)
        ), s = 0, i2 = e2 + 3, e2 = a = t2.indexOf("%", i2);
      else {
        if (l2 === bd)
          return null;
        if (e2 += 3, e2 < r2 && t2.charCodeAt(e2) === 37) continue;
        return null;
      }
    }
    return o3 + t2.slice(i2);
  }
  n2(Sd, "decodeURIComponent");
  var xd = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  function qi(t2, e2) {
    var r2 = xd[t2];
    return r2 === void 0 ? 255 : r2 << e2;
  }
  n2(qi, "hexCodeToInt");
  Hi.exports = Sd;
});
var Ui = q3((ie2) => {
  "use strict";
  var Td = ie2 && ie2.__importDefault || function(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  };
  Object.defineProperty(ie2, "__esModule", { value: true });
  ie2.numberValueDeserializer = ie2.numberKeyDeserializer = void 0;
  ie2.parse = Ed;
  var Mt = so(), Re = kt(), Bi = Td($i()), wd = n2((t2) => {
    let e2 = Number(t2);
    return Number.isNaN(e2) ? t2 : e2;
  }, "numberKeyDeserializer");
  ie2.numberKeyDeserializer = wd;
  var Rd = n2((t2) => {
    let e2 = Number(t2);
    return Number.isNaN(e2) ? t2 : e2;
  }, "numberValueDeserializer");
  ie2.numberValueDeserializer = Rd;
  var Gi = /\+/g, zi = n2(function() {
  }, "Empty");
  zi.prototype = /* @__PURE__ */ Object.create(null);
  function Lt(t2, e2, r2, o3, i2) {
    let s = t2.substring(e2, r2);
    return o3 && (s = s.replace(Gi, " ")), i2 && (s = (0, Bi.default)(s) || s), s;
  }
  n2(Lt, "computeKeySlice");
  function Ed(t2, e2) {
    let { valueDeserializer: r2 = Re.defaultOptions.valueDeserializer, keyDeserializer: o3 = Re.defaultOptions.keyDeserializer, arrayRepeatSyntax: i2 = Re.defaultOptions.arrayRepeatSyntax, nesting: s = Re.defaultOptions.nesting, arrayRepeat: a = Re.defaultOptions.arrayRepeat, nestingSyntax: l2 = Re.defaultOptions.nestingSyntax, delimiter: c = Re.defaultOptions.delimiter } = e2 ?? {}, d2 = typeof c == "string" ? c.charCodeAt(0) : c, p2 = l2 === "js", u = new zi();
    if (typeof t2 != "string")
      return u;
    let f3 = t2.length, h2 = "", g3 = -1, T3 = -1, x4 = -1, v3 = u, E, y = "", w4 = "", A3 = false, P4 = false, m2 = false, b4 = false, S3 = false, C3 = false, R3 = false, I5 = 0, F2 = -1, k3 = -1, B3 = -1;
    for (let L3 = 0; L3 < f3 + 1; L3++) {
      if (I5 = L3 !== f3 ? t2.charCodeAt(L3) : d2, I5 === d2) {
        if (R3 = T3 > g3, R3 || (T3 = L3), x4 !== T3 - 1 && (w4 = Lt(t2, x4 + 1, F2 > -1 ? F2 : T3, m2, A3), y = o3(w4), E !== void 0 && (v3 = (0, Mt.getDeepObject)(
          v3,
          E,
          y,
          p2 && S3,
          p2 && C3
        ))), R3 || y !== "") {
          R3 && (h2 = t2.slice(T3 + 1, L3), b4 && (h2 = h2.replace(Gi, " ")), P4 && (h2 = (0, Bi.default)(h2) || h2));
          let X4 = r2(h2, y);
          if (a) {
            let ye = v3[y];
            ye === void 0 ? F2 > -1 ? v3[y] = [X4] : v3[y] = X4 : ye.pop ? ye.push(X4) : v3[y] = [ye, X4];
          } else
            v3[y] = X4;
        }
        h2 = "", g3 = L3, T3 = L3, A3 = false, P4 = false, m2 = false, b4 = false, S3 = false, C3 = false, F2 = -1, x4 = L3, v3 = u, E = void 0, y = "";
      } else I5 === 93 ? (a && i2 === "bracket" && B3 === 91 && (F2 = k3), s && (l2 === "index" || p2) && T3 <= g3 && (x4 !== k3 && (w4 = Lt(
        t2,
        x4 + 1,
        L3,
        m2,
        A3
      ), y = o3(w4), E !== void 0 && (v3 = (0, Mt.getDeepObject)(v3, E, y, void 0, p2)), E = y, m2 = false, A3 = false), x4 = L3, C3 = true, S3 = false)) : I5 === 46 ? s && (l2 === "dot" || p2) && T3 <= g3 && (x4 !== k3 && (w4 = Lt(t2, x4 + 1, L3, m2, A3), y = o3(w4), E !== void 0 && (v3 = (0, Mt.getDeepObject)(
        v3,
        E,
        y,
        p2
      )), E = y, m2 = false, A3 = false), S3 = true, C3 = false, x4 = L3) : I5 === 91 ? s && (l2 === "index" || p2) && T3 <= g3 && (x4 !== k3 && (w4 = Lt(
        t2,
        x4 + 1,
        L3,
        m2,
        A3
      ), y = o3(w4), p2 && E !== void 0 && (v3 = (0, Mt.getDeepObject)(v3, E, y, p2)), E = y, m2 = false, A3 = false, S3 = false, C3 = true), x4 = L3) : I5 === 61 ? T3 <= g3 ? T3 = L3 : P4 = true : I5 === 43 ? T3 > g3 ? b4 = true : m2 = true : I5 === 37 && (T3 > g3 ? P4 = true : A3 = true);
      k3 = L3, B3 = I5;
    }
    return u;
  }
  n2(Ed, "parse");
});
var Vi = q3((lo) => {
  "use strict";
  Object.defineProperty(lo, "__esModule", { value: true });
  lo.stringify = vd;
  var Ad = so();
  function vd(t2, e2) {
    if (t2 === null || typeof t2 != "object")
      return "";
    let r2 = e2 ?? {};
    return (0, Ad.stringifyObject)(t2, r2);
  }
  n2(vd, "stringify");
});
var _t = q3((K4) => {
  "use strict";
  var Cd = K4 && K4.__createBinding || (Object.create ? function(t2, e2, r2, o3) {
    o3 === void 0 && (o3 = r2);
    var i2 = Object.getOwnPropertyDescriptor(e2, r2);
    (!i2 || ("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable)) && (i2 = { enumerable: true, get: n2(function() {
      return e2[r2];
    }, "get") }), Object.defineProperty(t2, o3, i2);
  } : function(t2, e2, r2, o3) {
    o3 === void 0 && (o3 = r2), t2[o3] = e2[r2];
  }), Pd = K4 && K4.__exportStar || function(t2, e2) {
    for (var r2 in t2) r2 !== "default" && !Object.prototype.hasOwnProperty.call(e2, r2) && Cd(e2, t2, r2);
  };
  Object.defineProperty(K4, "__esModule", { value: true });
  K4.stringify = K4.parse = void 0;
  var Fd = Ui();
  Object.defineProperty(K4, "parse", { enumerable: true, get: n2(function() {
    return Fd.parse;
  }, "get") });
  var Id = Vi();
  Object.defineProperty(K4, "stringify", { enumerable: true, get: n2(function() {
    return Id.stringify;
  }, "get") });
  Pd(kt(), K4);
});
var fo = q3(($b, qd) => {
  qd.exports = {
    Aacute: "Á",
    aacute: "á",
    Abreve: "Ă",
    abreve: "ă",
    ac: "∾",
    acd: "∿",
    acE: "∾̳",
    Acirc: "Â",
    acirc: "â",
    acute: "´",
    Acy: "А",
    acy: "а",
    AElig: "Æ",
    aelig: "æ",
    af: "⁡",
    Afr: "𝔄",
    afr: "𝔞",
    Agrave: "À",
    agrave: "à",
    alefsym: "ℵ",
    aleph: "ℵ",
    Alpha: "Α",
    alpha: "α",
    Amacr: "Ā",
    amacr: "ā",
    amalg: "⨿",
    amp: "&",
    AMP: "&",
    andand: "⩕",
    And: "⩓",
    and: "∧",
    andd: "⩜",
    andslope: "⩘",
    andv: "⩚",
    ang: "∠",
    ange: "⦤",
    angle: "∠",
    angmsdaa: "⦨",
    angmsdab: "⦩",
    angmsdac: "⦪",
    angmsdad: "⦫",
    angmsdae: "⦬",
    angmsdaf: "⦭",
    angmsdag: "⦮",
    angmsdah: "⦯",
    angmsd: "∡",
    angrt: "∟",
    angrtvb: "⊾",
    angrtvbd: "⦝",
    angsph: "∢",
    angst: "Å",
    angzarr: "⍼",
    Aogon: "Ą",
    aogon: "ą",
    Aopf: "𝔸",
    aopf: "𝕒",
    apacir: "⩯",
    ap: "≈",
    apE: "⩰",
    ape: "≊",
    apid: "≋",
    apos: "'",
    ApplyFunction: "⁡",
    approx: "≈",
    approxeq: "≊",
    Aring: "Å",
    aring: "å",
    Ascr: "𝒜",
    ascr: "𝒶",
    Assign: "≔",
    ast: "*",
    asymp: "≈",
    asympeq: "≍",
    Atilde: "Ã",
    atilde: "ã",
    Auml: "Ä",
    auml: "ä",
    awconint: "∳",
    awint: "⨑",
    backcong: "≌",
    backepsilon: "϶",
    backprime: "‵",
    backsim: "∽",
    backsimeq: "⋍",
    Backslash: "∖",
    Barv: "⫧",
    barvee: "⊽",
    barwed: "⌅",
    Barwed: "⌆",
    barwedge: "⌅",
    bbrk: "⎵",
    bbrktbrk: "⎶",
    bcong: "≌",
    Bcy: "Б",
    bcy: "б",
    bdquo: "„",
    becaus: "∵",
    because: "∵",
    Because: "∵",
    bemptyv: "⦰",
    bepsi: "϶",
    bernou: "ℬ",
    Bernoullis: "ℬ",
    Beta: "Β",
    beta: "β",
    beth: "ℶ",
    between: "≬",
    Bfr: "𝔅",
    bfr: "𝔟",
    bigcap: "⋂",
    bigcirc: "◯",
    bigcup: "⋃",
    bigodot: "⨀",
    bigoplus: "⨁",
    bigotimes: "⨂",
    bigsqcup: "⨆",
    bigstar: "★",
    bigtriangledown: "▽",
    bigtriangleup: "△",
    biguplus: "⨄",
    bigvee: "⋁",
    bigwedge: "⋀",
    bkarow: "⤍",
    blacklozenge: "⧫",
    blacksquare: "▪",
    blacktriangle: "▴",
    blacktriangledown: "▾",
    blacktriangleleft: "◂",
    blacktriangleright: "▸",
    blank: "␣",
    blk12: "▒",
    blk14: "░",
    blk34: "▓",
    block: "█",
    bne: "=⃥",
    bnequiv: "≡⃥",
    bNot: "⫭",
    bnot: "⌐",
    Bopf: "𝔹",
    bopf: "𝕓",
    bot: "⊥",
    bottom: "⊥",
    bowtie: "⋈",
    boxbox: "⧉",
    boxdl: "┐",
    boxdL: "╕",
    boxDl: "╖",
    boxDL: "╗",
    boxdr: "┌",
    boxdR: "╒",
    boxDr: "╓",
    boxDR: "╔",
    boxh: "─",
    boxH: "═",
    boxhd: "┬",
    boxHd: "╤",
    boxhD: "╥",
    boxHD: "╦",
    boxhu: "┴",
    boxHu: "╧",
    boxhU: "╨",
    boxHU: "╩",
    boxminus: "⊟",
    boxplus: "⊞",
    boxtimes: "⊠",
    boxul: "┘",
    boxuL: "╛",
    boxUl: "╜",
    boxUL: "╝",
    boxur: "└",
    boxuR: "╘",
    boxUr: "╙",
    boxUR: "╚",
    boxv: "│",
    boxV: "║",
    boxvh: "┼",
    boxvH: "╪",
    boxVh: "╫",
    boxVH: "╬",
    boxvl: "┤",
    boxvL: "╡",
    boxVl: "╢",
    boxVL: "╣",
    boxvr: "├",
    boxvR: "╞",
    boxVr: "╟",
    boxVR: "╠",
    bprime: "‵",
    breve: "˘",
    Breve: "˘",
    brvbar: "¦",
    bscr: "𝒷",
    Bscr: "ℬ",
    bsemi: "⁏",
    bsim: "∽",
    bsime: "⋍",
    bsolb: "⧅",
    bsol: "\\",
    bsolhsub: "⟈",
    bull: "•",
    bullet: "•",
    bump: "≎",
    bumpE: "⪮",
    bumpe: "≏",
    Bumpeq: "≎",
    bumpeq: "≏",
    Cacute: "Ć",
    cacute: "ć",
    capand: "⩄",
    capbrcup: "⩉",
    capcap: "⩋",
    cap: "∩",
    Cap: "⋒",
    capcup: "⩇",
    capdot: "⩀",
    CapitalDifferentialD: "ⅅ",
    caps: "∩︀",
    caret: "⁁",
    caron: "ˇ",
    Cayleys: "ℭ",
    ccaps: "⩍",
    Ccaron: "Č",
    ccaron: "č",
    Ccedil: "Ç",
    ccedil: "ç",
    Ccirc: "Ĉ",
    ccirc: "ĉ",
    Cconint: "∰",
    ccups: "⩌",
    ccupssm: "⩐",
    Cdot: "Ċ",
    cdot: "ċ",
    cedil: "¸",
    Cedilla: "¸",
    cemptyv: "⦲",
    cent: "¢",
    centerdot: "·",
    CenterDot: "·",
    cfr: "𝔠",
    Cfr: "ℭ",
    CHcy: "Ч",
    chcy: "ч",
    check: "✓",
    checkmark: "✓",
    Chi: "Χ",
    chi: "χ",
    circ: "ˆ",
    circeq: "≗",
    circlearrowleft: "↺",
    circlearrowright: "↻",
    circledast: "⊛",
    circledcirc: "⊚",
    circleddash: "⊝",
    CircleDot: "⊙",
    circledR: "®",
    circledS: "Ⓢ",
    CircleMinus: "⊖",
    CirclePlus: "⊕",
    CircleTimes: "⊗",
    cir: "○",
    cirE: "⧃",
    cire: "≗",
    cirfnint: "⨐",
    cirmid: "⫯",
    cirscir: "⧂",
    ClockwiseContourIntegral: "∲",
    CloseCurlyDoubleQuote: "”",
    CloseCurlyQuote: "’",
    clubs: "♣",
    clubsuit: "♣",
    colon: ":",
    Colon: "∷",
    Colone: "⩴",
    colone: "≔",
    coloneq: "≔",
    comma: ",",
    commat: "@",
    comp: "∁",
    compfn: "∘",
    complement: "∁",
    complexes: "ℂ",
    cong: "≅",
    congdot: "⩭",
    Congruent: "≡",
    conint: "∮",
    Conint: "∯",
    ContourIntegral: "∮",
    copf: "𝕔",
    Copf: "ℂ",
    coprod: "∐",
    Coproduct: "∐",
    copy: "©",
    COPY: "©",
    copysr: "℗",
    CounterClockwiseContourIntegral: "∳",
    crarr: "↵",
    cross: "✗",
    Cross: "⨯",
    Cscr: "𝒞",
    cscr: "𝒸",
    csub: "⫏",
    csube: "⫑",
    csup: "⫐",
    csupe: "⫒",
    ctdot: "⋯",
    cudarrl: "⤸",
    cudarrr: "⤵",
    cuepr: "⋞",
    cuesc: "⋟",
    cularr: "↶",
    cularrp: "⤽",
    cupbrcap: "⩈",
    cupcap: "⩆",
    CupCap: "≍",
    cup: "∪",
    Cup: "⋓",
    cupcup: "⩊",
    cupdot: "⊍",
    cupor: "⩅",
    cups: "∪︀",
    curarr: "↷",
    curarrm: "⤼",
    curlyeqprec: "⋞",
    curlyeqsucc: "⋟",
    curlyvee: "⋎",
    curlywedge: "⋏",
    curren: "¤",
    curvearrowleft: "↶",
    curvearrowright: "↷",
    cuvee: "⋎",
    cuwed: "⋏",
    cwconint: "∲",
    cwint: "∱",
    cylcty: "⌭",
    dagger: "†",
    Dagger: "‡",
    daleth: "ℸ",
    darr: "↓",
    Darr: "↡",
    dArr: "⇓",
    dash: "‐",
    Dashv: "⫤",
    dashv: "⊣",
    dbkarow: "⤏",
    dblac: "˝",
    Dcaron: "Ď",
    dcaron: "ď",
    Dcy: "Д",
    dcy: "д",
    ddagger: "‡",
    ddarr: "⇊",
    DD: "ⅅ",
    dd: "ⅆ",
    DDotrahd: "⤑",
    ddotseq: "⩷",
    deg: "°",
    Del: "∇",
    Delta: "Δ",
    delta: "δ",
    demptyv: "⦱",
    dfisht: "⥿",
    Dfr: "𝔇",
    dfr: "𝔡",
    dHar: "⥥",
    dharl: "⇃",
    dharr: "⇂",
    DiacriticalAcute: "´",
    DiacriticalDot: "˙",
    DiacriticalDoubleAcute: "˝",
    DiacriticalGrave: "`",
    DiacriticalTilde: "˜",
    diam: "⋄",
    diamond: "⋄",
    Diamond: "⋄",
    diamondsuit: "♦",
    diams: "♦",
    die: "¨",
    DifferentialD: "ⅆ",
    digamma: "ϝ",
    disin: "⋲",
    div: "÷",
    divide: "÷",
    divideontimes: "⋇",
    divonx: "⋇",
    DJcy: "Ђ",
    djcy: "ђ",
    dlcorn: "⌞",
    dlcrop: "⌍",
    dollar: "$",
    Dopf: "𝔻",
    dopf: "𝕕",
    Dot: "¨",
    dot: "˙",
    DotDot: "⃜",
    doteq: "≐",
    doteqdot: "≑",
    DotEqual: "≐",
    dotminus: "∸",
    dotplus: "∔",
    dotsquare: "⊡",
    doublebarwedge: "⌆",
    DoubleContourIntegral: "∯",
    DoubleDot: "¨",
    DoubleDownArrow: "⇓",
    DoubleLeftArrow: "⇐",
    DoubleLeftRightArrow: "⇔",
    DoubleLeftTee: "⫤",
    DoubleLongLeftArrow: "⟸",
    DoubleLongLeftRightArrow: "⟺",
    DoubleLongRightArrow: "⟹",
    DoubleRightArrow: "⇒",
    DoubleRightTee: "⊨",
    DoubleUpArrow: "⇑",
    DoubleUpDownArrow: "⇕",
    DoubleVerticalBar: "∥",
    DownArrowBar: "⤓",
    downarrow: "↓",
    DownArrow: "↓",
    Downarrow: "⇓",
    DownArrowUpArrow: "⇵",
    DownBreve: "̑",
    downdownarrows: "⇊",
    downharpoonleft: "⇃",
    downharpoonright: "⇂",
    DownLeftRightVector: "⥐",
    DownLeftTeeVector: "⥞",
    DownLeftVectorBar: "⥖",
    DownLeftVector: "↽",
    DownRightTeeVector: "⥟",
    DownRightVectorBar: "⥗",
    DownRightVector: "⇁",
    DownTeeArrow: "↧",
    DownTee: "⊤",
    drbkarow: "⤐",
    drcorn: "⌟",
    drcrop: "⌌",
    Dscr: "𝒟",
    dscr: "𝒹",
    DScy: "Ѕ",
    dscy: "ѕ",
    dsol: "⧶",
    Dstrok: "Đ",
    dstrok: "đ",
    dtdot: "⋱",
    dtri: "▿",
    dtrif: "▾",
    duarr: "⇵",
    duhar: "⥯",
    dwangle: "⦦",
    DZcy: "Џ",
    dzcy: "џ",
    dzigrarr: "⟿",
    Eacute: "É",
    eacute: "é",
    easter: "⩮",
    Ecaron: "Ě",
    ecaron: "ě",
    Ecirc: "Ê",
    ecirc: "ê",
    ecir: "≖",
    ecolon: "≕",
    Ecy: "Э",
    ecy: "э",
    eDDot: "⩷",
    Edot: "Ė",
    edot: "ė",
    eDot: "≑",
    ee: "ⅇ",
    efDot: "≒",
    Efr: "𝔈",
    efr: "𝔢",
    eg: "⪚",
    Egrave: "È",
    egrave: "è",
    egs: "⪖",
    egsdot: "⪘",
    el: "⪙",
    Element: "∈",
    elinters: "⏧",
    ell: "ℓ",
    els: "⪕",
    elsdot: "⪗",
    Emacr: "Ē",
    emacr: "ē",
    empty: "∅",
    emptyset: "∅",
    EmptySmallSquare: "◻",
    emptyv: "∅",
    EmptyVerySmallSquare: "▫",
    emsp13: " ",
    emsp14: " ",
    emsp: " ",
    ENG: "Ŋ",
    eng: "ŋ",
    ensp: " ",
    Eogon: "Ę",
    eogon: "ę",
    Eopf: "𝔼",
    eopf: "𝕖",
    epar: "⋕",
    eparsl: "⧣",
    eplus: "⩱",
    epsi: "ε",
    Epsilon: "Ε",
    epsilon: "ε",
    epsiv: "ϵ",
    eqcirc: "≖",
    eqcolon: "≕",
    eqsim: "≂",
    eqslantgtr: "⪖",
    eqslantless: "⪕",
    Equal: "⩵",
    equals: "=",
    EqualTilde: "≂",
    equest: "≟",
    Equilibrium: "⇌",
    equiv: "≡",
    equivDD: "⩸",
    eqvparsl: "⧥",
    erarr: "⥱",
    erDot: "≓",
    escr: "ℯ",
    Escr: "ℰ",
    esdot: "≐",
    Esim: "⩳",
    esim: "≂",
    Eta: "Η",
    eta: "η",
    ETH: "Ð",
    eth: "ð",
    Euml: "Ë",
    euml: "ë",
    euro: "€",
    excl: "!",
    exist: "∃",
    Exists: "∃",
    expectation: "ℰ",
    exponentiale: "ⅇ",
    ExponentialE: "ⅇ",
    fallingdotseq: "≒",
    Fcy: "Ф",
    fcy: "ф",
    female: "♀",
    ffilig: "ﬃ",
    fflig: "ﬀ",
    ffllig: "ﬄ",
    Ffr: "𝔉",
    ffr: "𝔣",
    filig: "ﬁ",
    FilledSmallSquare: "◼",
    FilledVerySmallSquare: "▪",
    fjlig: "fj",
    flat: "♭",
    fllig: "ﬂ",
    fltns: "▱",
    fnof: "ƒ",
    Fopf: "𝔽",
    fopf: "𝕗",
    forall: "∀",
    ForAll: "∀",
    fork: "⋔",
    forkv: "⫙",
    Fouriertrf: "ℱ",
    fpartint: "⨍",
    frac12: "½",
    frac13: "⅓",
    frac14: "¼",
    frac15: "⅕",
    frac16: "⅙",
    frac18: "⅛",
    frac23: "⅔",
    frac25: "⅖",
    frac34: "¾",
    frac35: "⅗",
    frac38: "⅜",
    frac45: "⅘",
    frac56: "⅚",
    frac58: "⅝",
    frac78: "⅞",
    frasl: "⁄",
    frown: "⌢",
    fscr: "𝒻",
    Fscr: "ℱ",
    gacute: "ǵ",
    Gamma: "Γ",
    gamma: "γ",
    Gammad: "Ϝ",
    gammad: "ϝ",
    gap: "⪆",
    Gbreve: "Ğ",
    gbreve: "ğ",
    Gcedil: "Ģ",
    Gcirc: "Ĝ",
    gcirc: "ĝ",
    Gcy: "Г",
    gcy: "г",
    Gdot: "Ġ",
    gdot: "ġ",
    ge: "≥",
    gE: "≧",
    gEl: "⪌",
    gel: "⋛",
    geq: "≥",
    geqq: "≧",
    geqslant: "⩾",
    gescc: "⪩",
    ges: "⩾",
    gesdot: "⪀",
    gesdoto: "⪂",
    gesdotol: "⪄",
    gesl: "⋛︀",
    gesles: "⪔",
    Gfr: "𝔊",
    gfr: "𝔤",
    gg: "≫",
    Gg: "⋙",
    ggg: "⋙",
    gimel: "ℷ",
    GJcy: "Ѓ",
    gjcy: "ѓ",
    gla: "⪥",
    gl: "≷",
    glE: "⪒",
    glj: "⪤",
    gnap: "⪊",
    gnapprox: "⪊",
    gne: "⪈",
    gnE: "≩",
    gneq: "⪈",
    gneqq: "≩",
    gnsim: "⋧",
    Gopf: "𝔾",
    gopf: "𝕘",
    grave: "`",
    GreaterEqual: "≥",
    GreaterEqualLess: "⋛",
    GreaterFullEqual: "≧",
    GreaterGreater: "⪢",
    GreaterLess: "≷",
    GreaterSlantEqual: "⩾",
    GreaterTilde: "≳",
    Gscr: "𝒢",
    gscr: "ℊ",
    gsim: "≳",
    gsime: "⪎",
    gsiml: "⪐",
    gtcc: "⪧",
    gtcir: "⩺",
    gt: ">",
    GT: ">",
    Gt: "≫",
    gtdot: "⋗",
    gtlPar: "⦕",
    gtquest: "⩼",
    gtrapprox: "⪆",
    gtrarr: "⥸",
    gtrdot: "⋗",
    gtreqless: "⋛",
    gtreqqless: "⪌",
    gtrless: "≷",
    gtrsim: "≳",
    gvertneqq: "≩︀",
    gvnE: "≩︀",
    Hacek: "ˇ",
    hairsp: " ",
    half: "½",
    hamilt: "ℋ",
    HARDcy: "Ъ",
    hardcy: "ъ",
    harrcir: "⥈",
    harr: "↔",
    hArr: "⇔",
    harrw: "↭",
    Hat: "^",
    hbar: "ℏ",
    Hcirc: "Ĥ",
    hcirc: "ĥ",
    hearts: "♥",
    heartsuit: "♥",
    hellip: "…",
    hercon: "⊹",
    hfr: "𝔥",
    Hfr: "ℌ",
    HilbertSpace: "ℋ",
    hksearow: "⤥",
    hkswarow: "⤦",
    hoarr: "⇿",
    homtht: "∻",
    hookleftarrow: "↩",
    hookrightarrow: "↪",
    hopf: "𝕙",
    Hopf: "ℍ",
    horbar: "―",
    HorizontalLine: "─",
    hscr: "𝒽",
    Hscr: "ℋ",
    hslash: "ℏ",
    Hstrok: "Ħ",
    hstrok: "ħ",
    HumpDownHump: "≎",
    HumpEqual: "≏",
    hybull: "⁃",
    hyphen: "‐",
    Iacute: "Í",
    iacute: "í",
    ic: "⁣",
    Icirc: "Î",
    icirc: "î",
    Icy: "И",
    icy: "и",
    Idot: "İ",
    IEcy: "Е",
    iecy: "е",
    iexcl: "¡",
    iff: "⇔",
    ifr: "𝔦",
    Ifr: "ℑ",
    Igrave: "Ì",
    igrave: "ì",
    ii: "ⅈ",
    iiiint: "⨌",
    iiint: "∭",
    iinfin: "⧜",
    iiota: "℩",
    IJlig: "Ĳ",
    ijlig: "ĳ",
    Imacr: "Ī",
    imacr: "ī",
    image: "ℑ",
    ImaginaryI: "ⅈ",
    imagline: "ℐ",
    imagpart: "ℑ",
    imath: "ı",
    Im: "ℑ",
    imof: "⊷",
    imped: "Ƶ",
    Implies: "⇒",
    incare: "℅",
    in: "∈",
    infin: "∞",
    infintie: "⧝",
    inodot: "ı",
    intcal: "⊺",
    int: "∫",
    Int: "∬",
    integers: "ℤ",
    Integral: "∫",
    intercal: "⊺",
    Intersection: "⋂",
    intlarhk: "⨗",
    intprod: "⨼",
    InvisibleComma: "⁣",
    InvisibleTimes: "⁢",
    IOcy: "Ё",
    iocy: "ё",
    Iogon: "Į",
    iogon: "į",
    Iopf: "𝕀",
    iopf: "𝕚",
    Iota: "Ι",
    iota: "ι",
    iprod: "⨼",
    iquest: "¿",
    iscr: "𝒾",
    Iscr: "ℐ",
    isin: "∈",
    isindot: "⋵",
    isinE: "⋹",
    isins: "⋴",
    isinsv: "⋳",
    isinv: "∈",
    it: "⁢",
    Itilde: "Ĩ",
    itilde: "ĩ",
    Iukcy: "І",
    iukcy: "і",
    Iuml: "Ï",
    iuml: "ï",
    Jcirc: "Ĵ",
    jcirc: "ĵ",
    Jcy: "Й",
    jcy: "й",
    Jfr: "𝔍",
    jfr: "𝔧",
    jmath: "ȷ",
    Jopf: "𝕁",
    jopf: "𝕛",
    Jscr: "𝒥",
    jscr: "𝒿",
    Jsercy: "Ј",
    jsercy: "ј",
    Jukcy: "Є",
    jukcy: "є",
    Kappa: "Κ",
    kappa: "κ",
    kappav: "ϰ",
    Kcedil: "Ķ",
    kcedil: "ķ",
    Kcy: "К",
    kcy: "к",
    Kfr: "𝔎",
    kfr: "𝔨",
    kgreen: "ĸ",
    KHcy: "Х",
    khcy: "х",
    KJcy: "Ќ",
    kjcy: "ќ",
    Kopf: "𝕂",
    kopf: "𝕜",
    Kscr: "𝒦",
    kscr: "𝓀",
    lAarr: "⇚",
    Lacute: "Ĺ",
    lacute: "ĺ",
    laemptyv: "⦴",
    lagran: "ℒ",
    Lambda: "Λ",
    lambda: "λ",
    lang: "⟨",
    Lang: "⟪",
    langd: "⦑",
    langle: "⟨",
    lap: "⪅",
    Laplacetrf: "ℒ",
    laquo: "«",
    larrb: "⇤",
    larrbfs: "⤟",
    larr: "←",
    Larr: "↞",
    lArr: "⇐",
    larrfs: "⤝",
    larrhk: "↩",
    larrlp: "↫",
    larrpl: "⤹",
    larrsim: "⥳",
    larrtl: "↢",
    latail: "⤙",
    lAtail: "⤛",
    lat: "⪫",
    late: "⪭",
    lates: "⪭︀",
    lbarr: "⤌",
    lBarr: "⤎",
    lbbrk: "❲",
    lbrace: "{",
    lbrack: "[",
    lbrke: "⦋",
    lbrksld: "⦏",
    lbrkslu: "⦍",
    Lcaron: "Ľ",
    lcaron: "ľ",
    Lcedil: "Ļ",
    lcedil: "ļ",
    lceil: "⌈",
    lcub: "{",
    Lcy: "Л",
    lcy: "л",
    ldca: "⤶",
    ldquo: "“",
    ldquor: "„",
    ldrdhar: "⥧",
    ldrushar: "⥋",
    ldsh: "↲",
    le: "≤",
    lE: "≦",
    LeftAngleBracket: "⟨",
    LeftArrowBar: "⇤",
    leftarrow: "←",
    LeftArrow: "←",
    Leftarrow: "⇐",
    LeftArrowRightArrow: "⇆",
    leftarrowtail: "↢",
    LeftCeiling: "⌈",
    LeftDoubleBracket: "⟦",
    LeftDownTeeVector: "⥡",
    LeftDownVectorBar: "⥙",
    LeftDownVector: "⇃",
    LeftFloor: "⌊",
    leftharpoondown: "↽",
    leftharpoonup: "↼",
    leftleftarrows: "⇇",
    leftrightarrow: "↔",
    LeftRightArrow: "↔",
    Leftrightarrow: "⇔",
    leftrightarrows: "⇆",
    leftrightharpoons: "⇋",
    leftrightsquigarrow: "↭",
    LeftRightVector: "⥎",
    LeftTeeArrow: "↤",
    LeftTee: "⊣",
    LeftTeeVector: "⥚",
    leftthreetimes: "⋋",
    LeftTriangleBar: "⧏",
    LeftTriangle: "⊲",
    LeftTriangleEqual: "⊴",
    LeftUpDownVector: "⥑",
    LeftUpTeeVector: "⥠",
    LeftUpVectorBar: "⥘",
    LeftUpVector: "↿",
    LeftVectorBar: "⥒",
    LeftVector: "↼",
    lEg: "⪋",
    leg: "⋚",
    leq: "≤",
    leqq: "≦",
    leqslant: "⩽",
    lescc: "⪨",
    les: "⩽",
    lesdot: "⩿",
    lesdoto: "⪁",
    lesdotor: "⪃",
    lesg: "⋚︀",
    lesges: "⪓",
    lessapprox: "⪅",
    lessdot: "⋖",
    lesseqgtr: "⋚",
    lesseqqgtr: "⪋",
    LessEqualGreater: "⋚",
    LessFullEqual: "≦",
    LessGreater: "≶",
    lessgtr: "≶",
    LessLess: "⪡",
    lesssim: "≲",
    LessSlantEqual: "⩽",
    LessTilde: "≲",
    lfisht: "⥼",
    lfloor: "⌊",
    Lfr: "𝔏",
    lfr: "𝔩",
    lg: "≶",
    lgE: "⪑",
    lHar: "⥢",
    lhard: "↽",
    lharu: "↼",
    lharul: "⥪",
    lhblk: "▄",
    LJcy: "Љ",
    ljcy: "љ",
    llarr: "⇇",
    ll: "≪",
    Ll: "⋘",
    llcorner: "⌞",
    Lleftarrow: "⇚",
    llhard: "⥫",
    lltri: "◺",
    Lmidot: "Ŀ",
    lmidot: "ŀ",
    lmoustache: "⎰",
    lmoust: "⎰",
    lnap: "⪉",
    lnapprox: "⪉",
    lne: "⪇",
    lnE: "≨",
    lneq: "⪇",
    lneqq: "≨",
    lnsim: "⋦",
    loang: "⟬",
    loarr: "⇽",
    lobrk: "⟦",
    longleftarrow: "⟵",
    LongLeftArrow: "⟵",
    Longleftarrow: "⟸",
    longleftrightarrow: "⟷",
    LongLeftRightArrow: "⟷",
    Longleftrightarrow: "⟺",
    longmapsto: "⟼",
    longrightarrow: "⟶",
    LongRightArrow: "⟶",
    Longrightarrow: "⟹",
    looparrowleft: "↫",
    looparrowright: "↬",
    lopar: "⦅",
    Lopf: "𝕃",
    lopf: "𝕝",
    loplus: "⨭",
    lotimes: "⨴",
    lowast: "∗",
    lowbar: "_",
    LowerLeftArrow: "↙",
    LowerRightArrow: "↘",
    loz: "◊",
    lozenge: "◊",
    lozf: "⧫",
    lpar: "(",
    lparlt: "⦓",
    lrarr: "⇆",
    lrcorner: "⌟",
    lrhar: "⇋",
    lrhard: "⥭",
    lrm: "‎",
    lrtri: "⊿",
    lsaquo: "‹",
    lscr: "𝓁",
    Lscr: "ℒ",
    lsh: "↰",
    Lsh: "↰",
    lsim: "≲",
    lsime: "⪍",
    lsimg: "⪏",
    lsqb: "[",
    lsquo: "‘",
    lsquor: "‚",
    Lstrok: "Ł",
    lstrok: "ł",
    ltcc: "⪦",
    ltcir: "⩹",
    lt: "<",
    LT: "<",
    Lt: "≪",
    ltdot: "⋖",
    lthree: "⋋",
    ltimes: "⋉",
    ltlarr: "⥶",
    ltquest: "⩻",
    ltri: "◃",
    ltrie: "⊴",
    ltrif: "◂",
    ltrPar: "⦖",
    lurdshar: "⥊",
    luruhar: "⥦",
    lvertneqq: "≨︀",
    lvnE: "≨︀",
    macr: "¯",
    male: "♂",
    malt: "✠",
    maltese: "✠",
    Map: "⤅",
    map: "↦",
    mapsto: "↦",
    mapstodown: "↧",
    mapstoleft: "↤",
    mapstoup: "↥",
    marker: "▮",
    mcomma: "⨩",
    Mcy: "М",
    mcy: "м",
    mdash: "—",
    mDDot: "∺",
    measuredangle: "∡",
    MediumSpace: " ",
    Mellintrf: "ℳ",
    Mfr: "𝔐",
    mfr: "𝔪",
    mho: "℧",
    micro: "µ",
    midast: "*",
    midcir: "⫰",
    mid: "∣",
    middot: "·",
    minusb: "⊟",
    minus: "−",
    minusd: "∸",
    minusdu: "⨪",
    MinusPlus: "∓",
    mlcp: "⫛",
    mldr: "…",
    mnplus: "∓",
    models: "⊧",
    Mopf: "𝕄",
    mopf: "𝕞",
    mp: "∓",
    mscr: "𝓂",
    Mscr: "ℳ",
    mstpos: "∾",
    Mu: "Μ",
    mu: "μ",
    multimap: "⊸",
    mumap: "⊸",
    nabla: "∇",
    Nacute: "Ń",
    nacute: "ń",
    nang: "∠⃒",
    nap: "≉",
    napE: "⩰̸",
    napid: "≋̸",
    napos: "ŉ",
    napprox: "≉",
    natural: "♮",
    naturals: "ℕ",
    natur: "♮",
    nbsp: " ",
    nbump: "≎̸",
    nbumpe: "≏̸",
    ncap: "⩃",
    Ncaron: "Ň",
    ncaron: "ň",
    Ncedil: "Ņ",
    ncedil: "ņ",
    ncong: "≇",
    ncongdot: "⩭̸",
    ncup: "⩂",
    Ncy: "Н",
    ncy: "н",
    ndash: "–",
    nearhk: "⤤",
    nearr: "↗",
    neArr: "⇗",
    nearrow: "↗",
    ne: "≠",
    nedot: "≐̸",
    NegativeMediumSpace: "​",
    NegativeThickSpace: "​",
    NegativeThinSpace: "​",
    NegativeVeryThinSpace: "​",
    nequiv: "≢",
    nesear: "⤨",
    nesim: "≂̸",
    NestedGreaterGreater: "≫",
    NestedLessLess: "≪",
    NewLine: `
`,
    nexist: "∄",
    nexists: "∄",
    Nfr: "𝔑",
    nfr: "𝔫",
    ngE: "≧̸",
    nge: "≱",
    ngeq: "≱",
    ngeqq: "≧̸",
    ngeqslant: "⩾̸",
    nges: "⩾̸",
    nGg: "⋙̸",
    ngsim: "≵",
    nGt: "≫⃒",
    ngt: "≯",
    ngtr: "≯",
    nGtv: "≫̸",
    nharr: "↮",
    nhArr: "⇎",
    nhpar: "⫲",
    ni: "∋",
    nis: "⋼",
    nisd: "⋺",
    niv: "∋",
    NJcy: "Њ",
    njcy: "њ",
    nlarr: "↚",
    nlArr: "⇍",
    nldr: "‥",
    nlE: "≦̸",
    nle: "≰",
    nleftarrow: "↚",
    nLeftarrow: "⇍",
    nleftrightarrow: "↮",
    nLeftrightarrow: "⇎",
    nleq: "≰",
    nleqq: "≦̸",
    nleqslant: "⩽̸",
    nles: "⩽̸",
    nless: "≮",
    nLl: "⋘̸",
    nlsim: "≴",
    nLt: "≪⃒",
    nlt: "≮",
    nltri: "⋪",
    nltrie: "⋬",
    nLtv: "≪̸",
    nmid: "∤",
    NoBreak: "⁠",
    NonBreakingSpace: " ",
    nopf: "𝕟",
    Nopf: "ℕ",
    Not: "⫬",
    not: "¬",
    NotCongruent: "≢",
    NotCupCap: "≭",
    NotDoubleVerticalBar: "∦",
    NotElement: "∉",
    NotEqual: "≠",
    NotEqualTilde: "≂̸",
    NotExists: "∄",
    NotGreater: "≯",
    NotGreaterEqual: "≱",
    NotGreaterFullEqual: "≧̸",
    NotGreaterGreater: "≫̸",
    NotGreaterLess: "≹",
    NotGreaterSlantEqual: "⩾̸",
    NotGreaterTilde: "≵",
    NotHumpDownHump: "≎̸",
    NotHumpEqual: "≏̸",
    notin: "∉",
    notindot: "⋵̸",
    notinE: "⋹̸",
    notinva: "∉",
    notinvb: "⋷",
    notinvc: "⋶",
    NotLeftTriangleBar: "⧏̸",
    NotLeftTriangle: "⋪",
    NotLeftTriangleEqual: "⋬",
    NotLess: "≮",
    NotLessEqual: "≰",
    NotLessGreater: "≸",
    NotLessLess: "≪̸",
    NotLessSlantEqual: "⩽̸",
    NotLessTilde: "≴",
    NotNestedGreaterGreater: "⪢̸",
    NotNestedLessLess: "⪡̸",
    notni: "∌",
    notniva: "∌",
    notnivb: "⋾",
    notnivc: "⋽",
    NotPrecedes: "⊀",
    NotPrecedesEqual: "⪯̸",
    NotPrecedesSlantEqual: "⋠",
    NotReverseElement: "∌",
    NotRightTriangleBar: "⧐̸",
    NotRightTriangle: "⋫",
    NotRightTriangleEqual: "⋭",
    NotSquareSubset: "⊏̸",
    NotSquareSubsetEqual: "⋢",
    NotSquareSuperset: "⊐̸",
    NotSquareSupersetEqual: "⋣",
    NotSubset: "⊂⃒",
    NotSubsetEqual: "⊈",
    NotSucceeds: "⊁",
    NotSucceedsEqual: "⪰̸",
    NotSucceedsSlantEqual: "⋡",
    NotSucceedsTilde: "≿̸",
    NotSuperset: "⊃⃒",
    NotSupersetEqual: "⊉",
    NotTilde: "≁",
    NotTildeEqual: "≄",
    NotTildeFullEqual: "≇",
    NotTildeTilde: "≉",
    NotVerticalBar: "∤",
    nparallel: "∦",
    npar: "∦",
    nparsl: "⫽⃥",
    npart: "∂̸",
    npolint: "⨔",
    npr: "⊀",
    nprcue: "⋠",
    nprec: "⊀",
    npreceq: "⪯̸",
    npre: "⪯̸",
    nrarrc: "⤳̸",
    nrarr: "↛",
    nrArr: "⇏",
    nrarrw: "↝̸",
    nrightarrow: "↛",
    nRightarrow: "⇏",
    nrtri: "⋫",
    nrtrie: "⋭",
    nsc: "⊁",
    nsccue: "⋡",
    nsce: "⪰̸",
    Nscr: "𝒩",
    nscr: "𝓃",
    nshortmid: "∤",
    nshortparallel: "∦",
    nsim: "≁",
    nsime: "≄",
    nsimeq: "≄",
    nsmid: "∤",
    nspar: "∦",
    nsqsube: "⋢",
    nsqsupe: "⋣",
    nsub: "⊄",
    nsubE: "⫅̸",
    nsube: "⊈",
    nsubset: "⊂⃒",
    nsubseteq: "⊈",
    nsubseteqq: "⫅̸",
    nsucc: "⊁",
    nsucceq: "⪰̸",
    nsup: "⊅",
    nsupE: "⫆̸",
    nsupe: "⊉",
    nsupset: "⊃⃒",
    nsupseteq: "⊉",
    nsupseteqq: "⫆̸",
    ntgl: "≹",
    Ntilde: "Ñ",
    ntilde: "ñ",
    ntlg: "≸",
    ntriangleleft: "⋪",
    ntrianglelefteq: "⋬",
    ntriangleright: "⋫",
    ntrianglerighteq: "⋭",
    Nu: "Ν",
    nu: "ν",
    num: "#",
    numero: "№",
    numsp: " ",
    nvap: "≍⃒",
    nvdash: "⊬",
    nvDash: "⊭",
    nVdash: "⊮",
    nVDash: "⊯",
    nvge: "≥⃒",
    nvgt: ">⃒",
    nvHarr: "⤄",
    nvinfin: "⧞",
    nvlArr: "⤂",
    nvle: "≤⃒",
    nvlt: "<⃒",
    nvltrie: "⊴⃒",
    nvrArr: "⤃",
    nvrtrie: "⊵⃒",
    nvsim: "∼⃒",
    nwarhk: "⤣",
    nwarr: "↖",
    nwArr: "⇖",
    nwarrow: "↖",
    nwnear: "⤧",
    Oacute: "Ó",
    oacute: "ó",
    oast: "⊛",
    Ocirc: "Ô",
    ocirc: "ô",
    ocir: "⊚",
    Ocy: "О",
    ocy: "о",
    odash: "⊝",
    Odblac: "Ő",
    odblac: "ő",
    odiv: "⨸",
    odot: "⊙",
    odsold: "⦼",
    OElig: "Œ",
    oelig: "œ",
    ofcir: "⦿",
    Ofr: "𝔒",
    ofr: "𝔬",
    ogon: "˛",
    Ograve: "Ò",
    ograve: "ò",
    ogt: "⧁",
    ohbar: "⦵",
    ohm: "Ω",
    oint: "∮",
    olarr: "↺",
    olcir: "⦾",
    olcross: "⦻",
    oline: "‾",
    olt: "⧀",
    Omacr: "Ō",
    omacr: "ō",
    Omega: "Ω",
    omega: "ω",
    Omicron: "Ο",
    omicron: "ο",
    omid: "⦶",
    ominus: "⊖",
    Oopf: "𝕆",
    oopf: "𝕠",
    opar: "⦷",
    OpenCurlyDoubleQuote: "“",
    OpenCurlyQuote: "‘",
    operp: "⦹",
    oplus: "⊕",
    orarr: "↻",
    Or: "⩔",
    or: "∨",
    ord: "⩝",
    order: "ℴ",
    orderof: "ℴ",
    ordf: "ª",
    ordm: "º",
    origof: "⊶",
    oror: "⩖",
    orslope: "⩗",
    orv: "⩛",
    oS: "Ⓢ",
    Oscr: "𝒪",
    oscr: "ℴ",
    Oslash: "Ø",
    oslash: "ø",
    osol: "⊘",
    Otilde: "Õ",
    otilde: "õ",
    otimesas: "⨶",
    Otimes: "⨷",
    otimes: "⊗",
    Ouml: "Ö",
    ouml: "ö",
    ovbar: "⌽",
    OverBar: "‾",
    OverBrace: "⏞",
    OverBracket: "⎴",
    OverParenthesis: "⏜",
    para: "¶",
    parallel: "∥",
    par: "∥",
    parsim: "⫳",
    parsl: "⫽",
    part: "∂",
    PartialD: "∂",
    Pcy: "П",
    pcy: "п",
    percnt: "%",
    period: ".",
    permil: "‰",
    perp: "⊥",
    pertenk: "‱",
    Pfr: "𝔓",
    pfr: "𝔭",
    Phi: "Φ",
    phi: "φ",
    phiv: "ϕ",
    phmmat: "ℳ",
    phone: "☎",
    Pi: "Π",
    pi: "π",
    pitchfork: "⋔",
    piv: "ϖ",
    planck: "ℏ",
    planckh: "ℎ",
    plankv: "ℏ",
    plusacir: "⨣",
    plusb: "⊞",
    pluscir: "⨢",
    plus: "+",
    plusdo: "∔",
    plusdu: "⨥",
    pluse: "⩲",
    PlusMinus: "±",
    plusmn: "±",
    plussim: "⨦",
    plustwo: "⨧",
    pm: "±",
    Poincareplane: "ℌ",
    pointint: "⨕",
    popf: "𝕡",
    Popf: "ℙ",
    pound: "£",
    prap: "⪷",
    Pr: "⪻",
    pr: "≺",
    prcue: "≼",
    precapprox: "⪷",
    prec: "≺",
    preccurlyeq: "≼",
    Precedes: "≺",
    PrecedesEqual: "⪯",
    PrecedesSlantEqual: "≼",
    PrecedesTilde: "≾",
    preceq: "⪯",
    precnapprox: "⪹",
    precneqq: "⪵",
    precnsim: "⋨",
    pre: "⪯",
    prE: "⪳",
    precsim: "≾",
    prime: "′",
    Prime: "″",
    primes: "ℙ",
    prnap: "⪹",
    prnE: "⪵",
    prnsim: "⋨",
    prod: "∏",
    Product: "∏",
    profalar: "⌮",
    profline: "⌒",
    profsurf: "⌓",
    prop: "∝",
    Proportional: "∝",
    Proportion: "∷",
    propto: "∝",
    prsim: "≾",
    prurel: "⊰",
    Pscr: "𝒫",
    pscr: "𝓅",
    Psi: "Ψ",
    psi: "ψ",
    puncsp: " ",
    Qfr: "𝔔",
    qfr: "𝔮",
    qint: "⨌",
    qopf: "𝕢",
    Qopf: "ℚ",
    qprime: "⁗",
    Qscr: "𝒬",
    qscr: "𝓆",
    quaternions: "ℍ",
    quatint: "⨖",
    quest: "?",
    questeq: "≟",
    quot: '"',
    QUOT: '"',
    rAarr: "⇛",
    race: "∽̱",
    Racute: "Ŕ",
    racute: "ŕ",
    radic: "√",
    raemptyv: "⦳",
    rang: "⟩",
    Rang: "⟫",
    rangd: "⦒",
    range: "⦥",
    rangle: "⟩",
    raquo: "»",
    rarrap: "⥵",
    rarrb: "⇥",
    rarrbfs: "⤠",
    rarrc: "⤳",
    rarr: "→",
    Rarr: "↠",
    rArr: "⇒",
    rarrfs: "⤞",
    rarrhk: "↪",
    rarrlp: "↬",
    rarrpl: "⥅",
    rarrsim: "⥴",
    Rarrtl: "⤖",
    rarrtl: "↣",
    rarrw: "↝",
    ratail: "⤚",
    rAtail: "⤜",
    ratio: "∶",
    rationals: "ℚ",
    rbarr: "⤍",
    rBarr: "⤏",
    RBarr: "⤐",
    rbbrk: "❳",
    rbrace: "}",
    rbrack: "]",
    rbrke: "⦌",
    rbrksld: "⦎",
    rbrkslu: "⦐",
    Rcaron: "Ř",
    rcaron: "ř",
    Rcedil: "Ŗ",
    rcedil: "ŗ",
    rceil: "⌉",
    rcub: "}",
    Rcy: "Р",
    rcy: "р",
    rdca: "⤷",
    rdldhar: "⥩",
    rdquo: "”",
    rdquor: "”",
    rdsh: "↳",
    real: "ℜ",
    realine: "ℛ",
    realpart: "ℜ",
    reals: "ℝ",
    Re: "ℜ",
    rect: "▭",
    reg: "®",
    REG: "®",
    ReverseElement: "∋",
    ReverseEquilibrium: "⇋",
    ReverseUpEquilibrium: "⥯",
    rfisht: "⥽",
    rfloor: "⌋",
    rfr: "𝔯",
    Rfr: "ℜ",
    rHar: "⥤",
    rhard: "⇁",
    rharu: "⇀",
    rharul: "⥬",
    Rho: "Ρ",
    rho: "ρ",
    rhov: "ϱ",
    RightAngleBracket: "⟩",
    RightArrowBar: "⇥",
    rightarrow: "→",
    RightArrow: "→",
    Rightarrow: "⇒",
    RightArrowLeftArrow: "⇄",
    rightarrowtail: "↣",
    RightCeiling: "⌉",
    RightDoubleBracket: "⟧",
    RightDownTeeVector: "⥝",
    RightDownVectorBar: "⥕",
    RightDownVector: "⇂",
    RightFloor: "⌋",
    rightharpoondown: "⇁",
    rightharpoonup: "⇀",
    rightleftarrows: "⇄",
    rightleftharpoons: "⇌",
    rightrightarrows: "⇉",
    rightsquigarrow: "↝",
    RightTeeArrow: "↦",
    RightTee: "⊢",
    RightTeeVector: "⥛",
    rightthreetimes: "⋌",
    RightTriangleBar: "⧐",
    RightTriangle: "⊳",
    RightTriangleEqual: "⊵",
    RightUpDownVector: "⥏",
    RightUpTeeVector: "⥜",
    RightUpVectorBar: "⥔",
    RightUpVector: "↾",
    RightVectorBar: "⥓",
    RightVector: "⇀",
    ring: "˚",
    risingdotseq: "≓",
    rlarr: "⇄",
    rlhar: "⇌",
    rlm: "‏",
    rmoustache: "⎱",
    rmoust: "⎱",
    rnmid: "⫮",
    roang: "⟭",
    roarr: "⇾",
    robrk: "⟧",
    ropar: "⦆",
    ropf: "𝕣",
    Ropf: "ℝ",
    roplus: "⨮",
    rotimes: "⨵",
    RoundImplies: "⥰",
    rpar: ")",
    rpargt: "⦔",
    rppolint: "⨒",
    rrarr: "⇉",
    Rrightarrow: "⇛",
    rsaquo: "›",
    rscr: "𝓇",
    Rscr: "ℛ",
    rsh: "↱",
    Rsh: "↱",
    rsqb: "]",
    rsquo: "’",
    rsquor: "’",
    rthree: "⋌",
    rtimes: "⋊",
    rtri: "▹",
    rtrie: "⊵",
    rtrif: "▸",
    rtriltri: "⧎",
    RuleDelayed: "⧴",
    ruluhar: "⥨",
    rx: "℞",
    Sacute: "Ś",
    sacute: "ś",
    sbquo: "‚",
    scap: "⪸",
    Scaron: "Š",
    scaron: "š",
    Sc: "⪼",
    sc: "≻",
    sccue: "≽",
    sce: "⪰",
    scE: "⪴",
    Scedil: "Ş",
    scedil: "ş",
    Scirc: "Ŝ",
    scirc: "ŝ",
    scnap: "⪺",
    scnE: "⪶",
    scnsim: "⋩",
    scpolint: "⨓",
    scsim: "≿",
    Scy: "С",
    scy: "с",
    sdotb: "⊡",
    sdot: "⋅",
    sdote: "⩦",
    searhk: "⤥",
    searr: "↘",
    seArr: "⇘",
    searrow: "↘",
    sect: "§",
    semi: ";",
    seswar: "⤩",
    setminus: "∖",
    setmn: "∖",
    sext: "✶",
    Sfr: "𝔖",
    sfr: "𝔰",
    sfrown: "⌢",
    sharp: "♯",
    SHCHcy: "Щ",
    shchcy: "щ",
    SHcy: "Ш",
    shcy: "ш",
    ShortDownArrow: "↓",
    ShortLeftArrow: "←",
    shortmid: "∣",
    shortparallel: "∥",
    ShortRightArrow: "→",
    ShortUpArrow: "↑",
    shy: "­",
    Sigma: "Σ",
    sigma: "σ",
    sigmaf: "ς",
    sigmav: "ς",
    sim: "∼",
    simdot: "⩪",
    sime: "≃",
    simeq: "≃",
    simg: "⪞",
    simgE: "⪠",
    siml: "⪝",
    simlE: "⪟",
    simne: "≆",
    simplus: "⨤",
    simrarr: "⥲",
    slarr: "←",
    SmallCircle: "∘",
    smallsetminus: "∖",
    smashp: "⨳",
    smeparsl: "⧤",
    smid: "∣",
    smile: "⌣",
    smt: "⪪",
    smte: "⪬",
    smtes: "⪬︀",
    SOFTcy: "Ь",
    softcy: "ь",
    solbar: "⌿",
    solb: "⧄",
    sol: "/",
    Sopf: "𝕊",
    sopf: "𝕤",
    spades: "♠",
    spadesuit: "♠",
    spar: "∥",
    sqcap: "⊓",
    sqcaps: "⊓︀",
    sqcup: "⊔",
    sqcups: "⊔︀",
    Sqrt: "√",
    sqsub: "⊏",
    sqsube: "⊑",
    sqsubset: "⊏",
    sqsubseteq: "⊑",
    sqsup: "⊐",
    sqsupe: "⊒",
    sqsupset: "⊐",
    sqsupseteq: "⊒",
    square: "□",
    Square: "□",
    SquareIntersection: "⊓",
    SquareSubset: "⊏",
    SquareSubsetEqual: "⊑",
    SquareSuperset: "⊐",
    SquareSupersetEqual: "⊒",
    SquareUnion: "⊔",
    squarf: "▪",
    squ: "□",
    squf: "▪",
    srarr: "→",
    Sscr: "𝒮",
    sscr: "𝓈",
    ssetmn: "∖",
    ssmile: "⌣",
    sstarf: "⋆",
    Star: "⋆",
    star: "☆",
    starf: "★",
    straightepsilon: "ϵ",
    straightphi: "ϕ",
    strns: "¯",
    sub: "⊂",
    Sub: "⋐",
    subdot: "⪽",
    subE: "⫅",
    sube: "⊆",
    subedot: "⫃",
    submult: "⫁",
    subnE: "⫋",
    subne: "⊊",
    subplus: "⪿",
    subrarr: "⥹",
    subset: "⊂",
    Subset: "⋐",
    subseteq: "⊆",
    subseteqq: "⫅",
    SubsetEqual: "⊆",
    subsetneq: "⊊",
    subsetneqq: "⫋",
    subsim: "⫇",
    subsub: "⫕",
    subsup: "⫓",
    succapprox: "⪸",
    succ: "≻",
    succcurlyeq: "≽",
    Succeeds: "≻",
    SucceedsEqual: "⪰",
    SucceedsSlantEqual: "≽",
    SucceedsTilde: "≿",
    succeq: "⪰",
    succnapprox: "⪺",
    succneqq: "⪶",
    succnsim: "⋩",
    succsim: "≿",
    SuchThat: "∋",
    sum: "∑",
    Sum: "∑",
    sung: "♪",
    sup1: "¹",
    sup2: "²",
    sup3: "³",
    sup: "⊃",
    Sup: "⋑",
    supdot: "⪾",
    supdsub: "⫘",
    supE: "⫆",
    supe: "⊇",
    supedot: "⫄",
    Superset: "⊃",
    SupersetEqual: "⊇",
    suphsol: "⟉",
    suphsub: "⫗",
    suplarr: "⥻",
    supmult: "⫂",
    supnE: "⫌",
    supne: "⊋",
    supplus: "⫀",
    supset: "⊃",
    Supset: "⋑",
    supseteq: "⊇",
    supseteqq: "⫆",
    supsetneq: "⊋",
    supsetneqq: "⫌",
    supsim: "⫈",
    supsub: "⫔",
    supsup: "⫖",
    swarhk: "⤦",
    swarr: "↙",
    swArr: "⇙",
    swarrow: "↙",
    swnwar: "⤪",
    szlig: "ß",
    Tab: "	",
    target: "⌖",
    Tau: "Τ",
    tau: "τ",
    tbrk: "⎴",
    Tcaron: "Ť",
    tcaron: "ť",
    Tcedil: "Ţ",
    tcedil: "ţ",
    Tcy: "Т",
    tcy: "т",
    tdot: "⃛",
    telrec: "⌕",
    Tfr: "𝔗",
    tfr: "𝔱",
    there4: "∴",
    therefore: "∴",
    Therefore: "∴",
    Theta: "Θ",
    theta: "θ",
    thetasym: "ϑ",
    thetav: "ϑ",
    thickapprox: "≈",
    thicksim: "∼",
    ThickSpace: "  ",
    ThinSpace: " ",
    thinsp: " ",
    thkap: "≈",
    thksim: "∼",
    THORN: "Þ",
    thorn: "þ",
    tilde: "˜",
    Tilde: "∼",
    TildeEqual: "≃",
    TildeFullEqual: "≅",
    TildeTilde: "≈",
    timesbar: "⨱",
    timesb: "⊠",
    times: "×",
    timesd: "⨰",
    tint: "∭",
    toea: "⤨",
    topbot: "⌶",
    topcir: "⫱",
    top: "⊤",
    Topf: "𝕋",
    topf: "𝕥",
    topfork: "⫚",
    tosa: "⤩",
    tprime: "‴",
    trade: "™",
    TRADE: "™",
    triangle: "▵",
    triangledown: "▿",
    triangleleft: "◃",
    trianglelefteq: "⊴",
    triangleq: "≜",
    triangleright: "▹",
    trianglerighteq: "⊵",
    tridot: "◬",
    trie: "≜",
    triminus: "⨺",
    TripleDot: "⃛",
    triplus: "⨹",
    trisb: "⧍",
    tritime: "⨻",
    trpezium: "⏢",
    Tscr: "𝒯",
    tscr: "𝓉",
    TScy: "Ц",
    tscy: "ц",
    TSHcy: "Ћ",
    tshcy: "ћ",
    Tstrok: "Ŧ",
    tstrok: "ŧ",
    twixt: "≬",
    twoheadleftarrow: "↞",
    twoheadrightarrow: "↠",
    Uacute: "Ú",
    uacute: "ú",
    uarr: "↑",
    Uarr: "↟",
    uArr: "⇑",
    Uarrocir: "⥉",
    Ubrcy: "Ў",
    ubrcy: "ў",
    Ubreve: "Ŭ",
    ubreve: "ŭ",
    Ucirc: "Û",
    ucirc: "û",
    Ucy: "У",
    ucy: "у",
    udarr: "⇅",
    Udblac: "Ű",
    udblac: "ű",
    udhar: "⥮",
    ufisht: "⥾",
    Ufr: "𝔘",
    ufr: "𝔲",
    Ugrave: "Ù",
    ugrave: "ù",
    uHar: "⥣",
    uharl: "↿",
    uharr: "↾",
    uhblk: "▀",
    ulcorn: "⌜",
    ulcorner: "⌜",
    ulcrop: "⌏",
    ultri: "◸",
    Umacr: "Ū",
    umacr: "ū",
    uml: "¨",
    UnderBar: "_",
    UnderBrace: "⏟",
    UnderBracket: "⎵",
    UnderParenthesis: "⏝",
    Union: "⋃",
    UnionPlus: "⊎",
    Uogon: "Ų",
    uogon: "ų",
    Uopf: "𝕌",
    uopf: "𝕦",
    UpArrowBar: "⤒",
    uparrow: "↑",
    UpArrow: "↑",
    Uparrow: "⇑",
    UpArrowDownArrow: "⇅",
    updownarrow: "↕",
    UpDownArrow: "↕",
    Updownarrow: "⇕",
    UpEquilibrium: "⥮",
    upharpoonleft: "↿",
    upharpoonright: "↾",
    uplus: "⊎",
    UpperLeftArrow: "↖",
    UpperRightArrow: "↗",
    upsi: "υ",
    Upsi: "ϒ",
    upsih: "ϒ",
    Upsilon: "Υ",
    upsilon: "υ",
    UpTeeArrow: "↥",
    UpTee: "⊥",
    upuparrows: "⇈",
    urcorn: "⌝",
    urcorner: "⌝",
    urcrop: "⌎",
    Uring: "Ů",
    uring: "ů",
    urtri: "◹",
    Uscr: "𝒰",
    uscr: "𝓊",
    utdot: "⋰",
    Utilde: "Ũ",
    utilde: "ũ",
    utri: "▵",
    utrif: "▴",
    uuarr: "⇈",
    Uuml: "Ü",
    uuml: "ü",
    uwangle: "⦧",
    vangrt: "⦜",
    varepsilon: "ϵ",
    varkappa: "ϰ",
    varnothing: "∅",
    varphi: "ϕ",
    varpi: "ϖ",
    varpropto: "∝",
    varr: "↕",
    vArr: "⇕",
    varrho: "ϱ",
    varsigma: "ς",
    varsubsetneq: "⊊︀",
    varsubsetneqq: "⫋︀",
    varsupsetneq: "⊋︀",
    varsupsetneqq: "⫌︀",
    vartheta: "ϑ",
    vartriangleleft: "⊲",
    vartriangleright: "⊳",
    vBar: "⫨",
    Vbar: "⫫",
    vBarv: "⫩",
    Vcy: "В",
    vcy: "в",
    vdash: "⊢",
    vDash: "⊨",
    Vdash: "⊩",
    VDash: "⊫",
    Vdashl: "⫦",
    veebar: "⊻",
    vee: "∨",
    Vee: "⋁",
    veeeq: "≚",
    vellip: "⋮",
    verbar: "|",
    Verbar: "‖",
    vert: "|",
    Vert: "‖",
    VerticalBar: "∣",
    VerticalLine: "|",
    VerticalSeparator: "❘",
    VerticalTilde: "≀",
    VeryThinSpace: " ",
    Vfr: "𝔙",
    vfr: "𝔳",
    vltri: "⊲",
    vnsub: "⊂⃒",
    vnsup: "⊃⃒",
    Vopf: "𝕍",
    vopf: "𝕧",
    vprop: "∝",
    vrtri: "⊳",
    Vscr: "𝒱",
    vscr: "𝓋",
    vsubnE: "⫋︀",
    vsubne: "⊊︀",
    vsupnE: "⫌︀",
    vsupne: "⊋︀",
    Vvdash: "⊪",
    vzigzag: "⦚",
    Wcirc: "Ŵ",
    wcirc: "ŵ",
    wedbar: "⩟",
    wedge: "∧",
    Wedge: "⋀",
    wedgeq: "≙",
    weierp: "℘",
    Wfr: "𝔚",
    wfr: "𝔴",
    Wopf: "𝕎",
    wopf: "𝕨",
    wp: "℘",
    wr: "≀",
    wreath: "≀",
    Wscr: "𝒲",
    wscr: "𝓌",
    xcap: "⋂",
    xcirc: "◯",
    xcup: "⋃",
    xdtri: "▽",
    Xfr: "𝔛",
    xfr: "𝔵",
    xharr: "⟷",
    xhArr: "⟺",
    Xi: "Ξ",
    xi: "ξ",
    xlarr: "⟵",
    xlArr: "⟸",
    xmap: "⟼",
    xnis: "⋻",
    xodot: "⨀",
    Xopf: "𝕏",
    xopf: "𝕩",
    xoplus: "⨁",
    xotime: "⨂",
    xrarr: "⟶",
    xrArr: "⟹",
    Xscr: "𝒳",
    xscr: "𝓍",
    xsqcup: "⨆",
    xuplus: "⨄",
    xutri: "△",
    xvee: "⋁",
    xwedge: "⋀",
    Yacute: "Ý",
    yacute: "ý",
    YAcy: "Я",
    yacy: "я",
    Ycirc: "Ŷ",
    ycirc: "ŷ",
    Ycy: "Ы",
    ycy: "ы",
    yen: "¥",
    Yfr: "𝔜",
    yfr: "𝔶",
    YIcy: "Ї",
    yicy: "ї",
    Yopf: "𝕐",
    yopf: "𝕪",
    Yscr: "𝒴",
    yscr: "𝓎",
    YUcy: "Ю",
    yucy: "ю",
    yuml: "ÿ",
    Yuml: "Ÿ",
    Zacute: "Ź",
    zacute: "ź",
    Zcaron: "Ž",
    zcaron: "ž",
    Zcy: "З",
    zcy: "з",
    Zdot: "Ż",
    zdot: "ż",
    zeetrf: "ℨ",
    ZeroWidthSpace: "​",
    Zeta: "Ζ",
    zeta: "ζ",
    zfr: "𝔷",
    Zfr: "ℨ",
    ZHcy: "Ж",
    zhcy: "ж",
    zigrarr: "⇝",
    zopf: "𝕫",
    Zopf: "ℤ",
    Zscr: "𝒵",
    zscr: "𝓏",
    zwj: "‍",
    zwnj: "‌"
  };
});
var Qi = q3((Bb, Hd) => {
  Hd.exports = {
    Aacute: "Á",
    aacute: "á",
    Acirc: "Â",
    acirc: "â",
    acute: "´",
    AElig: "Æ",
    aelig: "æ",
    Agrave: "À",
    agrave: "à",
    amp: "&",
    AMP: "&",
    Aring: "Å",
    aring: "å",
    Atilde: "Ã",
    atilde: "ã",
    Auml: "Ä",
    auml: "ä",
    brvbar: "¦",
    Ccedil: "Ç",
    ccedil: "ç",
    cedil: "¸",
    cent: "¢",
    copy: "©",
    COPY: "©",
    curren: "¤",
    deg: "°",
    divide: "÷",
    Eacute: "É",
    eacute: "é",
    Ecirc: "Ê",
    ecirc: "ê",
    Egrave: "È",
    egrave: "è",
    ETH: "Ð",
    eth: "ð",
    Euml: "Ë",
    euml: "ë",
    frac12: "½",
    frac14: "¼",
    frac34: "¾",
    gt: ">",
    GT: ">",
    Iacute: "Í",
    iacute: "í",
    Icirc: "Î",
    icirc: "î",
    iexcl: "¡",
    Igrave: "Ì",
    igrave: "ì",
    iquest: "¿",
    Iuml: "Ï",
    iuml: "ï",
    laquo: "«",
    lt: "<",
    LT: "<",
    macr: "¯",
    micro: "µ",
    middot: "·",
    nbsp: " ",
    not: "¬",
    Ntilde: "Ñ",
    ntilde: "ñ",
    Oacute: "Ó",
    oacute: "ó",
    Ocirc: "Ô",
    ocirc: "ô",
    Ograve: "Ò",
    ograve: "ò",
    ordf: "ª",
    ordm: "º",
    Oslash: "Ø",
    oslash: "ø",
    Otilde: "Õ",
    otilde: "õ",
    Ouml: "Ö",
    ouml: "ö",
    para: "¶",
    plusmn: "±",
    pound: "£",
    quot: '"',
    QUOT: '"',
    raquo: "»",
    reg: "®",
    REG: "®",
    sect: "§",
    shy: "­",
    sup1: "¹",
    sup2: "²",
    sup3: "³",
    szlig: "ß",
    THORN: "Þ",
    thorn: "þ",
    times: "×",
    Uacute: "Ú",
    uacute: "ú",
    Ucirc: "Û",
    ucirc: "û",
    Ugrave: "Ù",
    ugrave: "ù",
    uml: "¨",
    Uuml: "Ü",
    uuml: "ü",
    Yacute: "Ý",
    yacute: "ý",
    yen: "¥",
    yuml: "ÿ"
  };
});
var mo = q3((Gb, $d) => {
  $d.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
});
var es = q3((zb, Bd) => {
  Bd.exports = {
    "0": 65533,
    "128": 8364,
    "130": 8218,
    "131": 402,
    "132": 8222,
    "133": 8230,
    "134": 8224,
    "135": 8225,
    "136": 710,
    "137": 8240,
    "138": 352,
    "139": 8249,
    "140": 338,
    "142": 381,
    "145": 8216,
    "146": 8217,
    "147": 8220,
    "148": 8221,
    "149": 8226,
    "150": 8211,
    "151": 8212,
    "152": 732,
    "153": 8482,
    "154": 353,
    "155": 8250,
    "156": 339,
    "158": 382,
    "159": 376
  };
});
var rs = q3((at) => {
  "use strict";
  var Gd = at && at.__importDefault || function(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  };
  Object.defineProperty(at, "__esModule", { value: true });
  var ts = Gd(es()), zd = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.fromCodePoint || function(t2) {
      var e2 = "";
      return t2 > 65535 && (t2 -= 65536, e2 += String.fromCharCode(t2 >>> 10 & 1023 | 55296), t2 = 56320 | t2 & 1023), e2 += String.fromCharCode(t2), e2;
    }
  );
  function Ud(t2) {
    return t2 >= 55296 && t2 <= 57343 || t2 > 1114111 ? "�" : (t2 in ts.default && (t2 = ts.default[t2]), zd(t2));
  }
  n2(Ud, "decodeCodePoint");
  at.default = Ud;
});
var ho = q3((te) => {
  "use strict";
  var jt = te && te.__importDefault || function(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  };
  Object.defineProperty(te, "__esModule", { value: true });
  te.decodeHTML = te.decodeHTMLStrict = te.decodeXML = void 0;
  var yo = jt(fo()), Vd = jt(Qi()), Wd = jt(mo()), os = jt(rs()), Yd = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
  te.decodeXML = is(Wd.default);
  te.decodeHTMLStrict = is(yo.default);
  function is(t2) {
    var e2 = ss(t2);
    return function(r2) {
      return String(r2).replace(Yd, e2);
    };
  }
  n2(is, "getStrictDecoder");
  var ns = n2(function(t2, e2) {
    return t2 < e2 ? 1 : -1;
  }, "sorter");
  te.decodeHTML = function() {
    for (var t2 = Object.keys(Vd.default).sort(ns), e2 = Object.keys(yo.default).sort(ns), r2 = 0, o3 = 0; r2 < e2.length; r2++)
      t2[o3] === e2[r2] ? (e2[r2] += ";?", o3++) : e2[r2] += ";";
    var i2 = new RegExp("&(?:" + e2.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), s = ss(yo.default);
    function a(l2) {
      return l2.substr(-1) !== ";" && (l2 += ";"), s(l2);
    }
    return n2(a, "replacer"), function(l2) {
      return String(l2).replace(i2, a);
    };
  }();
  function ss(t2) {
    return n2(function(r2) {
      if (r2.charAt(1) === "#") {
        var o3 = r2.charAt(2);
        return o3 === "X" || o3 === "x" ? os.default(parseInt(r2.substr(3), 16)) : os.default(parseInt(r2.substr(2), 10));
      }
      return t2[r2.slice(1, -1)] || r2;
    }, "replace");
  }
  n2(ss, "getReplacer");
});
var bo = q3((G3) => {
  "use strict";
  var as = G3 && G3.__importDefault || function(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  };
  Object.defineProperty(G3, "__esModule", { value: true });
  G3.escapeUTF8 = G3.escape = G3.encodeNonAsciiHTML = G3.encodeHTML = G3.encodeXML = void 0;
  var Kd = as(mo()), ls = ds(Kd.default), cs = ps(ls);
  G3.encodeXML = ms(ls);
  var Xd = as(fo()), go = ds(Xd.default), Jd = ps(go);
  G3.encodeHTML = Qd(go, Jd);
  G3.encodeNonAsciiHTML = ms(go);
  function ds(t2) {
    return Object.keys(t2).sort().reduce(function(e2, r2) {
      return e2[t2[r2]] = "&" + r2 + ";", e2;
    }, {});
  }
  n2(ds, "getInverseObj");
  function ps(t2) {
    for (var e2 = [], r2 = [], o3 = 0, i2 = Object.keys(t2); o3 < i2.length; o3++) {
      var s = i2[o3];
      s.length === 1 ? e2.push("\\" + s) : r2.push(s);
    }
    e2.sort();
    for (var a = 0; a < e2.length - 1; a++) {
      for (var l2 = a; l2 < e2.length - 1 && e2[l2].charCodeAt(1) + 1 === e2[l2 + 1].charCodeAt(1); )
        l2 += 1;
      var c = 1 + l2 - a;
      c < 3 || e2.splice(a, c, e2[a] + "-" + e2[l2]);
    }
    return r2.unshift("[" + e2.join("") + "]"), new RegExp(r2.join("|"), "g");
  }
  n2(ps, "getInverseReplacer");
  var us = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, Zd = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? (
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      function(t2) {
        return t2.codePointAt(0);
      }
    ) : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      function(t2) {
        return (t2.charCodeAt(0) - 55296) * 1024 + t2.charCodeAt(1) - 56320 + 65536;
      }
    )
  );
  function Nt(t2) {
    return "&#x" + (t2.length > 1 ? Zd(t2) : t2.charCodeAt(0)).toString(16).toUpperCase() + ";";
  }
  n2(Nt, "singleCharReplacer");
  function Qd(t2, e2) {
    return function(r2) {
      return r2.replace(e2, function(o3) {
        return t2[o3];
      }).replace(us, Nt);
    };
  }
  n2(Qd, "getInverse");
  var fs = new RegExp(cs.source + "|" + us.source, "g");
  function ep(t2) {
    return t2.replace(fs, Nt);
  }
  n2(ep, "escape");
  G3.escape = ep;
  function tp(t2) {
    return t2.replace(cs, Nt);
  }
  n2(tp, "escapeUTF8");
  G3.escapeUTF8 = tp;
  function ms(t2) {
    return function(e2) {
      return e2.replace(fs, function(r2) {
        return t2[r2] || Nt(r2);
      });
    };
  }
  n2(ms, "getASCIIEncoder");
});
var hs = q3((O4) => {
  "use strict";
  Object.defineProperty(O4, "__esModule", { value: true });
  O4.decodeXMLStrict = O4.decodeHTML5Strict = O4.decodeHTML4Strict = O4.decodeHTML5 = O4.decodeHTML4 = O4.decodeHTMLStrict = O4.decodeHTML = O4.decodeXML = O4.encodeHTML5 = O4.encodeHTML4 = O4.escapeUTF8 = O4.escape = O4.encodeNonAsciiHTML = O4.encodeHTML = O4.encodeXML = O4.encode = O4.decodeStrict = O4.decode = void 0;
  var qt = ho(), ys = bo();
  function rp(t2, e2) {
    return (!e2 || e2 <= 0 ? qt.decodeXML : qt.decodeHTML)(t2);
  }
  n2(rp, "decode");
  O4.decode = rp;
  function op(t2, e2) {
    return (!e2 || e2 <= 0 ? qt.decodeXML : qt.decodeHTMLStrict)(t2);
  }
  n2(op, "decodeStrict");
  O4.decodeStrict = op;
  function np(t2, e2) {
    return (!e2 || e2 <= 0 ? ys.encodeXML : ys.encodeHTML)(t2);
  }
  n2(np, "encode");
  O4.encode = np;
  var Ee = bo();
  Object.defineProperty(O4, "encodeXML", { enumerable: true, get: n2(function() {
    return Ee.encodeXML;
  }, "get") });
  Object.defineProperty(O4, "encodeHTML", { enumerable: true, get: n2(function() {
    return Ee.encodeHTML;
  }, "get") });
  Object.defineProperty(O4, "encodeNonAsciiHTML", { enumerable: true, get: n2(function() {
    return Ee.encodeNonAsciiHTML;
  }, "get") });
  Object.defineProperty(O4, "escape", { enumerable: true, get: n2(function() {
    return Ee.escape;
  }, "get") });
  Object.defineProperty(O4, "escapeUTF8", { enumerable: true, get: n2(function() {
    return Ee.escapeUTF8;
  }, "get") });
  Object.defineProperty(O4, "encodeHTML4", { enumerable: true, get: n2(function() {
    return Ee.encodeHTML;
  }, "get") });
  Object.defineProperty(O4, "encodeHTML5", { enumerable: true, get: n2(function() {
    return Ee.encodeHTML;
  }, "get") });
  var fe = ho();
  Object.defineProperty(O4, "decodeXML", { enumerable: true, get: n2(function() {
    return fe.decodeXML;
  }, "get") });
  Object.defineProperty(O4, "decodeHTML", { enumerable: true, get: n2(function() {
    return fe.decodeHTML;
  }, "get") });
  Object.defineProperty(O4, "decodeHTMLStrict", { enumerable: true, get: n2(function() {
    return fe.decodeHTMLStrict;
  }, "get") });
  Object.defineProperty(O4, "decodeHTML4", { enumerable: true, get: n2(function() {
    return fe.decodeHTML;
  }, "get") });
  Object.defineProperty(O4, "decodeHTML5", { enumerable: true, get: n2(function() {
    return fe.decodeHTML;
  }, "get") });
  Object.defineProperty(O4, "decodeHTML4Strict", { enumerable: true, get: n2(function() {
    return fe.decodeHTMLStrict;
  }, "get") });
  Object.defineProperty(O4, "decodeHTML5Strict", { enumerable: true, get: n2(function() {
    return fe.decodeHTMLStrict;
  }, "get") });
  Object.defineProperty(O4, "decodeXMLStrict", { enumerable: true, get: n2(function() {
    return fe.decodeXML;
  }, "get") });
});
var Cs = q3((Qb, vs) => {
  "use strict";
  function ip(t2, e2) {
    if (!(t2 instanceof e2))
      throw new TypeError("Cannot call a class as a function");
  }
  n2(ip, "_classCallCheck");
  function gs(t2, e2) {
    for (var r2 = 0; r2 < e2.length; r2++) {
      var o3 = e2[r2];
      o3.enumerable = o3.enumerable || false, o3.configurable = true, "value" in o3 && (o3.writable = true), Object.defineProperty(t2, o3.key, o3);
    }
  }
  n2(gs, "_defineProperties");
  function sp(t2, e2, r2) {
    return e2 && gs(t2.prototype, e2), r2 && gs(t2, r2), t2;
  }
  n2(sp, "_createClass");
  function Rs(t2, e2) {
    var r2 = typeof Symbol < "u" && t2[Symbol.iterator] || t2["@@iterator"];
    if (!r2) {
      if (Array.isArray(t2) || (r2 = ap(t2)) || e2 && t2 && typeof t2.length == "number") {
        r2 && (t2 = r2);
        var o3 = 0, i2 = n2(function() {
        }, "F");
        return { s: i2, n: n2(function() {
          return o3 >= t2.length ? { done: true } : { done: false, value: t2[o3++] };
        }, "n"), e: n2(function(d2) {
          throw d2;
        }, "e"), f: i2 };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var s = true, a = false, l2;
    return { s: n2(function() {
      r2 = r2.call(t2);
    }, "s"), n: n2(function() {
      var d2 = r2.next();
      return s = d2.done, d2;
    }, "n"), e: n2(function(d2) {
      a = true, l2 = d2;
    }, "e"), f: n2(function() {
      try {
        !s && r2.return != null && r2.return();
      } finally {
        if (a) throw l2;
      }
    }, "f") };
  }
  n2(Rs, "_createForOfIteratorHelper");
  function ap(t2, e2) {
    if (t2) {
      if (typeof t2 == "string") return bs(t2, e2);
      var r2 = Object.prototype.toString.call(t2).slice(8, -1);
      if (r2 === "Object" && t2.constructor && (r2 = t2.constructor.name), r2 === "Map" || r2 === "Set") return Array.from(t2);
      if (r2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2)) return bs(t2, e2);
    }
  }
  n2(ap, "_unsupportedIterableToArray");
  function bs(t2, e2) {
    (e2 == null || e2 > t2.length) && (e2 = t2.length);
    for (var r2 = 0, o3 = new Array(e2); r2 < e2; r2++)
      o3[r2] = t2[r2];
    return o3;
  }
  n2(bs, "_arrayLikeToArray");
  var lp = hs(), Ss = {
    fg: "#FFF",
    bg: "#000",
    newline: false,
    escapeXML: false,
    stream: false,
    colors: cp()
  };
  function cp() {
    var t2 = {
      0: "#000",
      1: "#A00",
      2: "#0A0",
      3: "#A50",
      4: "#00A",
      5: "#A0A",
      6: "#0AA",
      7: "#AAA",
      8: "#555",
      9: "#F55",
      10: "#5F5",
      11: "#FF5",
      12: "#55F",
      13: "#F5F",
      14: "#5FF",
      15: "#FFF"
    };
    return Ht(0, 5).forEach(function(e2) {
      Ht(0, 5).forEach(function(r2) {
        Ht(0, 5).forEach(function(o3) {
          return dp(e2, r2, o3, t2);
        });
      });
    }), Ht(0, 23).forEach(function(e2) {
      var r2 = e2 + 232, o3 = Es(e2 * 10 + 8);
      t2[r2] = "#" + o3 + o3 + o3;
    }), t2;
  }
  n2(cp, "getDefaultColors");
  function dp(t2, e2, r2, o3) {
    var i2 = 16 + t2 * 36 + e2 * 6 + r2, s = t2 > 0 ? t2 * 40 + 55 : 0, a = e2 > 0 ? e2 * 40 + 55 : 0, l2 = r2 > 0 ? r2 * 40 + 55 : 0;
    o3[i2] = pp([s, a, l2]);
  }
  n2(dp, "setStyleColor");
  function Es(t2) {
    for (var e2 = t2.toString(16); e2.length < 2; )
      e2 = "0" + e2;
    return e2;
  }
  n2(Es, "toHexString");
  function pp(t2) {
    var e2 = [], r2 = Rs(t2), o3;
    try {
      for (r2.s(); !(o3 = r2.n()).done; ) {
        var i2 = o3.value;
        e2.push(Es(i2));
      }
    } catch (s) {
      r2.e(s);
    } finally {
      r2.f();
    }
    return "#" + e2.join("");
  }
  n2(pp, "toColorHexString");
  function xs(t2, e2, r2, o3) {
    var i2;
    return e2 === "text" ? i2 = yp(r2, o3) : e2 === "display" ? i2 = fp(t2, r2, o3) : e2 === "xterm256Foreground" ? i2 = Bt(t2, o3.colors[r2]) : e2 === "xterm256Background" ? i2 = Gt(t2, o3.colors[r2]) : e2 === "rgb" && (i2 = up(t2, r2)), i2;
  }
  n2(xs, "generateOutput");
  function up(t2, e2) {
    e2 = e2.substring(2).slice(0, -1);
    var r2 = +e2.substr(0, 2), o3 = e2.substring(5).split(";"), i2 = o3.map(function(s) {
      return ("0" + Number(s).toString(16)).substr(-2);
    }).join("");
    return $t(t2, (r2 === 38 ? "color:#" : "background-color:#") + i2);
  }
  n2(up, "handleRgb");
  function fp(t2, e2, r2) {
    e2 = parseInt(e2, 10);
    var o3 = {
      "-1": n2(function() {
        return "<br/>";
      }, "_"),
      0: n2(function() {
        return t2.length && As(t2);
      }, "_"),
      1: n2(function() {
        return me(t2, "b");
      }, "_"),
      3: n2(function() {
        return me(t2, "i");
      }, "_"),
      4: n2(function() {
        return me(t2, "u");
      }, "_"),
      8: n2(function() {
        return $t(t2, "display:none");
      }, "_"),
      9: n2(function() {
        return me(t2, "strike");
      }, "_"),
      22: n2(function() {
        return $t(t2, "font-weight:normal;text-decoration:none;font-style:normal");
      }, "_"),
      23: n2(function() {
        return ws(t2, "i");
      }, "_"),
      24: n2(function() {
        return ws(t2, "u");
      }, "_"),
      39: n2(function() {
        return Bt(t2, r2.fg);
      }, "_"),
      49: n2(function() {
        return Gt(t2, r2.bg);
      }, "_"),
      53: n2(function() {
        return $t(t2, "text-decoration:overline");
      }, "_")
    }, i2;
    return o3[e2] ? i2 = o3[e2]() : 4 < e2 && e2 < 7 ? i2 = me(t2, "blink") : 29 < e2 && e2 < 38 ? i2 = Bt(t2, r2.colors[e2 - 30]) : 39 < e2 && e2 < 48 ? i2 = Gt(t2, r2.colors[e2 - 40]) : 89 < e2 && e2 < 98 ? i2 = Bt(t2, r2.colors[8 + (e2 - 90)]) : 99 < e2 && e2 < 108 && (i2 = Gt(t2, r2.colors[8 + (e2 - 100)])), i2;
  }
  n2(fp, "handleDisplay");
  function As(t2) {
    var e2 = t2.slice(0);
    return t2.length = 0, e2.reverse().map(function(r2) {
      return "</" + r2 + ">";
    }).join("");
  }
  n2(As, "resetStyles");
  function Ht(t2, e2) {
    for (var r2 = [], o3 = t2; o3 <= e2; o3++)
      r2.push(o3);
    return r2;
  }
  n2(Ht, "range");
  function mp(t2) {
    return function(e2) {
      return (t2 === null || e2.category !== t2) && t2 !== "all";
    };
  }
  n2(mp, "notCategory");
  function Ts(t2) {
    t2 = parseInt(t2, 10);
    var e2 = null;
    return t2 === 0 ? e2 = "all" : t2 === 1 ? e2 = "bold" : 2 < t2 && t2 < 5 ? e2 = "underline" : 4 < t2 && t2 < 7 ? e2 = "blink" : t2 === 8 ? e2 = "hide" : t2 === 9 ? e2 = "strike" : 29 < t2 && t2 < 38 || t2 === 39 || 89 < t2 && t2 < 98 ? e2 = "foreground-color" : (39 < t2 && t2 < 48 || t2 === 49 || 99 < t2 && t2 < 108) && (e2 = "background-color"), e2;
  }
  n2(Ts, "categoryForCode");
  function yp(t2, e2) {
    return e2.escapeXML ? lp.encodeXML(t2) : t2;
  }
  n2(yp, "pushText");
  function me(t2, e2, r2) {
    return r2 || (r2 = ""), t2.push(e2), "<".concat(e2).concat(r2 ? ' style="'.concat(r2, '"') : "", ">");
  }
  n2(me, "pushTag");
  function $t(t2, e2) {
    return me(t2, "span", e2);
  }
  n2($t, "pushStyle");
  function Bt(t2, e2) {
    return me(t2, "span", "color:" + e2);
  }
  n2(Bt, "pushForegroundColor");
  function Gt(t2, e2) {
    return me(t2, "span", "background-color:" + e2);
  }
  n2(Gt, "pushBackgroundColor");
  function ws(t2, e2) {
    var r2;
    if (t2.slice(-1)[0] === e2 && (r2 = t2.pop()), r2)
      return "</" + e2 + ">";
  }
  n2(ws, "closeTag");
  function hp(t2, e2, r2) {
    var o3 = false, i2 = 3;
    function s() {
      return "";
    }
    n2(s, "remove");
    function a(A3, P4) {
      return r2("xterm256Foreground", P4), "";
    }
    n2(a, "removeXterm256Foreground");
    function l2(A3, P4) {
      return r2("xterm256Background", P4), "";
    }
    n2(l2, "removeXterm256Background");
    function c(A3) {
      return e2.newline ? r2("display", -1) : r2("text", A3), "";
    }
    n2(c, "newline");
    function d2(A3, P4) {
      o3 = true, P4.trim().length === 0 && (P4 = "0"), P4 = P4.trimRight(";").split(";");
      var m2 = Rs(P4), b4;
      try {
        for (m2.s(); !(b4 = m2.n()).done; ) {
          var S3 = b4.value;
          r2("display", S3);
        }
      } catch (C3) {
        m2.e(C3);
      } finally {
        m2.f();
      }
      return "";
    }
    n2(d2, "ansiMess");
    function p2(A3) {
      return r2("text", A3), "";
    }
    n2(p2, "realText");
    function u(A3) {
      return r2("rgb", A3), "";
    }
    n2(u, "rgb");
    var f3 = [{
      pattern: /^\x08+/,
      sub: s
    }, {
      pattern: /^\x1b\[[012]?K/,
      sub: s
    }, {
      pattern: /^\x1b\[\(B/,
      sub: s
    }, {
      pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/,
      sub: u
    }, {
      pattern: /^\x1b\[38;5;(\d+)m/,
      sub: a
    }, {
      pattern: /^\x1b\[48;5;(\d+)m/,
      sub: l2
    }, {
      pattern: /^\n/,
      sub: c
    }, {
      pattern: /^\r+\n/,
      sub: c
    }, {
      pattern: /^\r/,
      sub: c
    }, {
      pattern: /^\x1b\[((?:\d{1,3};?)+|)m/,
      sub: d2
    }, {
      // CSI n J
      // ED - Erase in Display Clears part of the screen.
      // If n is 0 (or missing), clear from cursor to end of screen.
      // If n is 1, clear from cursor to beginning of the screen.
      // If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI.SYS).
      // If n is 3, clear entire screen and delete all lines saved in the scrollback buffer
      //   (this feature was added for xterm and is supported by other terminal applications).
      pattern: /^\x1b\[\d?J/,
      sub: s
    }, {
      // CSI n ; m f
      // HVP - Horizontal Vertical Position Same as CUP
      pattern: /^\x1b\[\d{0,3};\d{0,3}f/,
      sub: s
    }, {
      // catch-all for CSI sequences?
      pattern: /^\x1b\[?[\d;]{0,3}/,
      sub: s
    }, {
      /**
       * extracts real text - not containing:
       * - `\x1b' - ESC - escape (Ascii 27)
       * - '\x08' - BS - backspace (Ascii 8)
       * - `\n` - Newline - linefeed (LF) (ascii 10)
       * - `\r` - Windows Carriage Return (CR)
       */
      pattern: /^(([^\x1b\x08\r\n])+)/,
      sub: p2
    }];
    function h2(A3, P4) {
      P4 > i2 && o3 || (o3 = false, t2 = t2.replace(A3.pattern, A3.sub));
    }
    n2(h2, "process");
    var g3 = [], T3 = t2, x4 = T3.length;
    e: for (; x4 > 0; ) {
      for (var v3 = 0, E = 0, y = f3.length; E < y; v3 = ++E) {
        var w4 = f3[v3];
        if (h2(w4, v3), t2.length !== x4) {
          x4 = t2.length;
          continue e;
        }
      }
      if (t2.length === x4)
        break;
      g3.push(0), x4 = t2.length;
    }
    return g3;
  }
  n2(hp, "tokenize");
  function gp(t2, e2, r2) {
    return e2 !== "text" && (t2 = t2.filter(mp(Ts(r2))), t2.push({
      token: e2,
      data: r2,
      category: Ts(r2)
    })), t2;
  }
  n2(gp, "updateStickyStack");
  var bp = function() {
    function t2(e2) {
      ip(this, t2), e2 = e2 || {}, e2.colors && (e2.colors = Object.assign({}, Ss.colors, e2.colors)), this.options = Object.assign({}, Ss, e2), this.stack = [], this.stickyStack = [];
    }
    return n2(t2, "Filter"), sp(t2, [{
      key: "toHtml",
      value: n2(function(r2) {
        var o3 = this;
        r2 = typeof r2 == "string" ? [r2] : r2;
        var i2 = this.stack, s = this.options, a = [];
        return this.stickyStack.forEach(function(l2) {
          var c = xs(i2, l2.token, l2.data, s);
          c && a.push(c);
        }), hp(r2.join(""), s, function(l2, c) {
          var d2 = xs(i2, l2, c, s);
          d2 && a.push(d2), s.stream && (o3.stickyStack = gp(o3.stickyStack, l2, c));
        }), i2.length && a.push(As(i2)), a.join("");
      }, "toHtml")
    }]), t2;
  }();
  vs.exports = bp;
});
function Wt() {
  let t2 = {
    setHandler: n2(() => {
    }, "setHandler"),
    send: n2(() => {
    }, "send")
  };
  return new z3({ transport: t2 });
}
n2(Wt, "mockChannel");
var Jt = class Jt2 {
  constructor() {
    this.getChannel = n2(() => {
      if (!this.channel) {
        let e2 = Wt();
        return this.setChannel(e2), e2;
      }
      return this.channel;
    }, "getChannel");
    this.ready = n2(() => this.promise, "ready");
    this.hasChannel = n2(() => !!this.channel, "hasChannel");
    this.setChannel = n2((e2) => {
      this.channel = e2, this.resolve();
    }, "setChannel");
    this.promise = new Promise((e2) => {
      this.resolve = () => e2(this.getChannel());
    });
  }
};
n2(Jt, "AddonStore");
var Xt = Jt;
var Kt = "__STORYBOOK_ADDONS_PREVIEW";
function Vs() {
  return scope[Kt] || (scope[Kt] = new Xt()), scope[Kt];
}
n2(Vs, "getAddonsStore");
var z5 = Vs();
function Ws(t2) {
  return t2;
}
n2(Ws, "definePreview");
var rr = class rr2 {
  constructor() {
    this.hookListsMap = void 0;
    this.mountedDecorators = void 0;
    this.prevMountedDecorators = void 0;
    this.currentHooks = void 0;
    this.nextHookIndex = void 0;
    this.currentPhase = void 0;
    this.currentEffects = void 0;
    this.prevEffects = void 0;
    this.currentDecoratorName = void 0;
    this.hasUpdates = void 0;
    this.currentContext = void 0;
    this.renderListener = n2((e2) => {
      e2 === this.currentContext?.id && (this.triggerEffects(), this.currentContext = null, this.removeRenderListeners());
    }, "renderListener");
    this.init();
  }
  init() {
    this.hookListsMap = /* @__PURE__ */ new WeakMap(), this.mountedDecorators = /* @__PURE__ */ new Set(), this.prevMountedDecorators = /* @__PURE__ */ new Set(), this.currentHooks = [], this.nextHookIndex = 0, this.currentPhase = "NONE", this.currentEffects = [], this.prevEffects = [], this.currentDecoratorName = null, this.hasUpdates = false, this.currentContext = null;
  }
  clean() {
    this.prevEffects.forEach((e2) => {
      e2.destroy && e2.destroy();
    }), this.init(), this.removeRenderListeners();
  }
  getNextHook() {
    let e2 = this.currentHooks[this.nextHookIndex];
    return this.nextHookIndex += 1, e2;
  }
  triggerEffects() {
    this.prevEffects.forEach((e2) => {
      !this.currentEffects.includes(e2) && e2.destroy && e2.destroy();
    }), this.currentEffects.forEach((e2) => {
      this.prevEffects.includes(e2) || (e2.destroy = e2.create());
    }), this.prevEffects = this.currentEffects, this.currentEffects = [];
  }
  addRenderListeners() {
    this.removeRenderListeners(), z5.getChannel().on(X2, this.renderListener);
  }
  removeRenderListeners() {
    z5.getChannel().removeListener(X2, this.renderListener);
  }
};
n2(rr, "HooksContext");
var he = rr;
function vo(t2) {
  let e2 = n2((...r2) => {
    let { hooks: o3 } = typeof r2[0] == "function" ? r2[1] : r2[0], i2 = o3.currentPhase, s = o3.currentHooks, a = o3.nextHookIndex, l2 = o3.currentDecoratorName;
    o3.currentDecoratorName = t2.name, o3.prevMountedDecorators.has(t2) ? (o3.currentPhase = "UPDATE", o3.currentHooks = o3.hookListsMap.get(t2) || []) : (o3.currentPhase = "MOUNT", o3.currentHooks = [], o3.hookListsMap.set(t2, o3.currentHooks), o3.prevMountedDecorators.add(t2)), o3.nextHookIndex = 0;
    let c = scope.STORYBOOK_HOOKS_CONTEXT;
    scope.STORYBOOK_HOOKS_CONTEXT = o3;
    let d2 = t2(...r2);
    if (scope.STORYBOOK_HOOKS_CONTEXT = c, o3.currentPhase === "UPDATE" && o3.getNextHook() != null)
      throw new Error(
        "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
      );
    return o3.currentPhase = i2, o3.currentHooks = s, o3.nextHookIndex = a, o3.currentDecoratorName = l2, d2;
  }, "hookified");
  return e2.originalFn = t2, e2;
}
n2(vo, "hookify");
var Zt = 0;
var Zs = 25;
var Qt = n2((t2) => (e2, r2) => {
  let o3 = t2(
    vo(e2),
    r2.map((i2) => vo(i2))
  );
  return (i2) => {
    let { hooks: s } = i2;
    s.prevMountedDecorators ??= /* @__PURE__ */ new Set(), s.mountedDecorators = /* @__PURE__ */ new Set([e2, ...r2]), s.currentContext = i2, s.hasUpdates = false;
    let a = o3(i2);
    for (Zt = 1; s.hasUpdates; )
      if (s.hasUpdates = false, s.currentEffects = [], a = o3(i2), Zt += 1, Zt > Zs)
        throw new Error(
          "Too many re-renders. Storybook limits the number of renders to prevent an infinite loop."
        );
    return s.addRenderListeners(), a;
  };
}, "applyHooks");
var Qs2 = n2((t2, e2) => t2.length === e2.length && t2.every((r2, o3) => r2 === e2[o3]), "areDepsEqual");
var er = n2(
  () => new Error("Storybook preview hooks can only be called inside decorators and story functions."),
  "invalidHooksError"
);
function Co() {
  return scope.STORYBOOK_HOOKS_CONTEXT || null;
}
n2(Co, "getHooksContextOrNull");
function tr() {
  let t2 = Co();
  if (t2 == null)
    throw er();
  return t2;
}
n2(tr, "getHooksContextOrThrow");
function ea(t2, e2, r2) {
  let o3 = tr();
  if (o3.currentPhase === "MOUNT") {
    r2 != null && !Array.isArray(r2) && i.warn(
      `${t2} received a final argument that is not an array (instead, received ${r2}). When specified, the final argument must be an array.`
    );
    let i2 = { name: t2, deps: r2 };
    return o3.currentHooks.push(i2), e2(i2), i2;
  }
  if (o3.currentPhase === "UPDATE") {
    let i2 = o3.getNextHook();
    if (i2 == null)
      throw new Error("Rendered more hooks than during the previous render.");
    return i2.name !== t2 && i.warn(
      `Storybook has detected a change in the order of Hooks${o3.currentDecoratorName ? ` called by ${o3.currentDecoratorName}` : ""}. This will lead to bugs and errors if not fixed.`
    ), r2 != null && i2.deps == null && i.warn(
      `${t2} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`
    ), r2 != null && i2.deps != null && r2.length !== i2.deps.length && i.warn(`The final argument passed to ${t2} changed size between renders. The order and size of this array must remain constant.
Previous: ${i2.deps}
Incoming: ${r2}`), (r2 == null || i2.deps == null || !Qs2(r2, i2.deps)) && (e2(i2), i2.deps = r2), i2;
  }
  throw er();
}
n2(ea, "useHook");
function dt(t2, e2, r2) {
  let { memoizedState: o3 } = ea(
    t2,
    (i2) => {
      i2.memoizedState = e2();
    },
    r2
  );
  return o3;
}
n2(dt, "useMemoLike");
function ta(t2, e2) {
  return dt("useMemo", t2, e2);
}
n2(ta, "useMemo");
function Ge(t2, e2) {
  return dt("useCallback", () => t2, e2);
}
n2(Ge, "useCallback");
function Po(t2, e2) {
  return dt(t2, () => ({ current: e2 }), []);
}
n2(Po, "useRefLike");
function ra(t2) {
  return Po("useRef", t2);
}
n2(ra, "useRef");
function oa() {
  let t2 = Co();
  if (t2 != null && t2.currentPhase !== "NONE")
    t2.hasUpdates = true;
  else
    try {
      z5.getChannel().emit(P);
    } catch {
      i.warn("State updates of Storybook preview hooks work only in browser");
    }
}
n2(oa, "triggerUpdate");
function Fo(t2, e2) {
  let r2 = Po(
    t2,
    // @ts-expect-error S type should never be function, but there's no way to tell that to TypeScript
    typeof e2 == "function" ? e2() : e2
  ), o3 = n2((i2) => {
    r2.current = typeof i2 == "function" ? i2(r2.current) : i2, oa();
  }, "setState");
  return [r2.current, o3];
}
n2(Fo, "useStateLike");
function na(t2) {
  return Fo("useState", t2);
}
n2(na, "useState");
function ia(t2, e2, r2) {
  let o3 = r2 != null ? () => r2(e2) : e2, [i2, s] = Fo("useReducer", o3);
  return [i2, n2((l2) => s((c) => t2(c, l2)), "dispatch")];
}
n2(ia, "useReducer");
function Io(t2, e2) {
  let r2 = tr(), o3 = dt("useEffect", () => ({ create: t2 }), e2);
  r2.currentEffects.includes(o3) || r2.currentEffects.push(o3);
}
n2(Io, "useEffect");
function sa(t2, e2 = []) {
  let r2 = z5.getChannel();
  return Io(() => (Object.entries(t2).forEach(([o3, i2]) => r2.on(o3, i2)), () => {
    Object.entries(t2).forEach(
      ([o3, i2]) => r2.removeListener(o3, i2)
    );
  }), [...Object.keys(t2), ...e2]), Ge(r2.emit.bind(r2), [r2]);
}
n2(sa, "useChannel");
function pt() {
  let { currentContext: t2 } = tr();
  if (t2 == null)
    throw er();
  return t2;
}
n2(pt, "useStoryContext");
function aa(t2, e2) {
  let { parameters: r2 } = pt();
  if (t2)
    return r2[t2] ?? e2;
}
n2(aa, "useParameter");
function la() {
  let t2 = z5.getChannel(), { id: e2, args: r2 } = pt(), o3 = Ge(
    (s) => t2.emit(Z, { storyId: e2, updatedArgs: s }),
    [t2, e2]
  ), i2 = Ge(
    (s) => t2.emit(p, { storyId: e2, argNames: s }),
    [t2, e2]
  );
  return [r2, o3, i2];
}
n2(la, "useArgs");
function ca() {
  let t2 = z5.getChannel(), { globals: e2 } = pt(), r2 = Ge(
    (o3) => t2.emit(z2, { globals: o3 }),
    [t2]
  );
  return [e2, r2];
}
n2(ca, "useGlobals");
var da = n2(({
  name: t2,
  parameterName: e2,
  wrapper: r2,
  skipIfNoParametersOrOptions: o3 = false
}) => {
  let i2 = n2((s) => (a, l2) => {
    let c = l2.parameters && l2.parameters[e2];
    return c && c.disable || o3 && !s && !c ? a(l2) : r2(a, l2, {
      options: s,
      parameters: c
    });
  }, "decorator");
  return (...s) => typeof s[0] == "function" ? i2()(...s) : (...a) => {
    if (a.length > 1)
      return s.length > 1 ? i2(s)(...a) : i2(...s)(...a);
    throw new Error(
      `Passing stories directly into ${t2}() is not allowed,
        instead use addDecorator(${t2}) and pass options with the '${e2}' parameter`
    );
  };
}, "makeDecorator");
function Oo() {
}
n2(Oo, "noop");
function or(t2) {
  return Object.getOwnPropertySymbols(t2).filter((e2) => Object.prototype.propertyIsEnumerable.call(t2, e2));
}
n2(or, "getSymbols");
function nr(t2) {
  return t2 == null ? t2 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(t2);
}
n2(nr, "getTag");
var ko = "[object RegExp]";
var Do = "[object String]";
var Mo = "[object Number]";
var Lo = "[object Boolean]";
var ir = "[object Arguments]";
var _o = "[object Symbol]";
var jo = "[object Date]";
var No = "[object Map]";
var qo = "[object Set]";
var Ho = "[object Array]";
var $o = "[object Function]";
var Bo = "[object ArrayBuffer]";
var ut = "[object Object]";
var Go = "[object Error]";
var zo = "[object DataView]";
var Uo = "[object Uint8Array]";
var Vo = "[object Uint8ClampedArray]";
var Wo = "[object Uint16Array]";
var Yo = "[object Uint32Array]";
var Ko = "[object BigUint64Array]";
var Xo = "[object Int8Array]";
var Jo = "[object Int16Array]";
var Zo = "[object Int32Array]";
var Qo = "[object BigInt64Array]";
var en = "[object Float32Array]";
var tn = "[object Float64Array]";
function $3(t2) {
  if (!t2 || typeof t2 != "object")
    return false;
  let e2 = Object.getPrototypeOf(t2);
  return e2 === null || e2 === Object.prototype || Object.getPrototypeOf(e2) === null ? Object.prototype.toString.call(t2) === "[object Object]" : false;
}
n2($3, "isPlainObject");
function re2(t2, e2) {
  let r2 = {}, o3 = Object.keys(t2);
  for (let i2 = 0; i2 < o3.length; i2++) {
    let s = o3[i2], a = t2[s];
    r2[s] = e2(a, s, t2);
  }
  return r2;
}
n2(re2, "mapValues");
function sr(t2, e2) {
  let r2 = {}, o3 = Object.keys(t2);
  for (let i2 = 0; i2 < o3.length; i2++) {
    let s = o3[i2], a = t2[s];
    e2(a, s) && (r2[s] = a);
  }
  return r2;
}
n2(sr, "pickBy");
function rn(t2, e2) {
  return t2 === e2 || Number.isNaN(t2) && Number.isNaN(e2);
}
n2(rn, "eq");
function on(t2, e2, r2) {
  return ze(t2, e2, void 0, void 0, void 0, void 0, r2);
}
n2(on, "isEqualWith");
function ze(t2, e2, r2, o3, i2, s, a) {
  let l2 = a(t2, e2, r2, o3, i2, s);
  if (l2 !== void 0)
    return l2;
  if (typeof t2 == typeof e2)
    switch (typeof t2) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined":
        return t2 === e2;
      case "number":
        return t2 === e2 || Object.is(t2, e2);
      case "function":
        return t2 === e2;
      case "object":
        return Ue(t2, e2, s, a);
    }
  return Ue(t2, e2, s, a);
}
n2(ze, "isEqualWithImpl");
function Ue(t2, e2, r2, o3) {
  if (Object.is(t2, e2))
    return true;
  let i2 = nr(t2), s = nr(e2);
  if (i2 === ir && (i2 = ut), s === ir && (s = ut), i2 !== s)
    return false;
  switch (i2) {
    case Do:
      return t2.toString() === e2.toString();
    case Mo: {
      let c = t2.valueOf(), d2 = e2.valueOf();
      return rn(c, d2);
    }
    case Lo:
    case jo:
    case _o:
      return Object.is(t2.valueOf(), e2.valueOf());
    case ko:
      return t2.source === e2.source && t2.flags === e2.flags;
    case $o:
      return t2 === e2;
  }
  r2 = r2 ?? /* @__PURE__ */ new Map();
  let a = r2.get(t2), l2 = r2.get(e2);
  if (a != null && l2 != null)
    return a === e2;
  r2.set(t2, e2), r2.set(e2, t2);
  try {
    switch (i2) {
      case No: {
        if (t2.size !== e2.size)
          return false;
        for (let [c, d2] of t2.entries())
          if (!e2.has(c) || !ze(d2, e2.get(c), c, t2, e2, r2, o3))
            return false;
        return true;
      }
      case qo: {
        if (t2.size !== e2.size)
          return false;
        let c = Array.from(t2.values()), d2 = Array.from(e2.values());
        for (let p2 = 0; p2 < c.length; p2++) {
          let u = c[p2], f3 = d2.findIndex((h2) => ze(u, h2, void 0, t2, e2, r2, o3));
          if (f3 === -1)
            return false;
          d2.splice(f3, 1);
        }
        return true;
      }
      case Ho:
      case Uo:
      case Vo:
      case Wo:
      case Yo:
      case Ko:
      case Xo:
      case Jo:
      case Zo:
      case Qo:
      case en:
      case tn: {
        if (typeof Buffer < "u" && Buffer.isBuffer(t2) !== Buffer.isBuffer(e2) || t2.length !== e2.length)
          return false;
        for (let c = 0; c < t2.length; c++)
          if (!ze(t2[c], e2[c], c, t2, e2, r2, o3))
            return false;
        return true;
      }
      case Bo:
        return t2.byteLength !== e2.byteLength ? false : Ue(new Uint8Array(t2), new Uint8Array(e2), r2, o3);
      case zo:
        return t2.byteLength !== e2.byteLength || t2.byteOffset !== e2.byteOffset ? false : Ue(new Uint8Array(t2), new Uint8Array(e2), r2, o3);
      case Go:
        return t2.name === e2.name && t2.message === e2.message;
      case ut: {
        if (!(Ue(t2.constructor, e2.constructor, r2, o3) || $3(t2) && $3(e2)))
          return false;
        let d2 = [...Object.keys(t2), ...or(t2)], p2 = [...Object.keys(e2), ...or(e2)];
        if (d2.length !== p2.length)
          return false;
        for (let u = 0; u < d2.length; u++) {
          let f3 = d2[u], h2 = t2[f3];
          if (!Object.hasOwn(e2, f3))
            return false;
          let g3 = e2[f3];
          if (!ze(h2, g3, f3, t2, e2, r2, o3))
            return false;
        }
        return true;
      }
      default:
        return false;
    }
  } finally {
    r2.delete(t2), r2.delete(e2);
  }
}
n2(Ue, "areObjectsEqual");
function ar(t2, e2) {
  return on(t2, e2, Oo);
}
n2(ar, "isEqual");
var It = ve(cr(), 1);
var pr = {};
Eo(pr, {
  argsEnhancers: () => ya
});
var dr = "storybook/actions";
var wu = `${dr}/panel`;
var sn = `${dr}/action-event`;
var Ru = `${dr}/action-clear`;
var an = {
  depth: 10,
  clearOnStoryChange: true,
  limit: 50
};
var cn2 = n2((t2, e2) => {
  let r2 = Object.getPrototypeOf(t2);
  return !r2 || e2(r2) ? r2 : cn2(r2, e2);
}, "findProto");
var fa = n2((t2) => !!(typeof t2 == "object" && t2 && cn2(t2, (e2) => /^Synthetic(?:Base)?Event$/.test(e2.constructor.name)) && typeof t2.persist == "function"), "isReactSyntheticEvent");
var ma = n2((t2) => {
  if (fa(t2)) {
    let e2 = Object.create(
      t2.constructor.prototype,
      Object.getOwnPropertyDescriptors(t2)
    );
    e2.persist();
    let r2 = Object.getOwnPropertyDescriptor(e2, "view"), o3 = r2?.value;
    return typeof o3 == "object" && o3?.constructor.name === "Window" && Object.defineProperty(e2, "view", {
      ...r2,
      value: Object.create(o3.constructor.prototype)
    }), e2;
  }
  return t2;
}, "serializeArg");
function Ve(t2, e2 = {}) {
  let r2 = {
    ...an,
    ...e2
  }, o3 = n2(function(...s) {
    if (e2.implicit) {
      let h2 = ("__STORYBOOK_PREVIEW__" in scope ? scope.__STORYBOOK_PREVIEW__ : void 0)?.storyRenders.find(
        (g3) => g3.phase === "playing" || g3.phase === "rendering"
      );
      if (h2) {
        let g3 = !globalThis?.FEATURES?.disallowImplicitActionsInRenderV8, T3 = new Y2({
          phase: h2.phase,
          name: t2,
          deprecated: g3
        });
        if (g3)
          console.warn(T3);
        else
          throw T3;
      }
    }
    let a = z5.getChannel(), l2 = Date.now().toString(36) + Math.random().toString(36).substring(2), c = 5, d2 = s.map(ma), p2 = s.length > 1 ? d2 : d2[0], u = {
      id: l2,
      count: 0,
      data: { name: t2, args: p2 },
      options: {
        ...r2,
        maxDepth: c + (r2.depth || 3)
      }
    };
    a.emit(sn, u);
  }, "actionHandler");
  return o3.isAction = true, o3.implicit = e2.implicit, o3;
}
n2(Ve, "action");
var dn = n2((t2, e2) => typeof e2[t2] > "u" && !(t2 in e2), "isInInitialArgs");
var pn = n2((t2) => {
  let {
    initialArgs: e2,
    argTypes: r2,
    id: o3,
    parameters: { actions: i2 }
  } = t2;
  if (!i2 || i2.disable || !i2.argTypesRegex || !r2)
    return {};
  let s = new RegExp(i2.argTypesRegex);
  return Object.entries(r2).filter(
    ([l2]) => !!s.test(l2)
  ).reduce((l2, [c, d2]) => (dn(c, e2) && (l2[c] = Ve(c, { implicit: true, id: o3 })), l2), {});
}, "inferActionsFromArgTypesRegex");
var un = n2((t2) => {
  let {
    initialArgs: e2,
    argTypes: r2,
    parameters: { actions: o3 }
  } = t2;
  return o3?.disable || !r2 ? {} : Object.entries(r2).filter(([s, a]) => !!a.action).reduce((s, [a, l2]) => (dn(a, e2) && (s[a] = Ve(typeof l2.action == "string" ? l2.action : a)), s), {});
}, "addActionsFromArgTypes");
var ya = [
  un,
  pn
];
var ur = {};
Eo(ur, {
  loaders: () => ba
});
var fn = false;
var ga = n2((t2) => {
  let { parameters: e2 } = t2;
  e2?.actions?.disable || fn || (abe((r2, o3) => {
    let i2 = r2.getMockName();
    i2 !== "spy" && (!/^next\/.*::/.test(i2) || [
      "next/router::useRouter()",
      "next/navigation::useRouter()",
      "next/navigation::redirect",
      "next/cache::",
      "next/headers::cookies().set",
      "next/headers::cookies().delete",
      "next/headers::headers().set",
      "next/headers::headers().delete"
    ].some((s) => i2.startsWith(s))) && Ve(i2)(o3);
  }), fn = true);
}, "logActionsWhenMockCalled");
var ba = [ga];
var fr = n2(() => Ws({
  ...pr,
  ...ur
}), "default");
var xa = "storybook/background";
var Ce = "backgrounds";
var zu = {
  UPDATE: `${xa}/update`
};
var mn = {
  light: { name: "light", value: "#F8F8F8" },
  dark: { name: "dark", value: "#333" }
};
var { document: W4 } = globalThis;
var yn = n2(() => globalThis?.matchMedia ? !!globalThis.matchMedia("(prefers-reduced-motion: reduce)")?.matches : false, "isReduceMotionEnabled");
var mr = n2((t2) => {
  (Array.isArray(t2) ? t2 : [t2]).forEach(Ta);
}, "clearStyles");
var Ta = n2((t2) => {
  if (!W4)
    return;
  let e2 = W4.getElementById(t2);
  e2 && e2.parentElement && e2.parentElement.removeChild(e2);
}, "clearStyle");
var hn = n2((t2, e2) => {
  if (!W4)
    return;
  let r2 = W4.getElementById(t2);
  if (r2)
    r2.innerHTML !== e2 && (r2.innerHTML = e2);
  else {
    let o3 = W4.createElement("style");
    o3.setAttribute("id", t2), o3.innerHTML = e2, W4.head.appendChild(o3);
  }
}, "addGridStyle");
var gn = n2((t2, e2, r2) => {
  if (!W4)
    return;
  let o3 = W4.getElementById(t2);
  if (o3)
    o3.innerHTML !== e2 && (o3.innerHTML = e2);
  else {
    let i2 = W4.createElement("style");
    i2.setAttribute("id", t2), i2.innerHTML = e2;
    let s = `addon-backgrounds-grid${r2 ? `-docs-${r2}` : ""}`, a = W4.getElementById(s);
    a ? a.parentElement?.insertBefore(i2, a) : W4.head.appendChild(i2);
  }
}, "addBackgroundStyle");
var wa = {
  cellSize: 100,
  cellAmount: 10,
  opacity: 0.8
};
var Sn = "addon-backgrounds";
var xn = "addon-backgrounds-grid";
var Ra = yn() ? "" : "transition: background-color 0.3s;";
var Tn = n2((t2, e2) => {
  let { globals: r2 = {}, parameters: o3 = {}, viewMode: i2, id: s } = e2, {
    options: a = mn,
    disable: l2,
    grid: c = wa
  } = o3[Ce] || {}, d2 = r2[Ce] || {}, p2 = typeof d2 == "string" ? d2 : d2?.value, u = p2 ? a[p2] : void 0, f3 = typeof u == "string" ? u : u?.value || "transparent", h2 = typeof d2 == "string" ? false : d2.grid || false, g3 = !!u && !l2, T3 = i2 === "docs" ? `#anchor--${s} .docs-story` : ".sb-show-main", x4 = i2 === "docs" ? `#anchor--${s} .docs-story` : ".sb-show-main", v3 = o3.layout === void 0 || o3.layout === "padded", E = i2 === "docs" ? 20 : v3 ? 16 : 0, { cellAmount: y, cellSize: w4, opacity: A3, offsetX: P4 = E, offsetY: m2 = E } = c, b4 = i2 === "docs" ? `${Sn}-docs-${s}` : `${Sn}-color`, S3 = i2 === "docs" ? s : null;
  Io(() => {
    let R3 = `
    ${T3} {
      background: ${f3} !important;
      ${Ra}
      }`;
    if (!g3) {
      mr(b4);
      return;
    }
    gn(b4, R3, S3);
  }, [T3, b4, S3, g3, f3]);
  let C3 = i2 === "docs" ? `${xn}-docs-${s}` : `${xn}`;
  return Io(() => {
    if (!h2) {
      mr(C3);
      return;
    }
    let R3 = [
      `${w4 * y}px ${w4 * y}px`,
      `${w4 * y}px ${w4 * y}px`,
      `${w4}px ${w4}px`,
      `${w4}px ${w4}px`
    ].join(", "), I5 = `
        ${x4} {
          background-size: ${R3} !important;
          background-position: ${P4}px ${m2}px, ${P4}px ${m2}px, ${P4}px ${m2}px, ${P4}px ${m2}px !important;
          background-blend-mode: difference !important;
          background-image: linear-gradient(rgba(130, 130, 130, ${A3}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${A3}) 1px, transparent 1px),
           linear-gradient(rgba(130, 130, 130, ${A3 / 2}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${A3 / 2}) 1px, transparent 1px) !important;
        }
      `;
    hn(C3, I5);
  }, [y, w4, x4, C3, h2, P4, m2, A3]), t2();
}, "withBackgroundAndGrid");
var Aa = globalThis.FEATURES?.backgrounds ? [Tn] : [];
var va = {
  [Ce]: {
    grid: {
      cellSize: 20,
      opacity: 0.5,
      cellAmount: 5
    },
    disable: false
  }
};
var Ca = {
  [Ce]: { value: void 0, grid: false }
};
var yr = n2(() => Ws({
  decorators: Aa,
  parameters: va,
  initialGlobals: Ca
}), "default");
var { step: Ia } = Qs(
  {
    // It seems like the label is unused, but the instrumenter has access to it
    // The context will be bounded later in StoryRender, so that the user can write just:
    // await step("label", (context) => {
    //   // labeled step
    // });
    step: n2(async (t2, e2, r2) => e2(r2), "step")
  },
  { intercept: true }
);
var hr = n2(() => Ws({
  parameters: {
    throwPlayFunctionExceptions: false
  },
  runStep: Ia
}), "default");
var ft = "storybook/highlight";
var wn = `${ft}/add`;
var Rn = `${ft}/remove`;
var En = `${ft}/reset`;
var An = `${ft}/scroll-into-view`;
var gr = 2147483647;
var J4 = 28;
var br = {
  chevronLeft: [
    "M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z"
  ],
  chevronRight: [
    "M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z"
  ],
  info: [
    "M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z",
    "M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z"
  ],
  shareAlt: [
    "M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z",
    "M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z"
  ]
};
var Oa = "svg,path,rect,circle,line,polyline,polygon,ellipse,text".split(",");
var j3 = n2((t2, e2 = {}, r2) => {
  let o3 = Oa.includes(t2) ? document.createElementNS("http://www.w3.org/2000/svg", t2) : document.createElement(t2);
  return Object.entries(e2).forEach(([i2, s]) => {
    /[A-Z]/.test(i2) ? (i2 === "onClick" && (o3.addEventListener("click", s), o3.addEventListener("keydown", (a) => {
      (a.key === "Enter" || a.key === " ") && (a.preventDefault(), s());
    })), i2 === "onMouseEnter" && o3.addEventListener("mouseenter", s), i2 === "onMouseLeave" && o3.addEventListener("mouseleave", s)) : o3.setAttribute(
      i2,
      s
    );
  }), r2?.forEach((i2) => {
    if (!(i2 == null || i2 === false))
      try {
        o3.appendChild(i2);
      } catch {
        o3.appendChild(document.createTextNode(String(i2)));
      }
  }), o3;
}, "createElement");
var Ye = n2((t2) => br[t2] && j3(
  "svg",
  { width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" },
  br[t2].map(
    (e2) => j3("path", {
      fill: "currentColor",
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: e2
    })
  )
), "createIcon");
var vn = n2((t2) => {
  if ("elements" in t2) {
    let { elements: o3, color: i2, style: s } = t2;
    return {
      id: void 0,
      priority: 0,
      selectors: o3,
      styles: {
        outline: `2px ${s} ${i2}`,
        outlineOffset: "2px",
        boxShadow: "0 0 0 6px rgba(255,255,255,0.6)"
      },
      menu: void 0
    };
  }
  let { menu: e2, ...r2 } = t2;
  return {
    id: void 0,
    priority: 0,
    styles: {
      outline: "2px dashed #029cfd"
    },
    ...r2,
    menu: Array.isArray(e2) ? e2.every(Array.isArray) ? e2 : [e2] : void 0
  };
}, "normalizeOptions");
var ka = n2((t2) => t2 instanceof Function, "isFunction");
var We = /* @__PURE__ */ new Map();
var ge = /* @__PURE__ */ new Map();
var mt = /* @__PURE__ */ new Map();
var Z2 = n2((t2) => {
  let e2 = Symbol();
  return ge.set(e2, []), We.set(e2, t2), { get: n2(() => We.get(e2), "get"), set: n2((a) => {
    let l2 = We.get(e2), c = ka(a) ? a(l2) : a;
    c !== l2 && (We.set(e2, c), ge.get(e2)?.forEach((d2) => {
      mt.get(d2)?.(), mt.set(d2, d2(c));
    }));
  }, "set"), subscribe: n2((a) => (ge.get(e2)?.push(a), () => {
    let l2 = ge.get(e2);
    l2 && ge.set(
      e2,
      l2.filter((c) => c !== a)
    );
  }), "subscribe"), teardown: n2(() => {
    ge.get(e2)?.forEach((a) => {
      mt.get(a)?.(), mt.delete(a);
    }), ge.delete(e2), We.delete(e2);
  }, "teardown") };
}, "useStore");
var Sr = n2((t2) => {
  let e2 = document.getElementById("storybook-root"), r2 = /* @__PURE__ */ new Map();
  for (let o3 of t2) {
    let { priority: i2 = 0 } = o3;
    for (let s of o3.selectors) {
      let a = [
        ...document.querySelectorAll(
          // Elements matching the selector, excluding storybook elements and their descendants.
          // Necessary to find portaled elements (e.g. children of `body`).
          `:is(${s}):not([id^="storybook-"], [id^="storybook-"] *, [class^="sb-"], [class^="sb-"] *)`
        ),
        // Elements matching the selector inside the storybook root, as these were excluded above.
        ...e2?.querySelectorAll(s) || []
      ];
      for (let l2 of a) {
        let c = r2.get(l2);
        (!c || c.priority <= i2) && r2.set(l2, {
          ...o3,
          priority: i2,
          selectors: Array.from(new Set((c?.selectors || []).concat(s)))
        });
      }
    }
  }
  return r2;
}, "mapElements");
var Cn = n2((t2) => Array.from(t2.entries()).map(([e2, {
  selectors: r2,
  styles: o3,
  hoverStyles: i2,
  focusStyles: s,
  menu: a
}]) => {
  let { top: l2, left: c, width: d2, height: p2 } = e2.getBoundingClientRect(), { position: u } = getComputedStyle(e2);
  return {
    element: e2,
    selectors: r2,
    styles: o3,
    hoverStyles: i2,
    focusStyles: s,
    menu: a,
    top: u === "fixed" ? l2 : l2 + window.scrollY,
    left: u === "fixed" ? c : c + window.scrollX,
    width: d2,
    height: p2
  };
}).sort((e2, r2) => r2.width * r2.height - e2.width * e2.height), "mapBoxes");
var xr = n2((t2, e2) => {
  let r2 = t2.getBoundingClientRect(), { x: o3, y: i2 } = e2;
  return r2?.top && r2?.left && o3 >= r2.left && o3 <= r2.left + r2.width && i2 >= r2.top && i2 <= r2.top + r2.height;
}, "isOverMenu");
var Tr = n2((t2, e2, r2) => {
  if (!e2 || !r2)
    return false;
  let { left: o3, top: i2, width: s, height: a } = t2;
  a < J4 && (i2 = i2 - Math.round((J4 - a) / 2), a = J4), s < J4 && (o3 = o3 - Math.round((J4 - s) / 2), s = J4), e2.style.position === "fixed" && (o3 += window.scrollX, i2 += window.scrollY);
  let { x: l2, y: c } = r2;
  return l2 >= o3 && l2 <= o3 + s && c >= i2 && c <= i2 + a;
}, "isTargeted");
var Pn = n2((t2, e2, r2 = {}) => {
  let { x: o3, y: i2 } = e2, { margin: s = 5, topOffset: a = 0, centered: l2 = false } = r2, { scrollX: c, scrollY: d2, innerHeight: p2, innerWidth: u } = window, f3 = Math.min(
    t2.style.position === "fixed" ? i2 - d2 : i2,
    p2 - t2.clientHeight - s - a + d2
  ), h2 = l2 ? t2.clientWidth / 2 : 0, g3 = t2.style.position === "fixed" ? Math.max(Math.min(o3 - c, u - h2 - s), h2 + s) : Math.max(
    Math.min(o3, u - h2 - s + c),
    h2 + s + c
  );
  Object.assign(t2.style, {
    ...g3 !== o3 && { left: `${g3}px` },
    ...f3 !== i2 && { top: `${f3}px` }
  });
}, "keepInViewport");
var wr = n2((t2) => {
  window.HTMLElement.prototype.hasOwnProperty("showPopover") && t2.showPopover();
}, "showPopover");
var Fn = n2((t2) => {
  window.HTMLElement.prototype.hasOwnProperty("showPopover") && t2.hidePopover();
}, "hidePopover");
var In = n2((t2) => ({
  top: t2.top,
  left: t2.left,
  width: t2.width,
  height: t2.height,
  selectors: t2.selectors,
  element: {
    attributes: Object.fromEntries(
      Array.from(t2.element.attributes).map((e2) => [e2.name, e2.value])
    ),
    localName: t2.element.localName,
    tagName: t2.element.tagName,
    outerHTML: t2.element.outerHTML
  }
}), "getEventDetails");
var M3 = "storybook-highlights-menu";
var On = "storybook-highlights-root";
var Ma = "storybook-root";
var kn = n2((t2) => {
  if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED)
    return;
  globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = true;
  let { document: e2 } = globalThis, r2 = Z2([]), o3 = Z2(/* @__PURE__ */ new Map()), i2 = Z2([]), s = Z2(), a = Z2(), l2 = Z2([]), c = Z2([]), d2 = Z2(), p2 = Z2(), u = e2.getElementById(On);
  r2.subscribe(() => {
    u || (u = j3("div", { id: On }), e2.body.appendChild(u));
  }), r2.subscribe((m2) => {
    let b4 = e2.getElementById(Ma);
    if (!b4)
      return;
    o3.set(Sr(m2));
    let S3 = new MutationObserver(() => o3.set(Sr(m2)));
    return S3.observe(b4, { subtree: true, childList: true }), () => {
      S3.disconnect();
    };
  }), o3.subscribe((m2) => {
    let b4 = n2(() => requestAnimationFrame(() => i2.set(Cn(m2))), "updateBoxes"), S3 = new ResizeObserver(b4);
    S3.observe(e2.body), Array.from(m2.keys()).forEach((R3) => S3.observe(R3));
    let C3 = Array.from(e2.body.querySelectorAll("*")).filter((R3) => {
      let { overflow: I5, overflowX: F2, overflowY: k3 } = window.getComputedStyle(R3);
      return ["auto", "scroll"].some((B3) => [I5, F2, k3].includes(B3));
    });
    return C3.forEach((R3) => R3.addEventListener("scroll", b4)), () => {
      S3.disconnect(), C3.forEach((R3) => R3.removeEventListener("scroll", b4));
    };
  }), o3.subscribe((m2) => {
    let b4 = Array.from(m2.keys()).filter(({ style: C3 }) => C3.position === "sticky"), S3 = n2(() => requestAnimationFrame(() => {
      i2.set(
        (C3) => C3.map((R3) => {
          if (b4.includes(R3.element)) {
            let { top: I5, left: F2 } = R3.element.getBoundingClientRect();
            return { ...R3, top: I5 + window.scrollY, left: F2 + window.scrollX };
          }
          return R3;
        })
      );
    }), "updateBoxes");
    return e2.addEventListener("scroll", S3), () => e2.removeEventListener("scroll", S3);
  }), o3.subscribe((m2) => {
    l2.set((b4) => b4.filter(({ element: S3 }) => m2.has(S3)));
  }), l2.subscribe((m2) => {
    m2.length ? (p2.set((b4) => m2.some((S3) => S3.element === b4?.element) ? b4 : void 0), d2.set((b4) => m2.some((S3) => S3.element === b4?.element) ? b4 : void 0)) : (p2.set(void 0), d2.set(void 0), s.set(void 0));
  });
  let f3 = new Map(/* @__PURE__ */ new Map());
  r2.subscribe((m2) => {
    m2.forEach(({ keyframes: b4 }) => {
      if (b4) {
        let S3 = f3.get(b4);
        S3 || (S3 = e2.createElement("style"), S3.setAttribute("data-highlight", "keyframes"), f3.set(b4, S3), e2.head.appendChild(S3)), S3.innerHTML = b4;
      }
    }), f3.forEach((b4, S3) => {
      m2.some((C3) => C3.keyframes === S3) || (b4.remove(), f3.delete(S3));
    });
  });
  let h2 = new Map(/* @__PURE__ */ new Map());
  i2.subscribe((m2) => {
    m2.forEach((b4) => {
      let S3 = h2.get(b4.element);
      if (u && !S3) {
        let C3 = {
          popover: "manual",
          "data-highlight-dimensions": `w${b4.width.toFixed(0)}h${b4.height.toFixed(0)}`,
          "data-highlight-coordinates": `x${b4.left.toFixed(0)}y${b4.top.toFixed(0)}`
        };
        S3 = u.appendChild(
          j3("div", C3, [j3("div")])
        ), h2.set(b4.element, S3);
      }
    }), h2.forEach((b4, S3) => {
      m2.some(({ element: C3 }) => C3 === S3) || (b4.remove(), h2.delete(S3));
    });
  }), i2.subscribe((m2) => {
    let b4 = m2.filter((C3) => C3.menu);
    if (!b4.length)
      return;
    let S3 = n2((C3) => {
      requestAnimationFrame(() => {
        let R3 = e2.getElementById(M3), I5 = { x: C3.pageX, y: C3.pageY };
        if (R3 && !xr(R3, I5)) {
          let F2 = b4.filter((k3) => {
            let B3 = h2.get(k3.element);
            return Tr(k3, B3, I5);
          });
          s.set(F2.length ? I5 : void 0), l2.set(F2);
        }
      });
    }, "onClick");
    return e2.addEventListener("click", S3), () => e2.removeEventListener("click", S3);
  });
  let g3 = n2(() => {
    let m2 = e2.getElementById(M3), b4 = a.get();
    !b4 || m2 && xr(m2, b4) || c.set((S3) => {
      let C3 = i2.get().filter((k3) => {
        let B3 = h2.get(k3.element);
        return Tr(k3, B3, b4);
      }), R3 = S3.filter((k3) => C3.includes(k3)), I5 = C3.filter((k3) => !S3.includes(k3)), F2 = S3.length - R3.length;
      return I5.length || F2 ? [...R3, ...I5] : S3;
    });
  }, "updateHovered");
  a.subscribe(g3), i2.subscribe(g3);
  let T3 = n2(() => {
    let m2 = p2.get(), b4 = m2 ? [m2] : l2.get(), S3 = b4.length === 1 ? b4[0] : d2.get(), C3 = s.get() !== void 0;
    i2.get().forEach((R3) => {
      let I5 = h2.get(R3.element);
      if (I5) {
        let F2 = S3 === R3, k3 = C3 ? S3 ? F2 : b4.includes(R3) : c.get()?.includes(R3);
        Object.assign(I5.style, {
          animation: "none",
          background: "transparent",
          border: "none",
          boxSizing: "border-box",
          outline: "none",
          outlineOffset: "0px",
          ...R3.styles,
          ...k3 ? R3.hoverStyles : {},
          ...F2 ? R3.focusStyles : {},
          position: getComputedStyle(R3.element).position === "fixed" ? "fixed" : "absolute",
          zIndex: gr - 10,
          top: `${R3.top}px`,
          left: `${R3.left}px`,
          width: `${R3.width}px`,
          height: `${R3.height}px`,
          margin: 0,
          padding: 0,
          cursor: R3.menu && k3 ? "pointer" : "default",
          pointerEvents: R3.menu ? "auto" : "none",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          overflow: "visible"
        }), Object.assign(I5.children[0].style, {
          width: "100%",
          height: "100%",
          minHeight: `${J4}px`,
          minWidth: `${J4}px`,
          boxSizing: "content-box",
          padding: I5.style.outlineWidth || "0px"
        }), wr(I5);
      }
    });
  }, "updateBoxStyles");
  i2.subscribe(T3), l2.subscribe(T3), c.subscribe(T3), d2.subscribe(T3), p2.subscribe(T3);
  let x4 = n2(() => {
    if (!u)
      return;
    let m2 = e2.getElementById(M3);
    if (m2)
      m2.innerHTML = "";
    else {
      let R3 = { id: M3, popover: "manual" };
      m2 = u.appendChild(j3("div", R3)), u.appendChild(
        j3("style", {}, [
          `
            #${M3} {
              position: absolute;
              z-index: ${gr};
              width: 300px;
              padding: 0px;
              margin: 15px 0 0 0;
              transform: translateX(-50%);
              font-family: "Nunito Sans", -apple-system, ".SFNSText-Regular", "San Francisco", BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
              font-size: 12px;
              background: white;
              border: none;
              border-radius: 6px;
              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);
              color: #2E3438;
            }
            #${M3} ul {
              list-style: none;
              margin: 0;
              padding: 0;
            }
            #${M3} > ul {
              max-height: 300px;
              overflow-y: auto;
              padding: 4px 0;
            }
            #${M3} li {
              padding: 0 4px;
              margin: 0;
            }
            #${M3} li > :not(ul) {
              display: flex;
              padding: 8px;
              margin: 0;
              align-items: center;
              gap: 8px;
              border-radius: 4px;
            }
            #${M3} button {
              width: 100%;
              border: 0;
              background: transparent;
              color: inherit;
              text-align: left;
              font-family: inherit;
              font-size: inherit;
            }
            #${M3} button:focus-visible {
              outline-color: #029CFD;
            }
            #${M3} button:hover {
              background: rgba(2, 156, 253, 0.07);
              color: #029CFD;
              cursor: pointer;
            }
            #${M3} li code {
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              line-height: 16px;
              font-size: 11px;
            }
            #${M3} li svg {
              flex-shrink: 0;
              margin: 1px;
              color: #73828C;
            }
            #${M3} li > button:hover svg, #${M3} li > button:focus-visible svg {
              color: #029CFD;
            }
            #${M3} .element-list li svg {
              display: none;
            }
            #${M3} li.selectable svg, #${M3} li.selected svg {
              display: block;
            }
            #${M3} .menu-list {
              border-top: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${M3} .menu-list > li:not(:last-child) {
              padding-bottom: 4px;
              margin-bottom: 4px;
              border-bottom: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${M3} .menu-items, #${M3} .menu-items li {
              padding: 0;
            }
            #${M3} .menu-item {
              display: flex;
            }
            #${M3} .menu-item-content {
              display: flex;
              flex-direction: column;
              flex-grow: 1;
            }
          `
        ])
      );
    }
    let b4 = p2.get(), S3 = b4 ? [b4] : l2.get();
    if (S3.length && (m2.style.position = getComputedStyle(S3[0].element).position === "fixed" ? "fixed" : "absolute", m2.appendChild(
      j3(
        "ul",
        { class: "element-list" },
        S3.map((R3) => {
          let I5 = S3.length > 1 && !!R3.menu?.some(
            (B3) => B3.some(
              (L3) => !L3.selectors || L3.selectors.some((X4) => R3.selectors.includes(X4))
            )
          ), F2 = I5 ? {
            class: "selectable",
            onClick: n2(() => p2.set(R3), "onClick"),
            onMouseEnter: n2(() => d2.set(R3), "onMouseEnter"),
            onMouseLeave: n2(() => d2.set(void 0), "onMouseLeave")
          } : b4 ? { class: "selected", onClick: n2(() => p2.set(void 0), "onClick") } : {}, k3 = I5 || b4;
          return j3("li", F2, [
            j3(k3 ? "button" : "div", k3 ? { type: "button" } : {}, [
              b4 ? Ye("chevronLeft") : null,
              j3("code", {}, [R3.element.outerHTML]),
              I5 ? Ye("chevronRight") : null
            ])
          ]);
        })
      )
    )), p2.get() || l2.get().length === 1) {
      let R3 = p2.get() || l2.get()[0], I5 = R3.menu?.filter(
        (F2) => F2.some(
          (k3) => !k3.selectors || k3.selectors.some((B3) => R3.selectors.includes(B3))
        )
      );
      I5?.length && m2.appendChild(
        j3(
          "ul",
          { class: "menu-list" },
          I5.map(
            (F2) => j3("li", {}, [
              j3(
                "ul",
                { class: "menu-items" },
                F2.map(
                  ({ id: k3, title: B3, description: L3, iconLeft: X4, iconRight: ye, clickEvent: Ro }) => {
                    let Vt = Ro && (() => t2.emit(Ro, k3, In(R3)));
                    return j3("li", {}, [
                      j3(
                        Vt ? "button" : "div",
                        Vt ? { class: "menu-item", type: "button", onClick: Vt } : { class: "menu-item" },
                        [
                          X4 ? Ye(X4) : null,
                          j3("div", { class: "menu-item-content" }, [
                            j3(L3 ? "strong" : "span", {}, [B3]),
                            L3 && j3("span", {}, [L3])
                          ]),
                          ye ? Ye(ye) : null
                        ]
                      )
                    ]);
                  }
                )
              )
            ])
          )
        )
      );
    }
    let C3 = s.get();
    C3 ? (Object.assign(m2.style, {
      display: "block",
      left: `${m2.style.position === "fixed" ? C3.x - window.scrollX : C3.x}px`,
      top: `${m2.style.position === "fixed" ? C3.y - window.scrollY : C3.y}px`
    }), wr(m2), requestAnimationFrame(() => Pn(m2, C3, { topOffset: 15, centered: true }))) : (Fn(m2), Object.assign(m2.style, { display: "none" }));
  }, "renderMenu");
  l2.subscribe(x4), p2.subscribe(x4);
  let v3 = n2((m2) => {
    let b4 = vn(m2);
    r2.set((S3) => {
      let C3 = b4.id ? S3.filter((R3) => R3.id !== b4.id) : S3;
      return b4.selectors?.length ? [...C3, b4] : C3;
    });
  }, "addHighlight"), E = n2((m2) => {
    m2 && r2.set((b4) => b4.filter((S3) => S3.id !== m2));
  }, "removeHighlight"), y = n2(() => {
    r2.set([]), o3.set(/* @__PURE__ */ new Map()), i2.set([]), s.set(void 0), a.set(void 0), l2.set([]), c.set([]), d2.set(void 0), p2.set(void 0);
  }, "resetState"), w4, A3 = n2((m2, b4) => {
    let S3 = "scrollIntoView-highlight";
    clearTimeout(w4), E(S3);
    let C3 = e2.querySelector(m2);
    if (!C3) {
      console.warn(`Cannot scroll into view: ${m2} not found`);
      return;
    }
    C3.scrollIntoView({ behavior: "smooth", block: "center", ...b4 });
    let R3 = `kf-${Math.random().toString(36).substring(2, 15)}`;
    r2.set((I5) => [
      ...I5,
      {
        id: S3,
        priority: 1e3,
        selectors: [m2],
        styles: {
          outline: "2px solid #1EA7FD",
          outlineOffset: "-1px",
          animation: `${R3} 3s linear forwards`
        },
        keyframes: `@keyframes ${R3} {
          0% { outline: 2px solid #1EA7FD; }
          20% { outline: 2px solid #1EA7FD00; }
          40% { outline: 2px solid #1EA7FD; }
          60% { outline: 2px solid #1EA7FD00; }
          80% { outline: 2px solid #1EA7FD; }
          100% { outline: 2px solid #1EA7FD00; }
        }`
      }
    ]), w4 = setTimeout(() => E(S3), 3500);
  }, "scrollIntoView"), P4 = n2((m2) => {
    requestAnimationFrame(() => a.set({ x: m2.pageX, y: m2.pageY }));
  }, "onMouseMove");
  e2.body.addEventListener("mousemove", P4), t2.on(wn, v3), t2.on(Rn, E), t2.on(En, y), t2.on(An, A3), t2.on(B, ({ newPhase: m2 }) => {
    m2 === "loading" && y();
  });
}, "useHighlights");
globalThis?.FEATURES?.highlight && z5?.ready && z5.ready().then(kn);
var Rr = n2(() => Ws({}), "default");
var yt = "storybook/measure-addon";
var vf = `${yt}/tool`;
var Mn = "measureEnabled";
var Cf = {
  RESULT: `${yt}/result`,
  REQUEST: `${yt}/request`,
  CLEAR: `${yt}/clear`
};
var _a = false;
var Er = "Invariant failed";
function se2(t2, e2) {
  if (!t2) {
    if (_a)
      throw new Error(Er);
    var r2 = typeof e2 == "function" ? e2() : e2, o3 = r2 ? "".concat(Er, ": ").concat(r2) : Er;
    throw new Error(o3);
  }
}
n2(se2, "invariant");
function Ln() {
  let t2 = scope.document.documentElement, e2 = Math.max(t2.scrollHeight, t2.offsetHeight);
  return { width: Math.max(t2.scrollWidth, t2.offsetWidth), height: e2 };
}
n2(Ln, "getDocumentWidthAndHeight");
function ja() {
  let t2 = scope.document.createElement("canvas");
  t2.id = "storybook-addon-measure";
  let e2 = t2.getContext("2d");
  se2(e2 != null);
  let { width: r2, height: o3 } = Ln();
  return Ar(t2, e2, { width: r2, height: o3 }), t2.style.position = "absolute", t2.style.left = "0", t2.style.top = "0", t2.style.zIndex = "2147483647", t2.style.pointerEvents = "none", scope.document.body.appendChild(t2), { canvas: t2, context: e2, width: r2, height: o3 };
}
n2(ja, "createCanvas");
function Ar(t2, e2, { width: r2, height: o3 }) {
  t2.style.width = `${r2}px`, t2.style.height = `${o3}px`;
  let i2 = scope.window.devicePixelRatio;
  t2.width = Math.floor(r2 * i2), t2.height = Math.floor(o3 * i2), e2.scale(i2, i2);
}
n2(Ar, "setCanvasWidthAndHeight");
var N3 = {};
function _n() {
  N3.canvas || (N3 = ja());
}
n2(_n, "init");
function jn() {
  N3.context && N3.context.clearRect(0, 0, N3.width ?? 0, N3.height ?? 0);
}
n2(jn, "clear");
function Nn(t2) {
  jn(), t2(N3.context);
}
n2(Nn, "draw");
function qn() {
  se2(N3.canvas, "Canvas should exist in the state."), se2(N3.context, "Context should exist in the state."), Ar(N3.canvas, N3.context, {
    width: 0,
    height: 0
  });
  let { width: t2, height: e2 } = Ln();
  Ar(N3.canvas, N3.context, { width: t2, height: e2 }), N3.width = t2, N3.height = e2;
}
n2(qn, "rescale");
function Hn() {
  N3.canvas && (jn(), N3.canvas.parentNode?.removeChild(N3.canvas), N3 = {});
}
n2(Hn, "destroy");
var Pe = {
  margin: "#f6b26b",
  border: "#ffe599",
  padding: "#93c47d",
  content: "#6fa8dc",
  text: "#232020"
};
var oe2 = 6;
function $n(t2, { x: e2, y: r2, w: o3, h: i2, r: s }) {
  e2 = e2 - o3 / 2, r2 = r2 - i2 / 2, o3 < 2 * s && (s = o3 / 2), i2 < 2 * s && (s = i2 / 2), t2.beginPath(), t2.moveTo(e2 + s, r2), t2.arcTo(e2 + o3, r2, e2 + o3, r2 + i2, s), t2.arcTo(e2 + o3, r2 + i2, e2, r2 + i2, s), t2.arcTo(e2, r2 + i2, e2, r2, s), t2.arcTo(e2, r2, e2 + o3, r2, s), t2.closePath();
}
n2($n, "roundedRect");
function Na(t2, { padding: e2, border: r2, width: o3, height: i2, top: s, left: a }) {
  let l2 = o3 - r2.left - r2.right - e2.left - e2.right, c = i2 - e2.top - e2.bottom - r2.top - r2.bottom, d2 = a + r2.left + e2.left, p2 = s + r2.top + e2.top;
  return t2 === "top" ? d2 += l2 / 2 : t2 === "right" ? (d2 += l2, p2 += c / 2) : t2 === "bottom" ? (d2 += l2 / 2, p2 += c) : t2 === "left" ? p2 += c / 2 : t2 === "center" && (d2 += l2 / 2, p2 += c / 2), { x: d2, y: p2 };
}
n2(Na, "positionCoordinate");
function qa(t2, e2, { margin: r2, border: o3, padding: i2 }, s, a) {
  let l2 = n2((f3) => 0, "shift"), c = 0, d2 = 0, p2 = a ? 1 : 0.5, u = a ? s * 2 : 0;
  return t2 === "padding" ? l2 = n2((f3) => i2[f3] * p2 + u, "shift") : t2 === "border" ? l2 = n2((f3) => i2[f3] + o3[f3] * p2 + u, "shift") : t2 === "margin" && (l2 = n2((f3) => i2[f3] + o3[f3] + r2[f3] * p2 + u, "shift")), e2 === "top" ? d2 = -l2("top") : e2 === "right" ? c = l2("right") : e2 === "bottom" ? d2 = l2("bottom") : e2 === "left" && (c = -l2("left")), { offsetX: c, offsetY: d2 };
}
n2(qa, "offset");
function Ha(t2, e2) {
  return Math.abs(t2.x - e2.x) < Math.abs(t2.w + e2.w) / 2 && Math.abs(t2.y - e2.y) < Math.abs(t2.h + e2.h) / 2;
}
n2(Ha, "collide");
function $a(t2, e2, r2) {
  return t2 === "top" ? e2.y = r2.y - r2.h - oe2 : t2 === "right" ? e2.x = r2.x + r2.w / 2 + oe2 + e2.w / 2 : t2 === "bottom" ? e2.y = r2.y + r2.h + oe2 : t2 === "left" && (e2.x = r2.x - r2.w / 2 - oe2 - e2.w / 2), { x: e2.x, y: e2.y };
}
n2($a, "overlapAdjustment");
function Bn(t2, e2, { x: r2, y: o3, w: i2, h: s }, a) {
  return $n(t2, { x: r2, y: o3, w: i2, h: s, r: 3 }), t2.fillStyle = `${Pe[e2]}dd`, t2.fill(), t2.strokeStyle = Pe[e2], t2.stroke(), t2.fillStyle = Pe.text, t2.fillText(a, r2, o3), $n(t2, { x: r2, y: o3, w: i2, h: s, r: 3 }), t2.fillStyle = `${Pe[e2]}dd`, t2.fill(), t2.strokeStyle = Pe[e2], t2.stroke(), t2.fillStyle = Pe.text, t2.fillText(a, r2, o3), { x: r2, y: o3, w: i2, h: s };
}
n2(Bn, "textWithRect");
function Gn(t2, e2) {
  t2.font = "600 12px monospace", t2.textBaseline = "middle", t2.textAlign = "center";
  let r2 = t2.measureText(e2), o3 = r2.actualBoundingBoxAscent + r2.actualBoundingBoxDescent, i2 = r2.width + oe2 * 2, s = o3 + oe2 * 2;
  return { w: i2, h: s };
}
n2(Gn, "configureText");
function Ba(t2, e2, { type: r2, position: o3 = "center", text: i2 }, s, a = false) {
  let { x: l2, y: c } = Na(o3, e2), { offsetX: d2, offsetY: p2 } = qa(r2, o3, e2, oe2 + 1, a);
  l2 += d2, c += p2;
  let { w: u, h: f3 } = Gn(t2, i2);
  if (s && Ha({ x: l2, y: c, w: u, h: f3 }, s)) {
    let h2 = $a(o3, { x: l2, y: c, w: u, h: f3 }, s);
    l2 = h2.x, c = h2.y;
  }
  return Bn(t2, r2, { x: l2, y: c, w: u, h: f3 }, i2);
}
n2(Ba, "drawLabel");
function Ga(t2, { w: e2, h: r2 }) {
  let o3 = e2 * 0.5 + oe2, i2 = r2 * 0.5 + oe2;
  return {
    offsetX: (t2.x === "left" ? -1 : 1) * o3,
    offsetY: (t2.y === "top" ? -1 : 1) * i2
  };
}
n2(Ga, "floatingOffset");
function za(t2, e2, { type: r2, text: o3 }) {
  let { floatingAlignment: i2, extremities: s } = e2, a = s[i2.x], l2 = s[i2.y], { w: c, h: d2 } = Gn(t2, o3), { offsetX: p2, offsetY: u } = Ga(i2, {
    w: c,
    h: d2
  });
  return a += p2, l2 += u, Bn(t2, r2, { x: a, y: l2, w: c, h: d2 }, o3);
}
n2(za, "drawFloatingLabel");
function Ke(t2, e2, r2, o3) {
  let i2 = [];
  r2.forEach((s, a) => {
    let l2 = o3 && s.position === "center" ? za(t2, e2, s) : Ba(t2, e2, s, i2[a - 1], o3);
    i2[a] = l2;
  });
}
n2(Ke, "drawStack");
function zn(t2, e2, r2, o3) {
  let i2 = r2.reduce((s, a) => (Object.prototype.hasOwnProperty.call(s, a.position) || (s[a.position] = []), s[a.position]?.push(a), s), {});
  i2.top && Ke(t2, e2, i2.top, o3), i2.right && Ke(t2, e2, i2.right, o3), i2.bottom && Ke(t2, e2, i2.bottom, o3), i2.left && Ke(t2, e2, i2.left, o3), i2.center && Ke(t2, e2, i2.center, o3);
}
n2(zn, "labelStacks");
var gt = {
  margin: "#f6b26ba8",
  border: "#ffe599a8",
  padding: "#93c47d8c",
  content: "#6fa8dca8"
};
var Un = 30;
function U3(t2) {
  return parseInt(t2.replace("px", ""), 10);
}
n2(U3, "pxToNumber");
function Fe(t2) {
  return Number.isInteger(t2) ? t2 : t2.toFixed(2);
}
n2(Fe, "round");
function vr(t2) {
  return t2.filter((e2) => e2.text !== 0 && e2.text !== "0");
}
n2(vr, "filterZeroValues");
function Ua(t2) {
  let e2 = {
    top: scope.window.scrollY,
    bottom: scope.window.scrollY + scope.window.innerHeight,
    left: scope.window.scrollX,
    right: scope.window.scrollX + scope.window.innerWidth
  }, r2 = {
    top: Math.abs(e2.top - t2.top),
    bottom: Math.abs(e2.bottom - t2.bottom),
    left: Math.abs(e2.left - t2.left),
    right: Math.abs(e2.right - t2.right)
  };
  return {
    x: r2.left > r2.right ? "left" : "right",
    y: r2.top > r2.bottom ? "top" : "bottom"
  };
}
n2(Ua, "floatingAlignment");
function Va(t2) {
  let e2 = scope.getComputedStyle(t2), { top: r2, left: o3, right: i2, bottom: s, width: a, height: l2 } = t2.getBoundingClientRect(), {
    marginTop: c,
    marginBottom: d2,
    marginLeft: p2,
    marginRight: u,
    paddingTop: f3,
    paddingBottom: h2,
    paddingLeft: g3,
    paddingRight: T3,
    borderBottomWidth: x4,
    borderTopWidth: v3,
    borderLeftWidth: E,
    borderRightWidth: y
  } = e2;
  r2 = r2 + scope.window.scrollY, o3 = o3 + scope.window.scrollX, s = s + scope.window.scrollY, i2 = i2 + scope.window.scrollX;
  let w4 = {
    top: U3(c),
    bottom: U3(d2),
    left: U3(p2),
    right: U3(u)
  }, A3 = {
    top: U3(f3),
    bottom: U3(h2),
    left: U3(g3),
    right: U3(T3)
  }, P4 = {
    top: U3(v3),
    bottom: U3(x4),
    left: U3(E),
    right: U3(y)
  }, m2 = {
    top: r2 - w4.top,
    bottom: s + w4.bottom,
    left: o3 - w4.left,
    right: i2 + w4.right
  };
  return {
    margin: w4,
    padding: A3,
    border: P4,
    top: r2,
    left: o3,
    bottom: s,
    right: i2,
    width: a,
    height: l2,
    extremities: m2,
    floatingAlignment: Ua(m2)
  };
}
n2(Va, "measureElement");
function Wa(t2, { margin: e2, width: r2, height: o3, top: i2, left: s, bottom: a, right: l2 }) {
  let c = o3 + e2.bottom + e2.top;
  t2.fillStyle = gt.margin, t2.fillRect(s, i2 - e2.top, r2, e2.top), t2.fillRect(l2, i2 - e2.top, e2.right, c), t2.fillRect(s, a, r2, e2.bottom), t2.fillRect(
    s - e2.left,
    i2 - e2.top,
    e2.left,
    c
  );
  let d2 = [
    {
      type: "margin",
      text: Fe(e2.top),
      position: "top"
    },
    {
      type: "margin",
      text: Fe(e2.right),
      position: "right"
    },
    {
      type: "margin",
      text: Fe(e2.bottom),
      position: "bottom"
    },
    {
      type: "margin",
      text: Fe(e2.left),
      position: "left"
    }
  ];
  return vr(d2);
}
n2(Wa, "drawMargin");
function Ya(t2, { padding: e2, border: r2, width: o3, height: i2, top: s, left: a, bottom: l2, right: c }) {
  let d2 = o3 - r2.left - r2.right, p2 = i2 - e2.top - e2.bottom - r2.top - r2.bottom;
  t2.fillStyle = gt.padding, t2.fillRect(a + r2.left, s + r2.top, d2, e2.top), t2.fillRect(
    c - e2.right - r2.right,
    s + e2.top + r2.top,
    e2.right,
    p2
  ), t2.fillRect(
    a + r2.left,
    l2 - e2.bottom - r2.bottom,
    d2,
    e2.bottom
  ), t2.fillRect(a + r2.left, s + e2.top + r2.top, e2.left, p2);
  let u = [
    {
      type: "padding",
      text: e2.top,
      position: "top"
    },
    {
      type: "padding",
      text: e2.right,
      position: "right"
    },
    {
      type: "padding",
      text: e2.bottom,
      position: "bottom"
    },
    {
      type: "padding",
      text: e2.left,
      position: "left"
    }
  ];
  return vr(u);
}
n2(Ya, "drawPadding");
function Ka(t2, { border: e2, width: r2, height: o3, top: i2, left: s, bottom: a, right: l2 }) {
  let c = o3 - e2.top - e2.bottom;
  t2.fillStyle = gt.border, t2.fillRect(s, i2, r2, e2.top), t2.fillRect(s, a - e2.bottom, r2, e2.bottom), t2.fillRect(s, i2 + e2.top, e2.left, c), t2.fillRect(
    l2 - e2.right,
    i2 + e2.top,
    e2.right,
    c
  );
  let d2 = [
    {
      type: "border",
      text: e2.top,
      position: "top"
    },
    {
      type: "border",
      text: e2.right,
      position: "right"
    },
    {
      type: "border",
      text: e2.bottom,
      position: "bottom"
    },
    {
      type: "border",
      text: e2.left,
      position: "left"
    }
  ];
  return vr(d2);
}
n2(Ka, "drawBorder");
function Xa(t2, { padding: e2, border: r2, width: o3, height: i2, top: s, left: a }) {
  let l2 = o3 - r2.left - r2.right - e2.left - e2.right, c = i2 - e2.top - e2.bottom - r2.top - r2.bottom;
  return t2.fillStyle = gt.content, t2.fillRect(
    a + r2.left + e2.left,
    s + r2.top + e2.top,
    l2,
    c
  ), [
    {
      type: "content",
      position: "center",
      text: `${Fe(l2)} x ${Fe(c)}`
    }
  ];
}
n2(Xa, "drawContent");
function Ja(t2) {
  return (e2) => {
    if (t2 && e2) {
      let r2 = Va(t2), o3 = Wa(e2, r2), i2 = Ya(e2, r2), s = Ka(e2, r2), a = Xa(e2, r2), l2 = r2.width <= Un * 3 || r2.height <= Un;
      zn(
        e2,
        r2,
        [...a, ...i2, ...s, ...o3],
        l2
      );
    }
  };
}
n2(Ja, "drawBoxModel");
function Vn(t2) {
  Nn(Ja(t2));
}
n2(Vn, "drawSelectedElement");
var Wn = n2((t2, e2) => {
  let r2 = scope.document.elementFromPoint(t2, e2), o3 = n2((s) => {
    if (s && s.shadowRoot) {
      let a = s.shadowRoot.elementFromPoint(t2, e2);
      return s.isEqualNode(a) ? s : a.shadowRoot ? o3(a) : a;
    }
    return s;
  }, "crawlShadows");
  return o3(r2) || r2;
}, "deepElementFromPoint");
var Kn;
var bt = { x: 0, y: 0 };
function Xn(t2, e2) {
  Kn = Wn(t2, e2), Vn(Kn);
}
n2(Xn, "findAndDrawElement");
var Jn = n2((t2, e2) => {
  let { measureEnabled: r2 } = e2.globals || {};
  return Io(() => {
    if (typeof globalThis.document > "u")
      return;
    let o3 = n2((i2) => {
      window.requestAnimationFrame(() => {
        i2.stopPropagation(), bt.x = i2.clientX, bt.y = i2.clientY;
      });
    }, "onPointerMove");
    return globalThis.document.addEventListener("pointermove", o3), () => {
      globalThis.document.removeEventListener("pointermove", o3);
    };
  }, []), Io(() => {
    let o3 = n2((s) => {
      window.requestAnimationFrame(() => {
        s.stopPropagation(), Xn(s.clientX, s.clientY);
      });
    }, "onPointerOver"), i2 = n2(() => {
      window.requestAnimationFrame(() => {
        qn();
      });
    }, "onResize");
    return e2.viewMode === "story" && r2 && (globalThis.document.addEventListener("pointerover", o3), _n(), globalThis.window.addEventListener(
      "resize",
      i2
    ), Xn(bt.x, bt.y)), () => {
      globalThis.window.removeEventListener("resize", i2), Hn();
    };
  }, [r2, e2.viewMode]), t2();
}, "withMeasure");
var el = globalThis.FEATURES?.measure ? [Jn] : [];
var tl = {
  [Mn]: false
};
var Cr = n2(() => Ws({
  decorators: el,
  initialGlobals: tl
}), "default");
var St = "outline";
var Pr = n2((t2) => {
  (Array.isArray(t2) ? t2 : [t2]).forEach(rl);
}, "clearStyles");
var rl = n2((t2) => {
  let e2 = typeof t2 == "string" ? t2 : t2.join(""), r2 = scope.document.getElementById(e2);
  r2 && r2.parentElement && r2.parentElement.removeChild(r2);
}, "clearStyle");
var Zn = n2((t2, e2) => {
  let r2 = scope.document.getElementById(t2);
  if (r2)
    r2.innerHTML !== e2 && (r2.innerHTML = e2);
  else {
    let o3 = scope.document.createElement("style");
    o3.setAttribute("id", t2), o3.innerHTML = e2, scope.document.head.appendChild(o3);
  }
}, "addOutlineStyles");
function _3(t2) {
  for (var e2 = [], r2 = 1; r2 < arguments.length; r2++)
    e2[r2 - 1] = arguments[r2];
  var o3 = Array.from(typeof t2 == "string" ? [t2] : t2);
  o3[o3.length - 1] = o3[o3.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var i2 = o3.reduce(function(l2, c) {
    var d2 = c.match(/\n([\t ]+|(?!\s).)/g);
    return d2 ? l2.concat(d2.map(function(p2) {
      var u, f3;
      return (f3 = (u = p2.match(/[\t ]/g)) === null || u === void 0 ? void 0 : u.length) !== null && f3 !== void 0 ? f3 : 0;
    })) : l2;
  }, []);
  if (i2.length) {
    var s = new RegExp(`
[	 ]{` + Math.min.apply(Math, i2) + "}", "g");
    o3 = o3.map(function(l2) {
      return l2.replace(s, `
`);
    });
  }
  o3[0] = o3[0].replace(/^\r?\n/, "");
  var a = o3[0];
  return e2.forEach(function(l2, c) {
    var d2 = a.match(/(?:^|\n)( *)$/), p2 = d2 ? d2[1] : "", u = l2;
    typeof l2 == "string" && l2.includes(`
`) && (u = String(l2).split(`
`).map(function(f3, h2) {
      return h2 === 0 ? f3 : "" + p2 + f3;
    }).join(`
`)), a += u + o3[c + 1];
  }), a;
}
n2(_3, "dedent");
function Fr(t2) {
  return _3`
    ${t2} body {
      outline: 1px solid #2980b9 !important;
    }

    ${t2} article {
      outline: 1px solid #3498db !important;
    }

    ${t2} nav {
      outline: 1px solid #0088c3 !important;
    }

    ${t2} aside {
      outline: 1px solid #33a0ce !important;
    }

    ${t2} section {
      outline: 1px solid #66b8da !important;
    }

    ${t2} header {
      outline: 1px solid #99cfe7 !important;
    }

    ${t2} footer {
      outline: 1px solid #cce7f3 !important;
    }

    ${t2} h1 {
      outline: 1px solid #162544 !important;
    }

    ${t2} h2 {
      outline: 1px solid #314e6e !important;
    }

    ${t2} h3 {
      outline: 1px solid #3e5e85 !important;
    }

    ${t2} h4 {
      outline: 1px solid #449baf !important;
    }

    ${t2} h5 {
      outline: 1px solid #c7d1cb !important;
    }

    ${t2} h6 {
      outline: 1px solid #4371d0 !important;
    }

    ${t2} main {
      outline: 1px solid #2f4f90 !important;
    }

    ${t2} address {
      outline: 1px solid #1a2c51 !important;
    }

    ${t2} div {
      outline: 1px solid #036cdb !important;
    }

    ${t2} p {
      outline: 1px solid #ac050b !important;
    }

    ${t2} hr {
      outline: 1px solid #ff063f !important;
    }

    ${t2} pre {
      outline: 1px solid #850440 !important;
    }

    ${t2} blockquote {
      outline: 1px solid #f1b8e7 !important;
    }

    ${t2} ol {
      outline: 1px solid #ff050c !important;
    }

    ${t2} ul {
      outline: 1px solid #d90416 !important;
    }

    ${t2} li {
      outline: 1px solid #d90416 !important;
    }

    ${t2} dl {
      outline: 1px solid #fd3427 !important;
    }

    ${t2} dt {
      outline: 1px solid #ff0043 !important;
    }

    ${t2} dd {
      outline: 1px solid #e80174 !important;
    }

    ${t2} figure {
      outline: 1px solid #ff00bb !important;
    }

    ${t2} figcaption {
      outline: 1px solid #bf0032 !important;
    }

    ${t2} table {
      outline: 1px solid #00cc99 !important;
    }

    ${t2} caption {
      outline: 1px solid #37ffc4 !important;
    }

    ${t2} thead {
      outline: 1px solid #98daca !important;
    }

    ${t2} tbody {
      outline: 1px solid #64a7a0 !important;
    }

    ${t2} tfoot {
      outline: 1px solid #22746b !important;
    }

    ${t2} tr {
      outline: 1px solid #86c0b2 !important;
    }

    ${t2} th {
      outline: 1px solid #a1e7d6 !important;
    }

    ${t2} td {
      outline: 1px solid #3f5a54 !important;
    }

    ${t2} col {
      outline: 1px solid #6c9a8f !important;
    }

    ${t2} colgroup {
      outline: 1px solid #6c9a9d !important;
    }

    ${t2} button {
      outline: 1px solid #da8301 !important;
    }

    ${t2} datalist {
      outline: 1px solid #c06000 !important;
    }

    ${t2} fieldset {
      outline: 1px solid #d95100 !important;
    }

    ${t2} form {
      outline: 1px solid #d23600 !important;
    }

    ${t2} input {
      outline: 1px solid #fca600 !important;
    }

    ${t2} keygen {
      outline: 1px solid #b31e00 !important;
    }

    ${t2} label {
      outline: 1px solid #ee8900 !important;
    }

    ${t2} legend {
      outline: 1px solid #de6d00 !important;
    }

    ${t2} meter {
      outline: 1px solid #e8630c !important;
    }

    ${t2} optgroup {
      outline: 1px solid #b33600 !important;
    }

    ${t2} option {
      outline: 1px solid #ff8a00 !important;
    }

    ${t2} output {
      outline: 1px solid #ff9619 !important;
    }

    ${t2} progress {
      outline: 1px solid #e57c00 !important;
    }

    ${t2} select {
      outline: 1px solid #e26e0f !important;
    }

    ${t2} textarea {
      outline: 1px solid #cc5400 !important;
    }

    ${t2} details {
      outline: 1px solid #33848f !important;
    }

    ${t2} summary {
      outline: 1px solid #60a1a6 !important;
    }

    ${t2} command {
      outline: 1px solid #438da1 !important;
    }

    ${t2} menu {
      outline: 1px solid #449da6 !important;
    }

    ${t2} del {
      outline: 1px solid #bf0000 !important;
    }

    ${t2} ins {
      outline: 1px solid #400000 !important;
    }

    ${t2} img {
      outline: 1px solid #22746b !important;
    }

    ${t2} iframe {
      outline: 1px solid #64a7a0 !important;
    }

    ${t2} embed {
      outline: 1px solid #98daca !important;
    }

    ${t2} object {
      outline: 1px solid #00cc99 !important;
    }

    ${t2} param {
      outline: 1px solid #37ffc4 !important;
    }

    ${t2} video {
      outline: 1px solid #6ee866 !important;
    }

    ${t2} audio {
      outline: 1px solid #027353 !important;
    }

    ${t2} source {
      outline: 1px solid #012426 !important;
    }

    ${t2} canvas {
      outline: 1px solid #a2f570 !important;
    }

    ${t2} track {
      outline: 1px solid #59a600 !important;
    }

    ${t2} map {
      outline: 1px solid #7be500 !important;
    }

    ${t2} area {
      outline: 1px solid #305900 !important;
    }

    ${t2} a {
      outline: 1px solid #ff62ab !important;
    }

    ${t2} em {
      outline: 1px solid #800b41 !important;
    }

    ${t2} strong {
      outline: 1px solid #ff1583 !important;
    }

    ${t2} i {
      outline: 1px solid #803156 !important;
    }

    ${t2} b {
      outline: 1px solid #cc1169 !important;
    }

    ${t2} u {
      outline: 1px solid #ff0430 !important;
    }

    ${t2} s {
      outline: 1px solid #f805e3 !important;
    }

    ${t2} small {
      outline: 1px solid #d107b2 !important;
    }

    ${t2} abbr {
      outline: 1px solid #4a0263 !important;
    }

    ${t2} q {
      outline: 1px solid #240018 !important;
    }

    ${t2} cite {
      outline: 1px solid #64003c !important;
    }

    ${t2} dfn {
      outline: 1px solid #b4005a !important;
    }

    ${t2} sub {
      outline: 1px solid #dba0c8 !important;
    }

    ${t2} sup {
      outline: 1px solid #cc0256 !important;
    }

    ${t2} time {
      outline: 1px solid #d6606d !important;
    }

    ${t2} code {
      outline: 1px solid #e04251 !important;
    }

    ${t2} kbd {
      outline: 1px solid #5e001f !important;
    }

    ${t2} samp {
      outline: 1px solid #9c0033 !important;
    }

    ${t2} var {
      outline: 1px solid #d90047 !important;
    }

    ${t2} mark {
      outline: 1px solid #ff0053 !important;
    }

    ${t2} bdi {
      outline: 1px solid #bf3668 !important;
    }

    ${t2} bdo {
      outline: 1px solid #6f1400 !important;
    }

    ${t2} ruby {
      outline: 1px solid #ff7b93 !important;
    }

    ${t2} rt {
      outline: 1px solid #ff2f54 !important;
    }

    ${t2} rp {
      outline: 1px solid #803e49 !important;
    }

    ${t2} span {
      outline: 1px solid #cc2643 !important;
    }

    ${t2} br {
      outline: 1px solid #db687d !important;
    }

    ${t2} wbr {
      outline: 1px solid #db175b !important;
    }`;
}
n2(Fr, "outlineCSS");
var Qn = n2((t2, e2) => {
  let r2 = e2.globals || {}, o3 = [true, "true"].includes(r2[St]), i2 = e2.viewMode === "docs", s = ta(() => Fr(i2 ? '[data-story-block="true"]' : ".sb-show-main"), [e2]);
  return Io(() => {
    let a = i2 ? `addon-outline-docs-${e2.id}` : "addon-outline";
    return o3 ? Zn(a, s) : Pr(a), () => {
      Pr(a);
    };
  }, [o3, s, e2]), t2();
}, "withOutline");
var sl = globalThis.FEATURES?.outline ? [Qn] : [];
var al = {
  [St]: false
};
var Ir = n2(() => Ws({ decorators: sl, initialGlobals: al }), "default");
var gl = n2(({ parameters: t2 }) => {
  t2?.test?.mockReset === true ? cbe() : t2?.test?.clearMocks === true ? ube() : t2?.test?.restoreMocks !== false && dbe();
}, "resetAllMocksLoader");
var Or = n2((t2, e2 = 0, r2) => {
  if (e2 > 5 || t2 == null)
    return t2;
  if (cn(t2))
    return r2 && t2.mockName(r2), t2;
  if (typeof t2 == "function" && "isAction" in t2 && t2.isAction && !("implicit" in t2 && t2.implicit)) {
    let o3 = lbe(t2);
    return r2 && o3.mockName(r2), o3;
  }
  if (Array.isArray(t2)) {
    e2++;
    for (let o3 = 0; o3 < t2.length; o3++)
      Object.getOwnPropertyDescriptor(t2, o3)?.writable && (t2[o3] = Or(t2[o3], e2));
    return t2;
  }
  if (typeof t2 == "object" && t2.constructor === Object) {
    e2++;
    for (let [o3, i2] of Object.entries(t2))
      Object.getOwnPropertyDescriptor(t2, o3)?.writable && (t2[o3] = Or(i2, e2, o3));
    return t2;
  }
  return t2;
}, "traverseArgs");
var bl = n2(({ initialArgs: t2 }) => {
  Or(t2);
}, "nameSpiesAndWrapActionsInSpies");
var ei = false;
var Sl = n2(async (t2) => {
  globalThis.HTMLElement && t2.canvasElement instanceof globalThis.HTMLElement && (t2.canvas = KTe(t2.canvasElement));
  let e2 = globalThis.window?.navigator?.clipboard;
  if (e2) {
    t2.userEvent = Qs(
      { userEvent: XTe.setup() },
      { intercept: true }
    ).userEvent, Object.defineProperty(globalThis.window.navigator, "clipboard", {
      get: n2(() => e2, "get"),
      configurable: true
    });
    let r2 = HTMLElement.prototype.focus;
    ei || Object.defineProperties(HTMLElement.prototype, {
      focus: {
        configurable: true,
        set: n2((o3) => {
          r2 = o3, ei = true;
        }, "set"),
        get: n2(() => r2, "get")
      }
    });
  }
}, "enhanceContext");
var kr = n2(() => Ws({
  loaders: [gl, bl, Sl]
}), "default");
var ti = "storybook/viewport";
var ri = "viewport";
var Cm = `${ti}/panel`;
var Pm = `${ti}/tool`;
var Tl = {
  [ri]: { value: void 0, isRotated: false }
};
var Dr = n2(() => Ws({
  initialGlobals: Tl
}), "default");
function Xe() {
  return [
    // @ts-expect-error CJS fallback
    (Cr.default ?? Cr)(),
    // @ts-expect-error CJS fallback
    (yr.default ?? yr)(),
    // @ts-expect-error CJS fallback
    (Rr.default ?? Rr)(),
    // @ts-expect-error CJS fallback
    (Ir.default ?? Ir)(),
    // @ts-expect-error CJS fallback
    (Dr.default ?? Dr)(),
    // @ts-expect-error CJS fallback
    (fr.default ?? fr)(),
    // @ts-expect-error CJS fallback
    (hr.default ?? hr)(),
    // @ts-expect-error CJS fallback
    (kr.default ?? kr)()
  ];
}
n2(Xe, "getCoreAnnotations");
var Ie = Symbol("incompatible");
var Lr = n2((t2, e2) => {
  let r2 = e2.type;
  if (t2 == null || !r2 || e2.mapping)
    return t2;
  switch (r2.name) {
    case "string":
      return String(t2);
    case "enum":
      return t2;
    case "number":
      return Number(t2);
    case "boolean":
      return String(t2) === "true";
    case "array":
      return !r2.value || !Array.isArray(t2) ? Ie : t2.reduce((o3, i2, s) => {
        let a = Lr(i2, { type: r2.value });
        return a !== Ie && (o3[s] = a), o3;
      }, new Array(t2.length));
    case "object":
      return typeof t2 == "string" || typeof t2 == "number" ? t2 : !r2.value || typeof t2 != "object" ? Ie : Object.entries(t2).reduce((o3, [i2, s]) => {
        let a = Lr(s, { type: r2.value[i2] });
        return a === Ie ? o3 : Object.assign(o3, { [i2]: a });
      }, {});
    default:
      return Ie;
  }
}, "map");
var oi = n2((t2, e2) => Object.entries(t2).reduce((r2, [o3, i2]) => {
  if (!e2[o3])
    return r2;
  let s = Lr(i2, e2[o3]);
  return s === Ie ? r2 : Object.assign(r2, { [o3]: s });
}, {}), "mapArgsToTypes");
var Je = n2((t2, e2) => Array.isArray(t2) && Array.isArray(e2) ? e2.reduce(
  (r2, o3, i2) => (r2[i2] = Je(t2[i2], e2[i2]), r2),
  [...t2]
).filter((r2) => r2 !== void 0) : !$3(t2) || !$3(e2) ? e2 : Object.keys({ ...t2, ...e2 }).reduce((r2, o3) => {
  if (o3 in e2) {
    let i2 = Je(t2[o3], e2[o3]);
    i2 !== void 0 && (r2[o3] = i2);
  } else
    r2[o3] = t2[o3];
  return r2;
}, {}), "combineArgs");
var ni = n2((t2, e2) => Object.entries(e2).reduce((r2, [o3, { options: i2 }]) => {
  function s() {
    return o3 in t2 && (r2[o3] = t2[o3]), r2;
  }
  if (n2(s, "allowArg"), !i2)
    return s();
  if (!Array.isArray(i2))
    return o.error(_3`
        Invalid argType: '${o3}.options' should be an array.

        More info: https://storybook.js.org/docs/api/arg-types
      `), s();
  if (i2.some((u) => u && ["object", "function"].includes(typeof u)))
    return o.error(_3`
        Invalid argType: '${o3}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
      `), s();
  let a = Array.isArray(t2[o3]), l2 = a && t2[o3].findIndex((u) => !i2.includes(u)), c = a && l2 === -1;
  if (t2[o3] === void 0 || i2.includes(t2[o3]) || c)
    return s();
  let d2 = a ? `${o3}[${l2}]` : o3, p2 = i2.map((u) => typeof u == "string" ? `'${u}'` : String(u)).join(", ");
  return o.warn(`Received illegal value for '${d2}'. Supported options: ${p2}`), r2;
}, {}), "validateOptions");
var be = Symbol("Deeply equal");
var Oe = n2((t2, e2) => {
  if (typeof t2 != typeof e2)
    return e2;
  if (ar(t2, e2))
    return be;
  if (Array.isArray(t2) && Array.isArray(e2)) {
    let r2 = e2.reduce((o3, i2, s) => {
      let a = Oe(t2[s], i2);
      return a !== be && (o3[s] = a), o3;
    }, new Array(e2.length));
    return e2.length >= t2.length ? r2 : r2.concat(new Array(t2.length - e2.length).fill(void 0));
  }
  return $3(t2) && $3(e2) ? Object.keys({ ...t2, ...e2 }).reduce((r2, o3) => {
    let i2 = Oe(t2?.[o3], e2?.[o3]);
    return i2 === be ? r2 : Object.assign(r2, { [o3]: i2 });
  }, {}) : e2;
}, "deepDiff");
var _r = "UNTARGETED";
function ii({
  args: t2,
  argTypes: e2
}) {
  let r2 = {};
  return Object.entries(t2).forEach(([o3, i2]) => {
    let { target: s = _r } = e2[o3] || {};
    r2[s] = r2[s] || {}, r2[s][o3] = i2;
  }), r2;
}
n2(ii, "groupArgsByTarget");
function wl(t2) {
  return Object.keys(t2).forEach((e2) => t2[e2] === void 0 && delete t2[e2]), t2;
}
n2(wl, "deleteUndefined");
var jr = class jr2 {
  constructor() {
    this.initialArgsByStoryId = {};
    this.argsByStoryId = {};
  }
  get(e2) {
    if (!(e2 in this.argsByStoryId))
      throw new Error(`No args known for ${e2} -- has it been rendered yet?`);
    return this.argsByStoryId[e2];
  }
  setInitial(e2) {
    if (!this.initialArgsByStoryId[e2.id])
      this.initialArgsByStoryId[e2.id] = e2.initialArgs, this.argsByStoryId[e2.id] = e2.initialArgs;
    else if (this.initialArgsByStoryId[e2.id] !== e2.initialArgs) {
      let r2 = Oe(this.initialArgsByStoryId[e2.id], this.argsByStoryId[e2.id]);
      this.initialArgsByStoryId[e2.id] = e2.initialArgs, this.argsByStoryId[e2.id] = e2.initialArgs, r2 !== be && this.updateFromDelta(e2, r2);
    }
  }
  updateFromDelta(e2, r2) {
    let o3 = ni(r2, e2.argTypes);
    this.argsByStoryId[e2.id] = Je(this.argsByStoryId[e2.id], o3);
  }
  updateFromPersisted(e2, r2) {
    let o3 = oi(r2, e2.argTypes);
    return this.updateFromDelta(e2, o3);
  }
  update(e2, r2) {
    if (!(e2 in this.argsByStoryId))
      throw new Error(`No args known for ${e2} -- has it been rendered yet?`);
    this.argsByStoryId[e2] = wl({
      ...this.argsByStoryId[e2],
      ...r2
    });
  }
};
n2(jr, "ArgsStore");
var Tt = jr;
var wt = n2((t2 = {}) => Object.entries(t2).reduce((e2, [r2, { defaultValue: o3 }]) => (typeof o3 < "u" && (e2[r2] = o3), e2), {}), "getValuesFromArgTypes");
var Nr = class Nr2 {
  constructor({
    globals: e2 = {},
    globalTypes: r2 = {}
  }) {
    this.set({ globals: e2, globalTypes: r2 });
  }
  set({ globals: e2 = {}, globalTypes: r2 = {} }) {
    let o3 = this.initialGlobals && Oe(this.initialGlobals, this.globals);
    this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(e2), ...Object.keys(r2)]);
    let i2 = wt(r2);
    this.initialGlobals = { ...i2, ...e2 }, this.globals = this.initialGlobals, o3 && o3 !== be && this.updateFromPersisted(o3);
  }
  filterAllowedGlobals(e2) {
    return Object.entries(e2).reduce((r2, [o3, i2]) => (this.allowedGlobalNames.has(o3) ? r2[o3] = i2 : i.warn(
      `Attempted to set a global (${o3}) that is not defined in initial globals or globalTypes`
    ), r2), {});
  }
  updateFromPersisted(e2) {
    let r2 = this.filterAllowedGlobals(e2);
    this.globals = { ...this.globals, ...r2 };
  }
  get() {
    return this.globals;
  }
  update(e2) {
    this.globals = { ...this.globals, ...this.filterAllowedGlobals(e2) };
    for (let r2 in e2)
      e2[r2] === void 0 && (this.globals[r2] = this.initialGlobals[r2]);
  }
};
n2(Nr, "GlobalsStore");
var Rt = Nr;
var si = ve(cr(), 1);
var Al = (0, si.default)(1)(
  (t2) => Object.values(t2).reduce(
    (e2, r2) => (e2[r2.importPath] = e2[r2.importPath] || r2, e2),
    {}
  )
);
var qr = class qr2 {
  constructor({ entries: e2 } = { v: 5, entries: {} }) {
    this.entries = e2;
  }
  entryFromSpecifier(e2) {
    let r2 = Object.values(this.entries);
    if (e2 === "*")
      return r2[0];
    if (typeof e2 == "string")
      return this.entries[e2] ? this.entries[e2] : r2.find((s) => s.id.startsWith(e2));
    let { name: o3, title: i2 } = e2;
    return r2.find((s) => s.name === o3 && s.title === i2);
  }
  storyIdToEntry(e2) {
    let r2 = this.entries[e2];
    if (!r2)
      throw new L2({ storyId: e2 });
    return r2;
  }
  importPathToEntry(e2) {
    return Al(this.entries)[e2];
  }
};
n2(qr, "StoryIndexStore");
var Et = qr;
var vl = n2((t2) => typeof t2 == "string" ? { name: t2 } : t2, "normalizeType");
var Cl = n2((t2) => typeof t2 == "string" ? { type: t2 } : t2, "normalizeControl");
var Pl = n2((t2, e2) => {
  let { type: r2, control: o3, ...i2 } = t2, s = {
    name: e2,
    ...i2
  };
  return r2 && (s.type = vl(r2)), o3 ? s.control = Cl(o3) : o3 === false && (s.control = { disable: true }), s;
}, "normalizeInputType");
var Se = n2((t2) => re2(t2, Pl), "normalizeInputTypes");
var D4 = n2((t2) => Array.isArray(t2) ? t2 : t2 ? [t2] : [], "normalizeArrays");
var Dl = _3`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
function ke(t2, e2, r2) {
  let o3 = e2, i2 = typeof e2 == "function" ? e2 : null, { story: s } = o3;
  s && (i.debug("deprecated story", s), h(Dl));
  let a = H(t2), l2 = typeof o3 != "function" && o3.name || o3.storyName || s?.name || a, c = [
    ...D4(o3.decorators),
    ...D4(s?.decorators)
  ], d2 = { ...s?.parameters, ...o3.parameters }, p2 = { ...s?.args, ...o3.args }, u = { ...s?.argTypes, ...o3.argTypes }, f3 = [...D4(o3.loaders), ...D4(
    s?.loaders
  )], h2 = [
    ...D4(o3.beforeEach),
    ...D4(s?.beforeEach)
  ], g3 = [
    ...D4(o3.afterEach),
    ...D4(s?.afterEach)
  ], { render: T3, play: x4, tags: v3 = [], globals: E = {} } = o3, y = d2.__id || W(r2.id, a);
  return {
    moduleExport: e2,
    id: y,
    name: l2,
    tags: v3,
    decorators: c,
    parameters: d2,
    args: p2,
    argTypes: Se(u),
    loaders: f3,
    beforeEach: h2,
    afterEach: g3,
    globals: E,
    ...T3 && { render: T3 },
    ...i2 && { userStoryFn: i2 },
    ...x4 && { play: x4 }
  };
}
n2(ke, "normalizeStory");
function Ze(t2, e2 = t2.title, r2) {
  let { id: o3, argTypes: i2 } = t2;
  return {
    id: I(o3 || e2),
    ...t2,
    title: e2,
    ...i2 && { argTypes: Se(i2) },
    parameters: {
      fileName: r2,
      ...t2.parameters
    }
  };
}
n2(Ze, "normalizeComponentAnnotations");
var _l = n2((t2) => {
  let { globals: e2, globalTypes: r2 } = t2;
  (e2 || r2) && i.error(
    "Global args/argTypes can only be set globally",
    JSON.stringify({
      globals: e2,
      globalTypes: r2
    })
  );
}, "checkGlobals");
var jl = n2((t2) => {
  let { options: e2 } = t2;
  e2?.storySort && i.error("The storySort option parameter can only be set globally");
}, "checkStorySort");
var At = n2((t2) => {
  t2 && (_l(t2), jl(t2));
}, "checkDisallowedParameters");
function ci(t2, e2, r2) {
  let { default: o3, __namedExportsOrder: i2, ...s } = t2, a = Object.values(s)[0];
  if (J(a)) {
    let d2 = Ze(a.meta.input, r2, e2);
    At(d2.parameters);
    let p2 = { meta: d2, stories: {}, moduleExports: t2 };
    return Object.keys(s).forEach((u) => {
      if (K(u, d2)) {
        let f3 = ke(u, s[u].input, d2);
        At(f3.parameters), p2.stories[f3.id] = f3;
      }
    }), p2.projectAnnotations = a.meta.preview.composed, p2;
  }
  let l2 = Ze(
    o3,
    r2,
    e2
  );
  At(l2.parameters);
  let c = { meta: l2, stories: {}, moduleExports: t2 };
  return Object.keys(s).forEach((d2) => {
    if (K(d2, l2)) {
      let p2 = ke(d2, s[d2], l2);
      At(p2.parameters), c.stories[p2.id] = p2;
    }
  }), c;
}
n2(ci, "processCSFFile");
function pi(t2) {
  return t2 != null && Nl(t2).includes("mount");
}
n2(pi, "mountDestructured");
function Nl(t2) {
  let e2 = t2.toString().match(/[^(]*\(([^)]*)/);
  if (!e2)
    return [];
  let r2 = di(e2[1]);
  if (!r2.length)
    return [];
  let o3 = r2[0];
  return o3.startsWith("{") && o3.endsWith("}") ? di(o3.slice(1, -1).replace(/\s/g, "")).map((s) => s.replace(/:.*|=.*/g, "")) : [];
}
n2(Nl, "getUsedProps");
function di(t2) {
  let e2 = [], r2 = [], o3 = 0;
  for (let s = 0; s < t2.length; s++)
    if (t2[s] === "{" || t2[s] === "[")
      r2.push(t2[s] === "{" ? "}" : "]");
    else if (t2[s] === r2[r2.length - 1])
      r2.pop();
    else if (!r2.length && t2[s] === ",") {
      let a = t2.substring(o3, s).trim();
      a && e2.push(a), o3 = s + 1;
    }
  let i2 = t2.substring(o3).trim();
  return i2 && e2.push(i2), e2;
}
n2(di, "splitByComma");
function ui(t2, e2, r2) {
  let o3 = r2(t2);
  return (i2) => e2(o3, i2);
}
n2(ui, "decorateStory");
function fi({
  componentId: t2,
  title: e2,
  kind: r2,
  id: o3,
  name: i2,
  story: s,
  parameters: a,
  initialArgs: l2,
  argTypes: c,
  ...d2
} = {}) {
  return d2;
}
n2(fi, "sanitizeStoryContextUpdate");
function Hr(t2, e2) {
  let r2 = {}, o3 = n2((s) => (a) => {
    if (!r2.value)
      throw new Error("Decorated function called without init");
    return r2.value = {
      ...r2.value,
      ...fi(a)
    }, s(r2.value);
  }, "bindWithContext"), i2 = e2.reduce(
    (s, a) => ui(s, a, o3),
    t2
  );
  return (s) => (r2.value = s, i2(s));
}
n2(Hr, "defaultDecorateStory");
var V4 = n2((...t2) => {
  let e2 = {}, r2 = t2.filter(Boolean), o3 = r2.reduce((i2, s) => (Object.entries(s).forEach(([a, l2]) => {
    let c = i2[a];
    Array.isArray(l2) || typeof c > "u" ? i2[a] = l2 : $3(l2) && $3(c) ? e2[a] = true : typeof l2 < "u" && (i2[a] = l2);
  }), i2), {});
  return Object.keys(e2).forEach((i2) => {
    let s = r2.filter(Boolean).map((a) => a[i2]).filter((a) => typeof a < "u");
    s.every((a) => $3(a)) ? o3[i2] = V4(...s) : o3[i2] = s[s.length - 1];
  }), o3;
}, "combineParameters");
function Qe(t2, e2, r2) {
  let { moduleExport: o3, id: i2, name: s } = t2 || {}, a = mi(
    t2,
    e2,
    r2
  ), l2 = n2(async (P4) => {
    let m2 = {};
    for (let b4 of [
      D4(r2.loaders),
      D4(e2.loaders),
      D4(t2.loaders)
    ]) {
      if (P4.abortSignal.aborted)
        return m2;
      let S3 = await Promise.all(b4.map((C3) => C3(P4)));
      Object.assign(m2, ...S3);
    }
    return m2;
  }, "applyLoaders"), c = n2(async (P4) => {
    let m2 = new Array();
    for (let b4 of [
      ...D4(r2.beforeEach),
      ...D4(e2.beforeEach),
      ...D4(t2.beforeEach)
    ]) {
      if (P4.abortSignal.aborted)
        return m2;
      let S3 = await b4(P4);
      S3 && m2.push(S3);
    }
    return m2;
  }, "applyBeforeEach"), d2 = n2(async (P4) => {
    let m2 = [
      ...D4(r2.afterEach),
      ...D4(e2.afterEach),
      ...D4(t2.afterEach)
    ].reverse();
    for (let b4 of m2) {
      if (P4.abortSignal.aborted)
        return;
      await b4(P4);
    }
  }, "applyAfterEach"), p2 = n2((P4) => P4.originalStoryFn(P4.args, P4), "undecoratedStoryFn"), { applyDecorators: u = Hr, runStep: f3 } = r2, h2 = [
    ...D4(t2?.decorators),
    ...D4(e2?.decorators),
    ...D4(r2?.decorators)
  ], g3 = t2?.userStoryFn || t2?.render || e2.render || r2.render, T3 = Qt(u)(p2, h2), x4 = n2((P4) => T3(P4), "unboundStoryFn"), v3 = t2?.play ?? e2?.play, E = pi(v3);
  if (!g3 && !E)
    throw new B2({ id: i2 });
  let y = n2((P4) => async () => (await P4.renderToCanvas(), P4.canvas), "defaultMount"), w4 = t2.mount ?? e2.mount ?? r2.mount ?? y, A3 = r2.testingLibraryRender;
  return {
    storyGlobals: {},
    ...a,
    moduleExport: o3,
    id: i2,
    name: s,
    story: s,
    originalStoryFn: g3,
    undecoratedStoryFn: p2,
    unboundStoryFn: x4,
    applyLoaders: l2,
    applyBeforeEach: c,
    applyAfterEach: d2,
    playFunction: v3,
    runStep: f3,
    mount: w4,
    testingLibraryRender: A3,
    renderToCanvas: r2.renderToCanvas,
    usesMount: E
  };
}
n2(Qe, "prepareStory");
function $r(t2, e2, r2) {
  return {
    ...mi(void 0, t2, e2),
    moduleExport: r2
  };
}
n2($r, "prepareMeta");
function mi(t2, e2, r2) {
  let o3 = ["dev", "test"], i2 = scope.DOCS_OPTIONS?.autodocs === true ? ["autodocs"] : [], s = X(
    ...o3,
    ...i2,
    ...r2.tags ?? [],
    ...e2.tags ?? [],
    ...t2?.tags ?? []
  ), a = V4(
    r2.parameters,
    e2.parameters,
    t2?.parameters
  ), { argTypesEnhancers: l2 = [], argsEnhancers: c = [] } = r2, d2 = V4(
    r2.argTypes,
    e2.argTypes,
    t2?.argTypes
  );
  if (t2) {
    let v3 = t2?.userStoryFn || t2?.render || e2.render || r2.render;
    a.__isArgsStory = v3 && v3.length > 0;
  }
  let p2 = {
    ...r2.args,
    ...e2.args,
    ...t2?.args
  }, u = {
    ...e2.globals,
    ...t2?.globals
  }, f3 = {
    componentId: e2.id,
    title: e2.title,
    kind: e2.title,
    // Back compat
    id: t2?.id || e2.id,
    // if there's no story name, we create a fake one since enhancers expect a name
    name: t2?.name || "__meta",
    story: t2?.name || "__meta",
    // Back compat
    component: e2.component,
    subcomponents: e2.subcomponents,
    tags: s,
    parameters: a,
    initialArgs: p2,
    argTypes: d2,
    storyGlobals: u
  };
  f3.argTypes = l2.reduce(
    (v3, E) => E({ ...f3, argTypes: v3 }),
    f3.argTypes
  );
  let h2 = { ...p2 };
  f3.initialArgs = [...c].reduce(
    (v3, E) => ({
      ...v3,
      ...E({
        ...f3,
        initialArgs: v3
      })
    }),
    h2
  );
  let { name: g3, story: T3, ...x4 } = f3;
  return x4;
}
n2(mi, "preparePartialAnnotations");
function vt(t2) {
  let { args: e2 } = t2, r2 = {
    ...t2,
    allArgs: void 0,
    argsByTarget: void 0
  };
  if (scope.FEATURES?.argTypeTargetsV7) {
    let s = ii(t2);
    r2 = {
      ...t2,
      allArgs: t2.args,
      argsByTarget: s,
      args: s[_r] || {}
    };
  }
  let o3 = Object.entries(r2.args).reduce((s, [a, l2]) => {
    if (!r2.argTypes[a]?.mapping)
      return s[a] = l2, s;
    let c = n2((d2) => {
      let p2 = r2.argTypes[a].mapping;
      return p2 && d2 in p2 ? p2[d2] : d2;
    }, "mappingFn");
    return s[a] = Array.isArray(l2) ? l2.map(c) : c(l2), s;
  }, {}), i2 = Object.entries(o3).reduce((s, [a, l2]) => {
    let c = r2.argTypes[a] || {};
    return z(c, o3, r2.globals) && (s[a] = l2), s;
  }, {});
  return { ...r2, unmappedArgs: e2, args: i2 };
}
n2(vt, "prepareContext");
var Br = n2((t2, e2, r2) => {
  let o3 = typeof t2;
  switch (o3) {
    case "boolean":
    case "string":
    case "number":
    case "function":
    case "symbol":
      return { name: o3 };
    default:
      break;
  }
  return t2 ? r2.has(t2) ? (i.warn(_3`
        We've detected a cycle in arg '${e2}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `), { name: "other", value: "cyclic object" }) : (r2.add(t2), Array.isArray(t2) ? { name: "array", value: t2.length > 0 ? Br(t2[0], e2, new Set(
    r2
  )) : { name: "other", value: "unknown" } } : { name: "object", value: re2(t2, (s) => Br(s, e2, new Set(r2))) }) : { name: "object", value: {} };
}, "inferType");
var Gr = n2((t2) => {
  let { id: e2, argTypes: r2 = {}, initialArgs: o3 = {} } = t2, i2 = re2(o3, (a, l2) => ({
    name: l2,
    type: Br(a, `${e2}.${l2}`, /* @__PURE__ */ new Set())
  })), s = re2(r2, (a, l2) => ({
    name: l2
  }));
  return V4(i2, s, r2);
}, "inferArgTypes");
Gr.secondPass = true;
var yi = n2((t2, e2) => Array.isArray(e2) ? e2.includes(t2) : t2.match(e2), "matches");
var Ct = n2((t2, e2, r2) => !e2 && !r2 ? t2 : t2 && sr(t2, (o3, i2) => {
  let s = o3.name || i2.toString();
  return !!(!e2 || yi(s, e2)) && (!r2 || !yi(s, r2));
}), "filterArgTypes");
var Vl = n2((t2, e2, r2) => {
  let { type: o3, options: i2 } = t2;
  if (o3) {
    if (r2.color && r2.color.test(e2)) {
      let s = o3.name;
      if (s === "string")
        return { control: { type: "color" } };
      s !== "enum" && i.warn(
        `Addon controls: Control of type color only supports string, received "${s}" instead`
      );
    }
    if (r2.date && r2.date.test(e2))
      return { control: { type: "date" } };
    switch (o3.name) {
      case "array":
        return { control: { type: "object" } };
      case "boolean":
        return { control: { type: "boolean" } };
      case "string":
        return { control: { type: "text" } };
      case "number":
        return { control: { type: "number" } };
      case "enum": {
        let { value: s } = o3;
        return { control: { type: s?.length <= 5 ? "radio" : "select" }, options: s };
      }
      case "function":
      case "symbol":
        return null;
      default:
        return { control: { type: i2 ? "select" : "object" } };
    }
  }
}, "inferControl");
var et = n2((t2) => {
  let {
    argTypes: e2,
    parameters: { __isArgsStory: r2, controls: { include: o3 = null, exclude: i2 = null, matchers: s = {} } = {} }
  } = t2;
  if (!r2)
    return e2;
  let a = Ct(e2, o3, i2), l2 = re2(a, (c, d2) => c?.type && Vl(c, d2.toString(), s));
  return V4(l2, a);
}, "inferControls");
et.secondPass = true;
function De({
  argTypes: t2,
  globalTypes: e2,
  argTypesEnhancers: r2,
  decorators: o3,
  loaders: i2,
  beforeEach: s,
  afterEach: a,
  initialGlobals: l2,
  ...c
}) {
  return {
    ...t2 && { argTypes: Se(t2) },
    ...e2 && { globalTypes: Se(e2) },
    decorators: D4(o3),
    loaders: D4(i2),
    beforeEach: D4(s),
    afterEach: D4(a),
    argTypesEnhancers: [
      ...r2 || [],
      Gr,
      // There's an architectural decision to be made regarding embedded addons in core:
      //
      // Option 1: Keep embedded addons but ensure consistency by moving addon-specific code
      // (like inferControls) to live alongside the addon code itself. This maintains the
      // concept of core addons while improving code organization.
      //
      // Option 2: Fully integrate these addons into core, potentially moving UI components
      // into the manager and treating them as core features rather than addons. This is a
      // bigger architectural change requiring careful consideration.
      //
      // For now, we're keeping inferControls here as we need time to properly evaluate
      // these options and their implications. Some features (like Angular's cleanArgsDecorator)
      // currently rely on this behavior.
      //
      // TODO: Make an architectural decision on the handling of core addons
      et
    ],
    initialGlobals: l2,
    ...c
  };
}
n2(De, "normalizeProjectAnnotations");
var hi = n2((t2) => async () => {
  let e2 = [];
  for (let r2 of t2) {
    let o3 = await r2();
    o3 && e2.unshift(o3);
  }
  return async () => {
    for (let r2 of e2)
      await r2();
  };
}, "composeBeforeAllHooks");
function zr(t2) {
  return async (e2, r2, o3) => {
    await t2.reduceRight(
      (s, a) => async () => a(e2, s, o3),
      async () => r2(o3)
    )();
  };
}
n2(zr, "composeStepRunners");
function rt(t2, e2) {
  return t2.map((r2) => r2.default?.[e2] ?? r2[e2]).filter(Boolean);
}
n2(rt, "getField");
function ae2(t2, e2, r2 = {}) {
  return rt(t2, e2).reduce((o3, i2) => {
    let s = D4(i2);
    return r2.reverseFileOrder ? [...s, ...o3] : [...o3, ...s];
  }, []);
}
n2(ae2, "getArrayField");
function Pt(t2, e2) {
  return Object.assign({}, ...rt(t2, e2));
}
n2(Pt, "getObjectField");
function tt(t2, e2) {
  return rt(t2, e2).pop();
}
n2(tt, "getSingletonField");
function le(t2) {
  let e2 = ae2(t2, "argTypesEnhancers"), r2 = rt(t2, "runStep"), o3 = ae2(t2, "beforeAll");
  return {
    parameters: V4(...rt(t2, "parameters")),
    decorators: ae2(t2, "decorators", {
      reverseFileOrder: !(scope.FEATURES?.legacyDecoratorFileOrder ?? false)
    }),
    args: Pt(t2, "args"),
    argsEnhancers: ae2(t2, "argsEnhancers"),
    argTypes: Pt(t2, "argTypes"),
    argTypesEnhancers: [
      ...e2.filter((i2) => !i2.secondPass),
      ...e2.filter((i2) => i2.secondPass)
    ],
    initialGlobals: Pt(t2, "initialGlobals"),
    globalTypes: Pt(t2, "globalTypes"),
    loaders: ae2(t2, "loaders"),
    beforeAll: hi(o3),
    beforeEach: ae2(t2, "beforeEach"),
    afterEach: ae2(t2, "afterEach"),
    render: tt(t2, "render"),
    renderToCanvas: tt(t2, "renderToCanvas"),
    applyDecorators: tt(t2, "applyDecorators"),
    runStep: zr(r2),
    tags: ae2(t2, "tags"),
    mount: tt(t2, "mount"),
    testingLibraryRender: tt(t2, "testingLibraryRender")
  };
}
n2(le, "composeConfigs");
function Ft() {
  try {
    return (
      // @ts-expect-error this property exists in certain environments
      !!globalThis.__vitest_browser__ || // @ts-expect-error this property exists in certain environments
      !!globalThis.__playwright__binding__
    );
  } catch {
    return false;
  }
}
n2(Ft, "isTestEnvironment");
function Me(t2 = true) {
  if (!("document" in globalThis && "createElement" in globalThis.document))
    return () => {
    };
  let e2 = document.createElement("style");
  e2.textContent = `*, *:before, *:after {
    animation: none !important;
  }`, document.head.appendChild(e2);
  let r2 = document.createElement("style");
  return r2.textContent = `*, *:before, *:after {
    animation-delay: 0s !important;
    animation-direction: ${t2 ? "reverse" : "normal"} !important;
    animation-play-state: paused !important;
    transition: none !important;
  }`, document.head.appendChild(r2), document.body.clientHeight, document.head.removeChild(e2), () => {
    r2.parentNode?.removeChild(r2);
  };
}
n2(Me, "pauseAnimations");
async function Le(t2) {
  if (!("document" in globalThis && "getAnimations" in globalThis.document && "querySelectorAll" in globalThis.document))
    return;
  let e2 = false;
  await Promise.race([
    // After 50ms, retrieve any running animations and wait for them to finish
    // If new animations are created while waiting, we'll wait for them too
    new Promise((r2) => {
      setTimeout(() => {
        let o3 = [globalThis.document, ...gi(globalThis.document)], i2 = n2(async () => {
          if (e2 || t2?.aborted)
            return;
          let s = o3.flatMap((a) => a?.getAnimations?.() || []).filter((a) => a.playState === "running" && !Yl(a));
          s.length > 0 && (await Promise.all(s.map((a) => a.finished)), await i2());
        }, "checkAnimationsFinished");
        i2().then(r2);
      }, 100);
    }),
    // If animations don't finish within the timeout, continue without waiting
    new Promise(
      (r2) => setTimeout(() => {
        e2 = true, r2(void 0);
      }, 5e3)
    )
  ]);
}
n2(Le, "waitForAnimations");
function gi(t2) {
  return [t2, ...t2.querySelectorAll("*")].reduce(
    (e2, r2) => ("shadowRoot" in r2 && r2.shadowRoot && e2.push(r2.shadowRoot, ...gi(r2.shadowRoot)), e2),
    []
  );
}
n2(gi, "getShadowRoots");
function Yl(t2) {
  if (t2 instanceof CSSAnimation && t2.effect instanceof KeyframeEffect && t2.effect.target) {
    let e2 = getComputedStyle(t2.effect.target, t2.effect.pseudoElement), r2 = e2.animationName?.split(", ").indexOf(t2.animationName);
    return e2.animationIterationCount.split(", ")[r2] === "infinite";
  }
  return false;
}
n2(Yl, "isInfiniteAnimation");
var Ur = class Ur2 {
  constructor() {
    this.reports = [];
  }
  async addReport(e2) {
    this.reports.push(e2);
  }
};
n2(Ur, "ReporterAPI");
var xe = Ur;
function Vr(t2, e2, r2) {
  return J(t2) ? {
    story: t2.input,
    meta: t2.meta.input,
    preview: t2.meta.preview.composed
  } : { story: t2, meta: e2, preview: r2 };
}
n2(Vr, "getCsfFactoryAnnotations");
function Zl(t2) {
  globalThis.defaultProjectAnnotations = t2;
}
n2(Zl, "setDefaultProjectAnnotations");
var Ql = "ComposedStory";
var ec = "Unnamed Story";
function tc(t2) {
  return t2 ? le([t2]) : {};
}
n2(tc, "extractAnnotation");
function rc(t2) {
  let e2 = Array.isArray(t2) ? t2 : [t2];
  return globalThis.globalProjectAnnotations = le([
    ...Xe(),
    globalThis.defaultProjectAnnotations ?? {},
    le(e2.map(tc))
  ]), globalThis.globalProjectAnnotations ?? {};
}
n2(rc, "setProjectAnnotations");
var ce = [];
function bi(t2, e2, r2, o3, i2) {
  if (t2 === void 0)
    throw new Error("Expected a story but received undefined.");
  e2.title = e2.title ?? Ql;
  let s = Ze(e2), a = i2 || t2.storyName || t2.story?.name || t2.name || ec, l2 = ke(
    a,
    t2,
    s
  ), c = De(
    le([
      o3 ?? globalThis.globalProjectAnnotations ?? {},
      r2 ?? {}
    ])
  ), d2 = Qe(
    l2,
    s,
    c
  ), u = {
    ...wt(c.globalTypes),
    ...c.initialGlobals,
    ...d2.storyGlobals
  }, f3 = new xe(), h2 = n2(() => {
    let y = vt({
      hooks: new he(),
      globals: u,
      args: { ...d2.initialArgs },
      viewMode: "story",
      reporting: f3,
      loaded: {},
      abortSignal: new AbortController().signal,
      step: n2((w4, A3) => d2.runStep(w4, A3, y), "step"),
      canvasElement: null,
      canvas: {},
      userEvent: {},
      globalTypes: c.globalTypes,
      ...d2,
      context: null,
      mount: null
    });
    return y.parameters.__isPortableStory = true, y.context = y, d2.renderToCanvas && (y.renderToCanvas = async () => {
      let w4 = await d2.renderToCanvas?.(
        {
          componentId: d2.componentId,
          title: d2.title,
          id: d2.id,
          name: d2.name,
          tags: d2.tags,
          showMain: n2(() => {
          }, "showMain"),
          showError: n2((A3) => {
            throw new Error(`${A3.title}
${A3.description}`);
          }, "showError"),
          showException: n2((A3) => {
            throw A3;
          }, "showException"),
          forceRemount: true,
          storyContext: y,
          storyFn: n2(() => d2.unboundStoryFn(y), "storyFn"),
          unboundStoryFn: d2.unboundStoryFn
        },
        y.canvasElement
      );
      w4 && ce.push(w4);
    }), y.mount = d2.mount(y), y;
  }, "initializeContext"), g3, T3 = n2(async (y) => {
    let w4 = h2();
    return w4.canvasElement ??= globalThis?.document?.body, g3 && (w4.loaded = g3.loaded), Object.assign(w4, y), d2.playFunction(w4);
  }, "play"), x4 = n2((y) => {
    let w4 = h2();
    return Object.assign(w4, y), sc(d2, w4);
  }, "run"), v3 = d2.playFunction ? T3 : void 0;
  return Object.assign(
    n2(function(w4) {
      let A3 = h2();
      return g3 && (A3.loaded = g3.loaded), A3.args = {
        ...A3.initialArgs,
        ...w4
      }, d2.unboundStoryFn(A3);
    }, "storyFn"),
    {
      id: d2.id,
      storyName: a,
      load: n2(async () => {
        for (let w4 of [...ce].reverse())
          await w4();
        ce.length = 0;
        let y = h2();
        y.loaded = await d2.applyLoaders(y), ce.push(...(await d2.applyBeforeEach(y)).filter(Boolean)), g3 = y;
      }, "load"),
      globals: u,
      args: d2.initialArgs,
      parameters: d2.parameters,
      argTypes: d2.argTypes,
      play: v3,
      run: x4,
      reporting: f3,
      tags: d2.tags
    }
  );
}
n2(bi, "composeStory");
var oc = n2((t2, e2, r2, o3) => bi(t2, e2, r2, {}, o3), "defaultComposeStory");
function nc(t2, e2, r2 = oc) {
  let { default: o3, __esModule: i2, __namedExportsOrder: s, ...a } = t2, l2 = o3;
  return Object.entries(a).reduce(
    (d2, [p2, u]) => {
      let { story: f3, meta: h2 } = Vr(u);
      return !l2 && h2 && (l2 = h2), K(p2, l2) ? Object.assign(d2, {
        [p2]: r2(f3, l2, e2, p2)
      }) : d2;
    },
    {}
  );
}
n2(nc, "composeStories");
function ic(t2) {
  return t2.extend({
    mount: n2(async ({ mount: e2, page: r2 }, o3) => {
      await o3(async (i2, ...s) => {
        if (!("__pw_type" in i2) || "__pw_type" in i2 && i2.__pw_type !== "jsx")
          throw new Error(_3`
              Portable stories in Playwright CT only work when referencing JSX elements.
              Please use JSX format for your components such as:

              instead of:
              await mount(MyComponent, { props: { foo: 'bar' } })

              do:
              await mount(<MyComponent foo="bar"/>)

              More info: https://storybook.js.org/docs/api/portable-stories-playwright
            `);
        let { props: a, ...l2 } = i2;
        await r2.evaluate(async (d2) => {
          let p2 = await globalThis.__pwUnwrapObject?.(d2);
          return ("__pw_type" in p2 ? p2.type : p2)?.load?.();
        }, l2);
        let c = await e2(i2, ...s);
        return await r2.evaluate(async (d2) => {
          let p2 = await globalThis.__pwUnwrapObject?.(d2), u = "__pw_type" in p2 ? p2.type : p2, f3 = document.querySelector("#root");
          return u?.play?.({ canvasElement: f3 });
        }, l2), c;
      });
    }, "mount")
  });
}
n2(ic, "createPlaywrightTest");
async function sc(t2, e2) {
  for (let s of [...ce].reverse())
    await s();
  if (ce.length = 0, !e2.canvasElement) {
    let s = document.createElement("div");
    globalThis?.document?.body?.appendChild(s), e2.canvasElement = s, ce.push(() => {
      globalThis?.document?.body?.contains(s) && globalThis?.document?.body?.removeChild(s);
    });
  }
  if (e2.loaded = await t2.applyLoaders(e2), e2.abortSignal.aborted)
    return;
  ce.push(...(await t2.applyBeforeEach(e2)).filter(Boolean));
  let r2 = t2.playFunction, o3 = t2.usesMount;
  if (o3 || await e2.mount(), e2.abortSignal.aborted)
    return;
  r2 && (o3 || (e2.mount = async () => {
    throw new z4({ playFunction: r2.toString() });
  }), await r2(e2));
  let i2;
  Ft() ? i2 = Me() : await Le(e2.abortSignal), await t2.applyAfterEach(e2), await i2?.();
}
n2(sc, "runStory");
var Si = 1e3;
var cc = 1e4;
var Wr = class Wr2 {
  constructor(e2, r2, o3) {
    this.importFn = r2;
    this.storyIndex = new Et(e2), this.projectAnnotations = De(
      le([...Xe(), o3])
    );
    let { initialGlobals: i2, globalTypes: s } = this.projectAnnotations;
    this.args = new Tt(), this.userGlobals = new Rt({ globals: i2, globalTypes: s }), this.hooks = {}, this.cleanupCallbacks = {}, this.processCSFFileWithCache = (0, It.default)(Si)(ci), this.prepareMetaWithCache = (0, It.default)(Si)($r), this.prepareStoryWithCache = (0, It.default)(cc)(Qe);
  }
  setProjectAnnotations(e2) {
    this.projectAnnotations = De(e2);
    let { initialGlobals: r2, globalTypes: o3 } = e2;
    this.userGlobals.set({ globals: r2, globalTypes: o3 });
  }
  // This means that one of the CSF files has changed.
  // If the `importFn` has changed, we will invalidate both caches.
  // If the `storyIndex` data has changed, we may or may not invalidate the caches, depending
  // on whether we've loaded the relevant files yet.
  async onStoriesChanged({
    importFn: e2,
    storyIndex: r2
  }) {
    e2 && (this.importFn = e2), r2 && (this.storyIndex.entries = r2.entries), this.cachedCSFFiles && await this.cacheAllCSFFiles();
  }
  // Get an entry from the index, waiting on initialization if necessary
  async storyIdToEntry(e2) {
    return this.storyIndex.storyIdToEntry(e2);
  }
  // To load a single CSF file to service a story we need to look up the importPath in the index
  async loadCSFFileByStoryId(e2) {
    let { importPath: r2, title: o3 } = this.storyIndex.storyIdToEntry(e2), i2 = await this.importFn(r2);
    return this.processCSFFileWithCache(i2, r2, o3);
  }
  async loadAllCSFFiles() {
    let e2 = {};
    return Object.entries(this.storyIndex.entries).forEach(([o3, { importPath: i2 }]) => {
      e2[i2] = o3;
    }), (await Promise.all(
      Object.entries(e2).map(async ([o3, i2]) => ({
        importPath: o3,
        csfFile: await this.loadCSFFileByStoryId(i2)
      }))
    )).reduce(
      (o3, { importPath: i2, csfFile: s }) => (o3[i2] = s, o3),
      {}
    );
  }
  async cacheAllCSFFiles() {
    this.cachedCSFFiles = await this.loadAllCSFFiles();
  }
  preparedMetaFromCSFFile({ csfFile: e2 }) {
    let r2 = e2.meta;
    return this.prepareMetaWithCache(
      r2,
      this.projectAnnotations,
      e2.moduleExports.default
    );
  }
  // Load the CSF file for a story and prepare the story from it and the project annotations.
  async loadStory({ storyId: e2 }) {
    let r2 = await this.loadCSFFileByStoryId(e2);
    return this.storyFromCSFFile({ storyId: e2, csfFile: r2 });
  }
  // This function is synchronous for convenience -- often times if you have a CSF file already
  // it is easier not to have to await `loadStory`.
  storyFromCSFFile({
    storyId: e2,
    csfFile: r2
  }) {
    let o3 = r2.stories[e2];
    if (!o3)
      throw new J3({ storyId: e2 });
    let i2 = r2.meta, s = this.prepareStoryWithCache(
      o3,
      i2,
      r2.projectAnnotations ?? this.projectAnnotations
    );
    return this.args.setInitial(s), this.hooks[s.id] = this.hooks[s.id] || new he(), s;
  }
  // If we have a CSF file we can get all the stories from it synchronously
  componentStoriesFromCSFFile({
    csfFile: e2
  }) {
    return Object.keys(this.storyIndex.entries).filter((r2) => !!e2.stories[r2]).map((r2) => this.storyFromCSFFile({ storyId: r2, csfFile: e2 }));
  }
  async loadEntry(e2) {
    let r2 = await this.storyIdToEntry(e2), o3 = r2.type === "docs" ? r2.storiesImports : [], [i2, ...s] = await Promise.all([
      this.importFn(r2.importPath),
      ...o3.map((a) => {
        let l2 = this.storyIndex.importPathToEntry(a);
        return this.loadCSFFileByStoryId(l2.id);
      })
    ]);
    return { entryExports: i2, csfFiles: s };
  }
  // A prepared story does not include args, globals or hooks. These are stored in the story store
  // and updated separtely to the (immutable) story.
  getStoryContext(e2, { forceInitialArgs: r2 = false } = {}) {
    let o3 = this.userGlobals.get(), { initialGlobals: i2 } = this.userGlobals, s = new xe();
    return vt({
      ...e2,
      args: r2 ? e2.initialArgs : this.args.get(e2.id),
      initialGlobals: i2,
      globalTypes: this.projectAnnotations.globalTypes,
      userGlobals: o3,
      reporting: s,
      globals: {
        ...o3,
        ...e2.storyGlobals
      },
      hooks: this.hooks[e2.id]
    });
  }
  addCleanupCallbacks(e2, ...r2) {
    this.cleanupCallbacks[e2.id] = (this.cleanupCallbacks[e2.id] || []).concat(r2);
  }
  async cleanupStory(e2) {
    this.hooks[e2.id].clean();
    let r2 = this.cleanupCallbacks[e2.id];
    if (r2)
      for (let o3 of [...r2].reverse())
        await o3();
    delete this.cleanupCallbacks[e2.id];
  }
  extract(e2 = { includeDocsOnly: false }) {
    let { cachedCSFFiles: r2 } = this;
    if (!r2)
      throw new G2();
    return Object.entries(this.storyIndex.entries).reduce(
      (o3, [i2, { type: s, importPath: a }]) => {
        if (s === "docs")
          return o3;
        let l2 = r2[a], c = this.storyFromCSFFile({ storyId: i2, csfFile: l2 });
        return !e2.includeDocsOnly && c.parameters.docsOnly || (o3[i2] = Object.entries(c).reduce(
          (d2, [p2, u]) => p2 === "moduleExport" || typeof u == "function" ? d2 : Array.isArray(u) ? Object.assign(d2, { [p2]: u.slice().sort() }) : Object.assign(d2, { [p2]: u }),
          {
            //
            args: c.initialArgs,
            globals: {
              ...this.userGlobals.initialGlobals,
              ...this.userGlobals.globals,
              ...c.storyGlobals
            }
          }
        )), o3;
      },
      {}
    );
  }
};
n2(Wr, "StoryStore");
var _e = Wr;
function Yr(t2) {
  return t2.startsWith("\\\\?\\") ? t2 : t2.replace(/\\/g, "/");
}
n2(Yr, "slash");
var pc = n2((t2) => {
  if (t2.length === 0)
    return t2;
  let e2 = t2[t2.length - 1], r2 = e2?.replace(/(?:[.](?:story|stories))?([.][^.]+)$/i, "");
  if (t2.length === 1)
    return [r2];
  let o3 = t2[t2.length - 2];
  return r2 && o3 && r2.toLowerCase() === o3.toLowerCase() ? [...t2.slice(0, -2), r2] : r2 && (/^(story|stories)([.][^.]+)$/i.test(e2) || /^index$/i.test(r2)) ? t2.slice(0, -1) : [...t2.slice(0, -1), r2];
}, "sanitize");
function xi(t2) {
  return t2.flatMap((e2) => e2.split("/")).filter(Boolean).join("/");
}
n2(xi, "pathJoin");
var Ti = n2((t2, e2, r2) => {
  let { directory: o3, importPathMatcher: i2, titlePrefix: s = "" } = e2 || {};
  typeof t2 == "number" && o.warn(_3`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
  let a = Yr(String(t2));
  if (i2.exec(a)) {
    if (!r2) {
      let l2 = a.replace(o3, ""), c = xi([s, l2]).split("/");
      return c = pc(c), c.join("/");
    }
    return s ? xi([s, r2]) : r2;
  }
}, "userOrAutoTitleFromSpecifier");
var uc = n2((t2, e2, r2) => {
  for (let o3 = 0; o3 < e2.length; o3 += 1) {
    let i2 = Ti(t2, e2[o3], r2);
    if (i2)
      return i2;
  }
  return r2 || void 0;
}, "userOrAutoTitle");
var wi = /\s*\/\s*/;
var Ri = n2((t2 = {}) => (e2, r2) => {
  if (e2.title === r2.title && !t2.includeNames)
    return 0;
  let o3 = t2.method || "configure", i2 = t2.order || [], s = e2.title.trim().split(wi), a = r2.title.trim().split(wi);
  t2.includeNames && (s.push(e2.name), a.push(r2.name));
  let l2 = 0;
  for (; s[l2] || a[l2]; ) {
    if (!s[l2])
      return -1;
    if (!a[l2])
      return 1;
    let c = s[l2], d2 = a[l2];
    if (c !== d2) {
      let u = i2.indexOf(c), f3 = i2.indexOf(d2), h2 = i2.indexOf("*");
      return u !== -1 || f3 !== -1 ? (u === -1 && (h2 !== -1 ? u = h2 : u = i2.length), f3 === -1 && (h2 !== -1 ? f3 = h2 : f3 = i2.length), u - f3) : o3 === "configure" ? 0 : c.localeCompare(d2, t2.locales ? t2.locales : void 0, {
        numeric: true,
        sensitivity: "accent"
      });
    }
    let p2 = i2.indexOf(c);
    p2 === -1 && (p2 = i2.indexOf("*")), i2 = p2 !== -1 && Array.isArray(i2[p2 + 1]) ? i2[p2 + 1] : [], l2 += 1;
  }
  return 0;
}, "storySort");
var fc = n2((t2, e2, r2) => {
  if (e2) {
    let o3;
    typeof e2 == "function" ? o3 = e2 : o3 = Ri(e2), t2.sort(o3);
  } else
    t2.sort(
      (o3, i2) => r2.indexOf(o3.importPath) - r2.indexOf(i2.importPath)
    );
  return t2;
}, "sortStoriesCommon");
var mc = n2((t2, e2, r2) => {
  try {
    return fc(t2, e2, r2);
  } catch (o3) {
    throw new Error(_3`
    Error sorting stories with sort parameter ${e2}:

    > ${o3.message}
    
    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `);
  }
}, "sortStoriesV7");
var de = new Error("prepareAborted");
var { AbortController: vi } = globalThis;
function Ci(t2) {
  try {
    let { name: e2 = "Error", message: r2 = String(t2), stack: o3 } = t2;
    return { name: e2, message: r2, stack: o3 };
  } catch {
    return { name: "Error", message: String(t2) };
  }
}
n2(Ci, "serializeError");
var Kr = class Kr2 {
  constructor(e2, r2, o3, i2, s, a, l2 = { autoplay: true, forceInitialArgs: false }, c) {
    this.channel = e2;
    this.store = r2;
    this.renderToScreen = o3;
    this.callbacks = i2;
    this.id = s;
    this.viewMode = a;
    this.renderOptions = l2;
    this.type = "story";
    this.notYetRendered = true;
    this.rerenderEnqueued = false;
    this.disableKeyListeners = false;
    this.teardownRender = n2(() => {
    }, "teardownRender");
    this.torndown = false;
    this.abortController = new vi(), c && (this.story = c, this.phase = "preparing");
  }
  async runPhase(e2, r2, o3) {
    this.phase = r2, this.channel.emit(B, { newPhase: this.phase, storyId: this.id }), o3 && (await o3(), this.checkIfAborted(e2));
  }
  checkIfAborted(e2) {
    return e2.aborted ? (this.phase = "aborted", this.channel.emit(B, { newPhase: this.phase, storyId: this.id }), true) : false;
  }
  async prepare() {
    if (await this.runPhase(this.abortController.signal, "preparing", async () => {
      this.story = await this.store.loadStory({ storyId: this.id });
    }), this.abortController.signal.aborted)
      throw await this.store.cleanupStory(this.story), de;
  }
  // The two story "renders" are equal and have both loaded the same story
  isEqual(e2) {
    return !!(this.id === e2.id && this.story && this.story === e2.story);
  }
  isPreparing() {
    return ["preparing"].includes(this.phase);
  }
  isPending() {
    return ["loading", "beforeEach", "rendering", "playing", "afterEach"].includes(
      this.phase
    );
  }
  async renderToElement(e2) {
    return this.canvasElement = e2, this.render({ initial: true, forceRemount: true });
  }
  storyContext() {
    if (!this.story)
      throw new Error("Cannot call storyContext before preparing");
    let { forceInitialArgs: e2 } = this.renderOptions;
    return this.store.getStoryContext(this.story, { forceInitialArgs: e2 });
  }
  async render({
    initial: e2 = false,
    forceRemount: r2 = false
  } = {}) {
    let { canvasElement: o3 } = this;
    if (!this.story)
      throw new Error("cannot render when not prepared");
    let i2 = this.story;
    if (!o3)
      throw new Error("cannot render when canvasElement is unset");
    let {
      id: s,
      componentId: a,
      title: l2,
      name: c,
      tags: d2,
      applyLoaders: p2,
      applyBeforeEach: u,
      applyAfterEach: f3,
      unboundStoryFn: h2,
      playFunction: g3,
      runStep: T3
    } = i2;
    r2 && !e2 && (this.cancelRender(), this.abortController = new vi());
    let x4 = this.abortController.signal, v3 = false, E = i2.usesMount;
    try {
      let y = {
        ...this.storyContext(),
        viewMode: this.viewMode,
        abortSignal: x4,
        canvasElement: o3,
        loaded: {},
        step: n2((F2, k3) => T3(F2, k3, y), "step"),
        context: null,
        canvas: {},
        userEvent: {},
        renderToCanvas: n2(async () => {
          let F2 = await this.renderToScreen(w4, o3);
          this.teardownRender = F2 || (() => {
          }), v3 = true;
        }, "renderToCanvas"),
        // The story provides (set in a renderer) a mount function that is a higher order function
        // (context) => (...args) => Canvas
        //
        // Before assigning it to the context, we resolve the context dependency,
        // so that a user can just call it as await mount(...args) in their play function.
        mount: n2(async (...F2) => {
          this.callbacks.showStoryDuringRender?.();
          let k3 = null;
          return await this.runPhase(x4, "rendering", async () => {
            k3 = await i2.mount(y)(...F2);
          }), E && await this.runPhase(x4, "playing"), k3;
        }, "mount")
      };
      y.context = y;
      let w4 = {
        componentId: a,
        title: l2,
        kind: l2,
        id: s,
        name: c,
        story: c,
        tags: d2,
        ...this.callbacks,
        showError: n2((F2) => (this.phase = "errored", this.callbacks.showError(F2)), "showError"),
        showException: n2((F2) => (this.phase = "errored", this.callbacks.showException(F2)), "showException"),
        forceRemount: r2 || this.notYetRendered,
        storyContext: y,
        storyFn: n2(() => h2(y), "storyFn"),
        unboundStoryFn: h2
      };
      if (await this.runPhase(x4, "loading", async () => {
        y.loaded = await p2(y);
      }), x4.aborted)
        return;
      let A3 = await u(y);
      if (this.store.addCleanupCallbacks(i2, ...A3), this.checkIfAborted(x4) || (!v3 && !E && await y.mount(), this.notYetRendered = false, x4.aborted))
        return;
      let P4 = this.story.parameters?.test?.dangerouslyIgnoreUnhandledErrors === true, m2 = /* @__PURE__ */ new Set(), b4 = n2((F2) => {
        F2.error && m2.add(F2.error);
      }, "onError"), S3 = n2((F2) => {
        F2.reason && m2.add(F2.reason);
      }, "onUnhandledRejection");
      if (this.renderOptions.autoplay && r2 && g3 && this.phase !== "errored") {
        window?.addEventListener?.("error", b4), window?.addEventListener?.("unhandledrejection", S3), this.disableKeyListeners = true;
        try {
          if (E ? await g3(y) : (y.mount = async () => {
            throw new z4({ playFunction: g3.toString() });
          }, await this.runPhase(x4, "playing", async () => g3(y))), !v3)
            throw new Q2();
          this.checkIfAborted(x4), !P4 && m2.size > 0 ? await this.runPhase(x4, "errored") : await this.runPhase(x4, "played");
        } catch (F2) {
          if (this.callbacks.showStoryDuringRender?.(), await this.runPhase(x4, "errored", async () => {
            this.channel.emit(U, Ci(F2));
          }), this.story.parameters.throwPlayFunctionExceptions !== false)
            throw F2;
          console.error(F2);
        }
        if (!P4 && m2.size > 0 && this.channel.emit(
          H2,
          Array.from(m2).map(Ci)
        ), this.disableKeyListeners = false, window?.removeEventListener?.("unhandledrejection", S3), window?.removeEventListener?.("error", b4), x4.aborted)
          return;
      }
      await this.runPhase(x4, "completing", async () => {
        Ft() ? this.store.addCleanupCallbacks(i2, Me()) : await Le(x4);
      }), await this.runPhase(x4, "completed", async () => {
        this.channel.emit(X2, s);
      }), this.phase !== "errored" && await this.runPhase(x4, "afterEach", async () => {
        await f3(y);
      });
      let C3 = !P4 && m2.size > 0, R3 = y.reporting.reports.some(
        (F2) => F2.status === "failed"
      ), I5 = C3 || R3;
      await this.runPhase(
        x4,
        "finished",
        async () => this.channel.emit(b, {
          storyId: s,
          status: I5 ? "error" : "success",
          reporters: y.reporting.reports
        })
      );
    } catch (y) {
      this.phase = "errored", this.callbacks.showException(y), await this.runPhase(
        x4,
        "finished",
        async () => this.channel.emit(b, {
          storyId: s,
          status: "error",
          reporters: []
        })
      );
    }
    this.rerenderEnqueued && (this.rerenderEnqueued = false, this.render());
  }
  /**
   * Rerender the story. If the story is currently pending (loading/rendering), the rerender will be
   * enqueued, and will be executed after the current render is completed. Rerendering while playing
   * will not be enqueued, and will be executed immediately, to support rendering args changes while
   * playing.
   */
  async rerender() {
    if (this.isPending() && this.phase !== "playing")
      this.rerenderEnqueued = true;
    else
      return this.render();
  }
  async remount() {
    return await this.teardown(), this.render({ forceRemount: true });
  }
  // If the story is torn down (either a new story is rendered or the docs page removes it)
  // we need to consider the fact that the initial render may not be finished
  // (possibly the loaders or the play function are still running). We use the controller
  // as a method to abort them, ASAP, but this is not foolproof as we cannot control what
  // happens inside the user's code.
  cancelRender() {
    this.abortController?.abort();
  }
  async teardown() {
    this.torndown = true, this.cancelRender(), this.story && await this.store.cleanupStory(this.story);
    for (let e2 = 0; e2 < 3; e2 += 1) {
      if (!this.isPending()) {
        await this.teardownRender();
        return;
      }
      await new Promise((r2) => setTimeout(r2, 0));
    }
    window?.location?.reload?.(), await new Promise(() => {
    });
  }
};
n2(Kr, "StoryRender");
var Te = Kr;
var { fetch: Lc } = scope;
var _c = "./index.json";
var Xr = class Xr2 {
  constructor(e2, r2, o3 = z5.getChannel(), i2 = true) {
    this.importFn = e2;
    this.getProjectAnnotations = r2;
    this.channel = o3;
    this.storyRenders = [];
    this.storeInitializationPromise = new Promise((s, a) => {
      this.resolveStoreInitializationPromise = s, this.rejectStoreInitializationPromise = a;
    }), i2 && this.initialize();
  }
  // Create a proxy object for `__STORYBOOK_STORY_STORE__` and `__STORYBOOK_PREVIEW__.storyStore`
  // That proxies through to the store once ready, and errors beforehand. This means we can set
  // `__STORYBOOK_STORY_STORE__ = __STORYBOOK_PREVIEW__.storyStore` without having to wait, and
  // similarly integrators can access the `storyStore` on the preview at any time, although
  // it is considered deprecated and we will no longer allow access in 9.0
  get storyStore() {
    return new Proxy(
      {},
      {
        get: n2((e2, r2) => {
          if (this.storyStoreValue)
            return h("Accessing the Story Store is deprecated and will be removed in 9.0"), this.storyStoreValue[r2];
          throw new q2();
        }, "get")
      }
    );
  }
  // INITIALIZATION
  async initialize() {
    this.setupListeners();
    try {
      let e2 = await this.getProjectAnnotationsOrRenderError();
      await this.runBeforeAllHook(e2), await this.initializeWithProjectAnnotations(e2);
    } catch (e2) {
      this.rejectStoreInitializationPromise(e2);
    }
  }
  ready() {
    return this.storeInitializationPromise;
  }
  setupListeners() {
    this.channel.on(Q, this.onStoryIndexChanged.bind(this)), this.channel.on(z2, this.onUpdateGlobals.bind(this)), this.channel.on(Z, this.onUpdateArgs.bind(this)), this.channel.on(TE, this.onRequestArgTypesInfo.bind(this)), this.channel.on(p, this.onResetArgs.bind(this)), this.channel.on(P, this.onForceReRender.bind(this)), this.channel.on(L, this.onForceRemount.bind(this));
  }
  async getProjectAnnotationsOrRenderError() {
    try {
      let e2 = await this.getProjectAnnotations();
      if (this.renderToCanvas = e2.renderToCanvas, !this.renderToCanvas)
        throw new F();
      return e2;
    } catch (e2) {
      throw this.renderPreviewEntryError("Error reading preview.js:", e2), e2;
    }
  }
  // If initialization gets as far as project annotations, this function runs.
  async initializeWithProjectAnnotations(e2) {
    this.projectAnnotationsBeforeInitialization = e2;
    try {
      let r2 = await this.getStoryIndexFromServer();
      return this.initializeWithStoryIndex(r2);
    } catch (r2) {
      throw this.renderPreviewEntryError("Error loading story index:", r2), r2;
    }
  }
  async runBeforeAllHook(e2) {
    try {
      await this.beforeAllCleanup?.(), this.beforeAllCleanup = await e2.beforeAll?.();
    } catch (r2) {
      throw this.renderPreviewEntryError("Error in beforeAll hook:", r2), r2;
    }
  }
  async getStoryIndexFromServer() {
    let e2 = await Lc(_c);
    if (e2.status === 200)
      return e2.json();
    throw new M2({ text: await e2.text() });
  }
  // If initialization gets as far as the story index, this function runs.
  initializeWithStoryIndex(e2) {
    if (!this.projectAnnotationsBeforeInitialization)
      throw new Error("Cannot call initializeWithStoryIndex until project annotations resolve");
    this.storyStoreValue = new _e(
      e2,
      this.importFn,
      this.projectAnnotationsBeforeInitialization
    ), delete this.projectAnnotationsBeforeInitialization, this.setInitialGlobals(), this.resolveStoreInitializationPromise();
  }
  async setInitialGlobals() {
    this.emitGlobals();
  }
  emitGlobals() {
    if (!this.storyStoreValue)
      throw new H3({ methodName: "emitGlobals" });
    let e2 = {
      globals: this.storyStoreValue.userGlobals.get() || {},
      globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {}
    };
    this.channel.emit(e, e2);
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations: e2
  }) {
    delete this.previewEntryError, this.getProjectAnnotations = e2;
    let r2 = await this.getProjectAnnotationsOrRenderError();
    if (await this.runBeforeAllHook(r2), !this.storyStoreValue) {
      await this.initializeWithProjectAnnotations(r2);
      return;
    }
    this.storyStoreValue.setProjectAnnotations(r2), this.emitGlobals();
  }
  async onStoryIndexChanged() {
    if (delete this.previewEntryError, !(!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization))
      try {
        let e2 = await this.getStoryIndexFromServer();
        if (this.projectAnnotationsBeforeInitialization) {
          this.initializeWithStoryIndex(e2);
          return;
        }
        await this.onStoriesChanged({ storyIndex: e2 });
      } catch (e2) {
        throw this.renderPreviewEntryError("Error loading story index:", e2), e2;
      }
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn: e2,
    storyIndex: r2
  }) {
    if (!this.storyStoreValue)
      throw new H3({ methodName: "onStoriesChanged" });
    await this.storyStoreValue.onStoriesChanged({ importFn: e2, storyIndex: r2 });
  }
  async onUpdateGlobals({
    globals: e2,
    currentStory: r2
  }) {
    if (this.storyStoreValue || await this.storeInitializationPromise, !this.storyStoreValue)
      throw new H3({ methodName: "onUpdateGlobals" });
    if (this.storyStoreValue.userGlobals.update(e2), r2) {
      let { initialGlobals: o3, storyGlobals: i2, userGlobals: s, globals: a } = this.storyStoreValue.getStoryContext(r2);
      this.channel.emit(Y, {
        initialGlobals: o3,
        userGlobals: s,
        storyGlobals: i2,
        globals: a
      });
    } else {
      let { initialGlobals: o3, globals: i2 } = this.storyStoreValue.userGlobals;
      this.channel.emit(Y, {
        initialGlobals: o3,
        userGlobals: i2,
        storyGlobals: {},
        globals: i2
      });
    }
    await Promise.all(this.storyRenders.map((o3) => o3.rerender()));
  }
  async onUpdateArgs({ storyId: e2, updatedArgs: r2 }) {
    if (!this.storyStoreValue)
      throw new H3({ methodName: "onUpdateArgs" });
    this.storyStoreValue.args.update(e2, r2), await Promise.all(
      this.storyRenders.filter((o3) => o3.id === e2 && !o3.renderOptions.forceInitialArgs).map(
        (o3) => (
          // We only run the play function, with in a force remount.
          // But when mount is destructured, the rendering happens inside of the play function.
          o3.story && o3.story.usesMount ? o3.remount() : o3.rerender()
        )
      )
    ), this.channel.emit(x, {
      storyId: e2,
      args: this.storyStoreValue.args.get(e2)
    });
  }
  async onRequestArgTypesInfo({ id: e2, payload: r2 }) {
    try {
      await this.storeInitializationPromise;
      let o3 = await this.storyStoreValue?.loadStory(r2);
      this.channel.emit(OE, {
        id: e2,
        success: true,
        payload: { argTypes: o3?.argTypes || {} },
        error: null
      });
    } catch (o3) {
      this.channel.emit(OE, {
        id: e2,
        success: false,
        error: o3?.message
      });
    }
  }
  async onResetArgs({ storyId: e2, argNames: r2 }) {
    if (!this.storyStoreValue)
      throw new H3({ methodName: "onResetArgs" });
    let i2 = this.storyRenders.find((l2) => l2.id === e2)?.story || await this.storyStoreValue.loadStory({ storyId: e2 }), a = (r2 || [
      .../* @__PURE__ */ new Set([
        ...Object.keys(i2.initialArgs),
        ...Object.keys(this.storyStoreValue.args.get(e2))
      ])
    ]).reduce((l2, c) => (l2[c] = i2.initialArgs[c], l2), {});
    await this.onUpdateArgs({ storyId: e2, updatedArgs: a });
  }
  // ForceReRender does not include a story id, so we simply must
  // re-render all stories in case they are relevant
  async onForceReRender() {
    await Promise.all(this.storyRenders.map((e2) => e2.rerender()));
  }
  async onForceRemount({ storyId: e2 }) {
    await Promise.all(this.storyRenders.filter((r2) => r2.id === e2).map((r2) => r2.remount()));
  }
  // Used by docs to render a story to a given element
  // Note this short-circuits the `prepare()` phase of the StoryRender,
  // main to be consistent with the previous behaviour. In the future,
  // we will change it to go ahead and load the story, which will end up being
  // "instant", although async.
  renderStoryToElement(e2, r2, o3, i2) {
    if (!this.renderToCanvas || !this.storyStoreValue)
      throw new H3({
        methodName: "renderStoryToElement"
      });
    let s = new Te(
      this.channel,
      this.storyStoreValue,
      this.renderToCanvas,
      o3,
      e2.id,
      "docs",
      i2,
      e2
    );
    return s.renderToElement(r2), this.storyRenders.push(s), async () => {
      await this.teardownRender(s);
    };
  }
  async teardownRender(e2, { viewModeChanged: r2 } = {}) {
    this.storyRenders = this.storyRenders.filter((o3) => o3 !== e2), await e2?.teardown?.({ viewModeChanged: r2 });
  }
  // API
  async loadStory({ storyId: e2 }) {
    if (!this.storyStoreValue)
      throw new H3({ methodName: "loadStory" });
    return this.storyStoreValue.loadStory({ storyId: e2 });
  }
  getStoryContext(e2, { forceInitialArgs: r2 = false } = {}) {
    if (!this.storyStoreValue)
      throw new H3({ methodName: "getStoryContext" });
    return this.storyStoreValue.getStoryContext(e2, { forceInitialArgs: r2 });
  }
  async extract(e2) {
    if (!this.storyStoreValue)
      throw new H3({ methodName: "extract" });
    if (this.previewEntryError)
      throw this.previewEntryError;
    return await this.storyStoreValue.cacheAllCSFFiles(), this.storyStoreValue.extract(e2);
  }
  // UTILITIES
  renderPreviewEntryError(e2, r2) {
    this.previewEntryError = r2, i.error(e2), i.error(r2), this.channel.emit(O, r2);
  }
};
n2(Xr, "Preview");
var je = Xr;
var Jr = class Jr2 {
  constructor(e2, r2, o3, i2) {
    this.channel = e2;
    this.store = r2;
    this.renderStoryToElement = o3;
    this.storyIdByName = n2((e3) => {
      let r3 = this.nameToStoryId.get(e3);
      if (r3)
        return r3;
      throw new Error(`No story found with that name: ${e3}`);
    }, "storyIdByName");
    this.componentStories = n2(() => this.componentStoriesValue, "componentStories");
    this.componentStoriesFromCSFFile = n2((e3) => this.store.componentStoriesFromCSFFile({ csfFile: e3 }), "componentStoriesFromCSFFile");
    this.storyById = n2((e3) => {
      if (!e3) {
        if (!this.primaryStory)
          throw new Error(
            "No primary story defined for docs entry. Did you forget to use `<Meta>`?"
          );
        return this.primaryStory;
      }
      let r3 = this.storyIdToCSFFile.get(e3);
      if (!r3)
        throw new Error(`Called \`storyById\` for story that was never loaded: ${e3}`);
      return this.store.storyFromCSFFile({ storyId: e3, csfFile: r3 });
    }, "storyById");
    this.getStoryContext = n2((e3) => ({
      ...this.store.getStoryContext(e3),
      loaded: {},
      viewMode: "docs"
    }), "getStoryContext");
    this.loadStory = n2((e3) => this.store.loadStory({ storyId: e3 }), "loadStory");
    this.componentStoriesValue = [], this.storyIdToCSFFile = /* @__PURE__ */ new Map(), this.exportToStory = /* @__PURE__ */ new Map(), this.exportsToCSFFile = /* @__PURE__ */ new Map(), this.nameToStoryId = /* @__PURE__ */ new Map(), this.attachedCSFFiles = /* @__PURE__ */ new Set(), i2.forEach((s, a) => {
      this.referenceCSFFile(s);
    });
  }
  // This docs entry references this CSF file and can synchronously load the stories, as well
  // as reference them by module export. If the CSF is part of the "component" stories, they
  // can also be referenced by name and are in the componentStories list.
  referenceCSFFile(e2) {
    this.exportsToCSFFile.set(e2.moduleExports, e2), this.exportsToCSFFile.set(e2.moduleExports.default, e2), this.store.componentStoriesFromCSFFile(
      { csfFile: e2 }
    ).forEach((o3) => {
      let i2 = e2.stories[o3.id];
      this.storyIdToCSFFile.set(i2.id, e2), this.exportToStory.set(i2.moduleExport, o3);
    });
  }
  attachCSFFile(e2) {
    if (!this.exportsToCSFFile.has(e2.moduleExports))
      throw new Error("Cannot attach a CSF file that has not been referenced");
    if (this.attachedCSFFiles.has(e2))
      return;
    this.attachedCSFFiles.add(e2), this.store.componentStoriesFromCSFFile({ csfFile: e2 }).forEach((o3) => {
      this.nameToStoryId.set(o3.name, o3.id), this.componentStoriesValue.push(o3), this.primaryStory || (this.primaryStory = o3);
    });
  }
  referenceMeta(e2, r2) {
    let o3 = this.resolveModuleExport(e2);
    if (o3.type !== "meta")
      throw new Error(
        "<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?"
      );
    r2 && this.attachCSFFile(o3.csfFile);
  }
  get projectAnnotations() {
    let { projectAnnotations: e2 } = this.store;
    if (!e2)
      throw new Error("Can't get projectAnnotations from DocsContext before they are initialized");
    return e2;
  }
  resolveAttachedModuleExportType(e2) {
    if (e2 === "story") {
      if (!this.primaryStory)
        throw new Error(
          "No primary story attached to this docs file, did you forget to use <Meta of={} />?"
        );
      return { type: "story", story: this.primaryStory };
    }
    if (this.attachedCSFFiles.size === 0)
      throw new Error(
        "No CSF file attached to this docs file, did you forget to use <Meta of={} />?"
      );
    let r2 = Array.from(this.attachedCSFFiles)[0];
    if (e2 === "meta")
      return { type: "meta", csfFile: r2 };
    let { component: o3 } = r2.meta;
    if (!o3)
      throw new Error(
        "Attached CSF file does not defined a component, did you forget to export one?"
      );
    return { type: "component", component: o3 };
  }
  resolveModuleExport(e2) {
    let r2 = this.exportsToCSFFile.get(e2);
    if (r2)
      return { type: "meta", csfFile: r2 };
    let o3 = this.exportToStory.get(
      J(e2) ? e2.input : e2
    );
    return o3 ? { type: "story", story: o3 } : { type: "component", component: e2 };
  }
  resolveOf(e2, r2 = []) {
    let o3;
    if (["component", "meta", "story"].includes(e2)) {
      let i2 = e2;
      o3 = this.resolveAttachedModuleExportType(i2);
    } else
      o3 = this.resolveModuleExport(e2);
    if (r2.length && !r2.includes(o3.type)) {
      let i2 = o3.type === "component" ? "component or unknown" : o3.type;
      throw new Error(_3`Invalid value passed to the 'of' prop. The value was resolved to a '${i2}' type but the only types for this block are: ${r2.join(
        ", "
      )}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);
    }
    switch (o3.type) {
      case "component":
        return {
          ...o3,
          projectAnnotations: this.projectAnnotations
        };
      case "meta":
        return {
          ...o3,
          preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: o3.csfFile })
        };
      case "story":
      default:
        return o3;
    }
  }
};
n2(Jr, "DocsContext");
var pe = Jr;
var Zr = class Zr2 {
  constructor(e2, r2, o3, i2) {
    this.channel = e2;
    this.store = r2;
    this.entry = o3;
    this.callbacks = i2;
    this.type = "docs";
    this.subtype = "csf";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = o3.id;
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    let { entryExports: e2, csfFiles: r2 = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw de;
    let { importPath: o3, title: i2 } = this.entry, s = this.store.processCSFFileWithCache(
      e2,
      o3,
      i2
    ), a = Object.keys(s.stories)[0];
    this.story = this.store.storyFromCSFFile({ storyId: a, csfFile: s }), this.csfFiles = [s, ...r2], this.preparing = false;
  }
  isEqual(e2) {
    return !!(this.id === e2.id && this.story && this.story === e2.story);
  }
  docsContext(e2) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let r2 = new pe(
      this.channel,
      this.store,
      e2,
      this.csfFiles
    );
    return this.csfFiles.forEach((o3) => r2.attachCSFFile(o3)), r2;
  }
  async renderToElement(e2, r2) {
    if (!this.story || !this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let o3 = this.docsContext(r2), { docs: i2 } = this.story.parameters || {};
    if (!i2)
      throw new Error(
        "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
      );
    let s = await i2.renderer(), { render: a } = s, l2 = n2(async () => {
      try {
        await a(o3, i2, e2), this.channel.emit(I2, this.id);
      } catch (c) {
        this.callbacks.showException(c);
      }
    }, "renderDocs");
    return this.rerender = async () => l2(), this.teardownRender = async ({ viewModeChanged: c }) => {
      !c || !e2 || s.unmount(e2);
    }, l2();
  }
  async teardown({ viewModeChanged: e2 } = {}) {
    this.teardownRender?.({ viewModeChanged: e2 }), this.torndown = true;
  }
};
n2(Zr, "CsfDocsRender");
var ot = Zr;
var Qr = class Qr2 {
  constructor(e2, r2, o3, i2) {
    this.channel = e2;
    this.store = r2;
    this.entry = o3;
    this.callbacks = i2;
    this.type = "docs";
    this.subtype = "mdx";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = o3.id;
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    let { entryExports: e2, csfFiles: r2 = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw de;
    this.csfFiles = r2, this.exports = e2, this.preparing = false;
  }
  isEqual(e2) {
    return !!(this.id === e2.id && this.exports && this.exports === e2.exports);
  }
  docsContext(e2) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    return new pe(
      this.channel,
      this.store,
      e2,
      this.csfFiles
    );
  }
  async renderToElement(e2, r2) {
    if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
      throw new Error("Cannot render docs before preparing");
    let o3 = this.docsContext(r2), { docs: i2 } = this.store.projectAnnotations.parameters || {};
    if (!i2)
      throw new Error(
        "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
      );
    let s = { ...i2, page: this.exports.default }, a = await i2.renderer(), { render: l2 } = a, c = n2(async () => {
      try {
        await l2(o3, s, e2), this.channel.emit(I2, this.id);
      } catch (d2) {
        this.callbacks.showException(d2);
      }
    }, "renderDocs");
    return this.rerender = async () => c(), this.teardownRender = async ({ viewModeChanged: d2 } = {}) => {
      !d2 || !e2 || (a.unmount(e2), this.torndown = true);
    }, c();
  }
  async teardown({ viewModeChanged: e2 } = {}) {
    this.teardownRender?.({ viewModeChanged: e2 }), this.torndown = true;
  }
};
n2(Qr, "MdxDocsRender");
var nt = Qr;
var ed = globalThis;
function td(t2) {
  let e2 = t2.composedPath && t2.composedPath()[0] || t2.target;
  return /input|textarea/i.test(e2.tagName) || e2.getAttribute("contenteditable") !== null;
}
n2(td, "focusInInput");
var Li = "attached-mdx";
var rd = "unattached-mdx";
function od({ tags: t2 }) {
  return t2?.includes(rd) || t2?.includes(Li);
}
n2(od, "isMdxEntry");
function to(t2) {
  return t2.type === "story";
}
n2(to, "isStoryRender");
function nd(t2) {
  return t2.type === "docs";
}
n2(nd, "isDocsRender");
function id(t2) {
  return nd(t2) && t2.subtype === "csf";
}
n2(id, "isCsfDocsRender");
var ro = class ro2 extends je {
  constructor(r2, o3, i2, s) {
    super(r2, o3, void 0, false);
    this.importFn = r2;
    this.getProjectAnnotations = o3;
    this.selectionStore = i2;
    this.view = s;
    this.initialize();
  }
  setupListeners() {
    super.setupListeners(), ed.onkeydown = this.onKeydown.bind(this), this.channel.on(l, this.onSetCurrentStory.bind(this)), this.channel.on(
      J2,
      this.onUpdateQueryParams.bind(this)
    ), this.channel.on(G, this.onPreloadStories.bind(this));
  }
  async setInitialGlobals() {
    if (!this.storyStoreValue)
      throw new H3({ methodName: "setInitialGlobals" });
    let { globals: r2 } = this.selectionStore.selectionSpecifier || {};
    r2 && this.storyStoreValue.userGlobals.updateFromPersisted(r2), this.emitGlobals();
  }
  // If initialization gets as far as the story index, this function runs.
  async initializeWithStoryIndex(r2) {
    return await super.initializeWithStoryIndex(r2), this.selectSpecifiedStory();
  }
  // Use the selection specifier to choose a story, then render it
  async selectSpecifiedStory() {
    if (!this.storyStoreValue)
      throw new H3({
        methodName: "selectSpecifiedStory"
      });
    if (this.selectionStore.selection) {
      await this.renderSelection();
      return;
    }
    if (!this.selectionStore.selectionSpecifier) {
      this.renderMissingStory();
      return;
    }
    let { storySpecifier: r2, args: o3 } = this.selectionStore.selectionSpecifier, i2 = this.storyStoreValue.storyIndex.entryFromSpecifier(r2);
    if (!i2) {
      r2 === "*" ? this.renderStoryLoadingException(r2, new X3()) : this.renderStoryLoadingException(
        r2,
        new U2({ storySpecifier: r2.toString() })
      );
      return;
    }
    let { id: s, type: a } = i2;
    this.selectionStore.setSelection({ storyId: s, viewMode: a }), this.channel.emit(q, this.selectionStore.selection), this.channel.emit(
      r,
      this.selectionStore.selection
    ), await this.renderSelection({ persistedArgs: o3 });
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations: r2
  }) {
    await super.onGetProjectAnnotationsChanged({ getProjectAnnotations: r2 }), this.selectionStore.selection && this.renderSelection();
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn: r2,
    storyIndex: o3
  }) {
    await super.onStoriesChanged({ importFn: r2, storyIndex: o3 }), this.selectionStore.selection ? await this.renderSelection() : await this.selectSpecifiedStory();
  }
  onKeydown(r2) {
    if (!this.storyRenders.find((o3) => o3.disableKeyListeners) && !td(r2)) {
      let { altKey: o3, ctrlKey: i2, metaKey: s, shiftKey: a, key: l2, code: c, keyCode: d2 } = r2;
      this.channel.emit(d, {
        event: { altKey: o3, ctrlKey: i2, metaKey: s, shiftKey: a, key: l2, code: c, keyCode: d2 }
      });
    }
  }
  async onSetCurrentStory(r2) {
    this.selectionStore.setSelection({ viewMode: "story", ...r2 }), await this.storeInitializationPromise, this.channel.emit(r, this.selectionStore.selection), this.renderSelection();
  }
  onUpdateQueryParams(r2) {
    this.selectionStore.setQueryParams(r2);
  }
  async onUpdateGlobals({ globals: r2 }) {
    let o3 = this.currentRender instanceof Te && this.currentRender.story || void 0;
    super.onUpdateGlobals({ globals: r2, currentStory: o3 }), (this.currentRender instanceof nt || this.currentRender instanceof ot) && await this.currentRender.rerender?.();
  }
  async onUpdateArgs({ storyId: r2, updatedArgs: o3 }) {
    super.onUpdateArgs({ storyId: r2, updatedArgs: o3 });
  }
  async onPreloadStories({ ids: r2 }) {
    await this.storeInitializationPromise, this.storyStoreValue && await Promise.allSettled(r2.map((o3) => this.storyStoreValue?.loadEntry(o3)));
  }
  // RENDERING
  // We can either have:
  // - a story selected in "story" viewMode,
  //     in which case we render it to the root element, OR
  // - a story selected in "docs" viewMode,
  //     in which case we render the docsPage for that story
  async renderSelection({ persistedArgs: r2 } = {}) {
    let { renderToCanvas: o3 } = this;
    if (!this.storyStoreValue || !o3)
      throw new H3({ methodName: "renderSelection" });
    let { selection: i2 } = this.selectionStore;
    if (!i2)
      throw new Error("Cannot call renderSelection as no selection was made");
    let { storyId: s } = i2, a;
    try {
      a = await this.storyStoreValue.storyIdToEntry(s);
    } catch (h2) {
      this.currentRender && await this.teardownRender(this.currentRender), this.renderStoryLoadingException(s, h2);
      return;
    }
    let l2 = this.currentSelection?.storyId !== s, c = this.currentRender?.type !== a.type;
    a.type === "story" ? this.view.showPreparingStory({ immediate: c }) : this.view.showPreparingDocs({ immediate: c }), this.currentRender?.isPreparing() && await this.teardownRender(this.currentRender);
    let d2;
    a.type === "story" ? d2 = new Te(
      this.channel,
      this.storyStoreValue,
      o3,
      this.mainStoryCallbacks(s),
      s,
      "story"
    ) : od(a) ? d2 = new nt(
      this.channel,
      this.storyStoreValue,
      a,
      this.mainStoryCallbacks(s)
    ) : d2 = new ot(
      this.channel,
      this.storyStoreValue,
      a,
      this.mainStoryCallbacks(s)
    );
    let p2 = this.currentSelection;
    this.currentSelection = i2;
    let u = this.currentRender;
    this.currentRender = d2;
    try {
      await d2.prepare();
    } catch (h2) {
      u && await this.teardownRender(u), h2 !== de && this.renderStoryLoadingException(s, h2);
      return;
    }
    let f3 = !l2 && u && !d2.isEqual(u);
    if (r2 && to(d2) && (se2(!!d2.story), this.storyStoreValue.args.updateFromPersisted(d2.story, r2)), u && !u.torndown && !l2 && !f3 && !c) {
      this.currentRender = u, this.channel.emit(j, s), this.view.showMain();
      return;
    }
    if (u && await this.teardownRender(u, { viewModeChanged: c }), p2 && (l2 || c) && this.channel.emit(m, s), to(d2)) {
      se2(!!d2.story);
      let {
        parameters: h2,
        initialArgs: g3,
        argTypes: T3,
        unmappedArgs: x4,
        initialGlobals: v3,
        userGlobals: E,
        storyGlobals: y,
        globals: w4
      } = this.storyStoreValue.getStoryContext(d2.story);
      this.channel.emit(w, {
        id: s,
        parameters: h2,
        initialArgs: g3,
        argTypes: T3,
        args: x4
      }), this.channel.emit(Y, { userGlobals: E, storyGlobals: y, globals: w4, initialGlobals: v3 });
    } else {
      let { parameters: h2 } = this.storyStoreValue.projectAnnotations, { initialGlobals: g3, globals: T3 } = this.storyStoreValue.userGlobals;
      if (this.channel.emit(Y, {
        globals: T3,
        initialGlobals: g3,
        storyGlobals: {},
        userGlobals: T3
      }), id(d2) || d2.entry.tags?.includes(Li)) {
        if (!d2.csfFiles)
          throw new K3({ storyId: s });
        ({ parameters: h2 } = this.storyStoreValue.preparedMetaFromCSFFile({
          csfFile: d2.csfFiles[0]
        }));
      }
      this.channel.emit(D, {
        id: s,
        parameters: h2
      });
    }
    to(d2) ? (se2(!!d2.story), this.storyRenders.push(d2), this.currentRender.renderToElement(
      this.view.prepareForStory(d2.story)
    )) : this.currentRender.renderToElement(
      this.view.prepareForDocs(),
      // This argument is used for docs, which is currently only compatible with HTMLElements
      this.renderStoryToElement.bind(this)
    );
  }
  async teardownRender(r2, { viewModeChanged: o3 = false } = {}) {
    this.storyRenders = this.storyRenders.filter((i2) => i2 !== r2), await r2?.teardown?.({ viewModeChanged: o3 });
  }
  // UTILITIES
  mainStoryCallbacks(r2) {
    return {
      showStoryDuringRender: n2(() => this.view.showStoryDuringRender(), "showStoryDuringRender"),
      showMain: n2(() => this.view.showMain(), "showMain"),
      showError: n2((o3) => this.renderError(r2, o3), "showError"),
      showException: n2((o3) => this.renderException(r2, o3), "showException")
    };
  }
  renderPreviewEntryError(r2, o3) {
    super.renderPreviewEntryError(r2, o3), this.view.showErrorDisplay(o3);
  }
  renderMissingStory() {
    this.view.showNoPreview(), this.channel.emit(V);
  }
  renderStoryLoadingException(r2, o3) {
    i.error(o3), this.view.showErrorDisplay(o3), this.channel.emit(V, r2);
  }
  // renderException is used if we fail to render the story and it is uncaught by the app layer
  renderException(r2, o3) {
    let { name: i2 = "Error", message: s = String(o3), stack: a } = o3;
    this.channel.emit(K2, { name: i2, message: s, stack: a }), this.channel.emit(B, { newPhase: "errored", storyId: r2 }), this.view.showErrorDisplay(
      o3
    ), i.error(`Error rendering story '${r2}':`), i.error(o3);
  }
  // renderError is used by the various app layers to inform the user they have done something
  // wrong -- for instance returned the wrong thing from a story
  renderError(r2, { title: o3, description: i2 }) {
    i.error(`Error rendering story ${o3}: ${i2}`), this.channel.emit(M, { title: o3, description: i2 }), this.channel.emit(B, { newPhase: "errored", storyId: r2 }), this.view.showErrorDisplay({
      message: o3,
      stack: i2
    });
  }
};
n2(ro, "PreviewWithSelection");
var Ne = ro;
var st = ve(_t(), 1);
var Yi = ve(_t(), 1);
var Wi = /^[a-zA-Z0-9 _-]*$/;
var Ki = /^-?[0-9]+(\.[0-9]+)?$/;
var kd = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i;
var Xi = /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i;
var co = n2((t2 = "", e2) => t2 === null || t2 === "" || !Wi.test(t2) ? false : e2 == null || e2 instanceof Date || typeof e2 == "number" || typeof e2 == "boolean" ? true : typeof e2 == "string" ? Wi.test(e2) || Ki.test(e2) || kd.test(e2) || Xi.test(e2) : Array.isArray(e2) ? e2.every((r2) => co(
  t2,
  r2
)) : $3(e2) ? Object.entries(e2).every(([r2, o3]) => co(r2, o3)) : false, "validateArgs");
var Dd = {
  delimiter: ";",
  // we're parsing a single query param
  nesting: true,
  arrayRepeat: true,
  arrayRepeatSyntax: "bracket",
  nestingSyntax: "js",
  // objects are encoded using dot notation
  valueDeserializer(t2) {
    if (t2.startsWith("!")) {
      if (t2 === "!undefined")
        return;
      if (t2 === "!null")
        return null;
      if (t2 === "!true")
        return true;
      if (t2 === "!false")
        return false;
      if (t2.startsWith("!date(") && t2.endsWith(")"))
        return new Date(t2.replaceAll(" ", "+").slice(6, -1));
      if (t2.startsWith("!hex(") && t2.endsWith(")"))
        return `#${t2.slice(5, -1)}`;
      let e2 = t2.slice(1).match(Xi);
      if (e2)
        return t2.startsWith("!rgba") || t2.startsWith("!RGBA") ? `${e2[1]}(${e2[2]}, ${e2[3]}, ${e2[4]}, ${e2[5]})` : t2.startsWith("!hsla") || t2.startsWith(
          "!HSLA"
        ) ? `${e2[1]}(${e2[2]}, ${e2[3]}%, ${e2[4]}%, ${e2[5]})` : t2.startsWith("!rgb") || t2.startsWith("!RGB") ? `${e2[1]}(${e2[2]}, ${e2[3]}, ${e2[4]})` : `${e2[1]}(${e2[2]}, ${e2[3]}%, ${e2[4]}%)`;
    }
    return Ki.test(t2) ? Number(t2) : t2;
  }
};
var po = n2((t2) => {
  let e2 = t2.split(";").map((r2) => r2.replace("=", "~").replace(":", "="));
  return Object.entries((0, Yi.parse)(e2.join(";"), Dd)).reduce((r2, [o3, i2]) => co(o3, i2) ? Object.assign(r2, { [o3]: i2 }) : (o.warn(_3`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/writing-stories/args#setting-args-through-the-url
    `), r2), {});
}, "parseArgsParam");
var { history: Ji, document: ue } = scope;
function Ld(t2) {
  let e2 = (t2 || "").match(/^\/story\/(.+)/);
  if (!e2)
    throw new Error(`Invalid path '${t2}',  must start with '/story/'`);
  return e2[1];
}
n2(Ld, "pathToId");
var Zi = n2(({
  selection: t2,
  extraParams: e2
}) => {
  let r2 = ue?.location.search.slice(1), { path: o3, selectedKind: i2, selectedStory: s, ...a } = (0, st.parse)(r2);
  return `?${(0, st.stringify)({
    ...a,
    ...e2,
    ...t2 && { id: t2.storyId, viewMode: t2.viewMode }
  })}`;
}, "getQueryString");
var _d = n2((t2) => {
  if (!t2)
    return;
  let e2 = Zi({ selection: t2 }), { hash: r2 = "" } = ue.location;
  ue.title = t2.storyId, Ji.replaceState({}, "", `${ue.location.pathname}${e2}${r2}`);
}, "setPath");
var jd = n2((t2) => t2 != null && typeof t2 == "object" && Array.isArray(t2) === false, "isObject");
var it = n2(
  (t2) => {
    if (t2 !== void 0) {
      if (typeof t2 == "string")
        return t2;
      if (Array.isArray(t2))
        return it(t2[0]);
      if (jd(t2))
        return it(
          Object.values(t2).filter(Boolean)
        );
    }
  },
  "getFirstString"
);
var Nd = n2(() => {
  if (typeof ue < "u") {
    let t2 = ue.location.search.slice(1), e2 = (0, st.parse)(t2), r2 = typeof e2.args == "string" ? po(e2.args) : void 0, o3 = typeof e2.globals == "string" ? po(e2.globals) : void 0, i2 = it(e2.viewMode);
    (typeof i2 != "string" || !i2.match(/docs|story/)) && (i2 = "story");
    let s = it(e2.path), a = s ? Ld(s) : it(e2.id);
    if (a)
      return { storySpecifier: a, args: r2, globals: o3, viewMode: i2 };
  }
  return null;
}, "getSelectionSpecifierFromPath");
var uo = class uo2 {
  constructor() {
    this.selectionSpecifier = Nd();
  }
  setSelection(e2) {
    this.selection = e2, _d(this.selection);
  }
  setQueryParams(e2) {
    let r2 = Zi({ extraParams: e2 }), { hash: o3 = "" } = ue.location;
    Ji.replaceState({}, "", `${ue.location.pathname}${r2}${o3}`);
  }
};
n2(uo, "UrlStore");
var qe = uo;
var Is = ve(Cs(), 1);
var Os = ve(_t(), 1);
var { document: H4 } = scope;
var Ps = 100;
var ks = ((s) => (s.MAIN = "MAIN", s.NOPREVIEW = "NOPREVIEW", s.PREPARING_STORY = "PREPARING_STORY", s.PREPARING_DOCS = "PREPARING_DOCS", s.ERROR = "ERROR", s))(ks || {});
var So = {
  PREPARING_STORY: "sb-show-preparing-story",
  PREPARING_DOCS: "sb-show-preparing-docs",
  MAIN: "sb-show-main",
  NOPREVIEW: "sb-show-nopreview",
  ERROR: "sb-show-errordisplay"
};
var xo = {
  centered: "sb-main-centered",
  fullscreen: "sb-main-fullscreen",
  padded: "sb-main-padded"
};
var Fs = new Is.default({
  escapeXML: true
});
var To = class To2 {
  constructor() {
    this.testing = false;
    if (typeof H4 < "u") {
      let { __SPECIAL_TEST_PARAMETER__: e2 } = (0, Os.parse)(H4.location.search.slice(1));
      switch (e2) {
        case "preparing-story": {
          this.showPreparingStory(), this.testing = true;
          break;
        }
        case "preparing-docs": {
          this.showPreparingDocs(), this.testing = true;
          break;
        }
        default:
      }
    }
  }
  // Get ready to render a story, returning the element to render to
  prepareForStory(e2) {
    return this.showStory(), this.applyLayout(e2.parameters.layout), H4.documentElement.scrollTop = 0, H4.documentElement.scrollLeft = 0, this.storyRoot();
  }
  storyRoot() {
    return H4.getElementById("storybook-root");
  }
  prepareForDocs() {
    return this.showMain(), this.showDocs(), this.applyLayout("fullscreen"), H4.documentElement.scrollTop = 0, H4.documentElement.scrollLeft = 0, this.docsRoot();
  }
  docsRoot() {
    return H4.getElementById("storybook-docs");
  }
  applyLayout(e2 = "padded") {
    if (e2 === "none") {
      H4.body.classList.remove(this.currentLayoutClass), this.currentLayoutClass = null;
      return;
    }
    this.checkIfLayoutExists(e2);
    let r2 = xo[e2];
    H4.body.classList.remove(this.currentLayoutClass), H4.body.classList.add(r2), this.currentLayoutClass = r2;
  }
  checkIfLayoutExists(e2) {
    xo[e2] || i.warn(
      _3`
          The desired layout: ${e2} is not a valid option.
          The possible options are: ${Object.keys(xo).join(", ")}, none.
        `
    );
  }
  showMode(e2) {
    clearTimeout(this.preparingTimeout), Object.keys(ks).forEach((r2) => {
      r2 === e2 ? H4.body.classList.add(So[r2]) : H4.body.classList.remove(So[r2]);
    });
  }
  showErrorDisplay({ message: e2 = "", stack: r2 = "" }) {
    let o3 = e2, i2 = r2, s = e2.split(`
`);
    s.length > 1 && ([o3] = s, i2 = s.slice(1).join(`
`).replace(/^\n/, "")), H4.getElementById("error-message").innerHTML = Fs.toHtml(o3), H4.getElementById("error-stack").innerHTML = Fs.toHtml(i2), this.showMode("ERROR");
  }
  showNoPreview() {
    this.testing || (this.showMode("NOPREVIEW"), this.storyRoot()?.setAttribute("hidden", "true"), this.docsRoot()?.setAttribute("hidden", "true"));
  }
  showPreparingStory({ immediate: e2 = false } = {}) {
    clearTimeout(this.preparingTimeout), e2 ? this.showMode("PREPARING_STORY") : this.preparingTimeout = setTimeout(
      () => this.showMode("PREPARING_STORY"),
      Ps
    );
  }
  showPreparingDocs({ immediate: e2 = false } = {}) {
    clearTimeout(this.preparingTimeout), e2 ? this.showMode("PREPARING_DOCS") : this.preparingTimeout = setTimeout(() => this.showMode("PREPARING_DOCS"), Ps);
  }
  showMain() {
    this.showMode("MAIN");
  }
  showDocs() {
    this.storyRoot().setAttribute("hidden", "true"), this.docsRoot().removeAttribute("hidden");
  }
  showStory() {
    this.docsRoot().setAttribute("hidden", "true"), this.storyRoot().removeAttribute("hidden");
  }
  showStoryDuringRender() {
    H4.body.classList.add(So.MAIN);
  }
};
n2(To, "WebView");
var He = To;
var wo = class wo2 extends Ne {
  constructor(r2, o3) {
    super(r2, o3, new qe(), new He());
    this.importFn = r2;
    this.getProjectAnnotations = o3;
    scope.__STORYBOOK_PREVIEW__ = this;
  }
};
n2(wo, "PreviewWeb");
var { document: Ae } = scope;
var Rp = [
  "application/javascript",
  "application/ecmascript",
  "application/x-ecmascript",
  "application/x-javascript",
  "text/ecmascript",
  "text/javascript",
  "text/javascript1.0",
  "text/javascript1.1",
  "text/javascript1.2",
  "text/javascript1.3",
  "text/javascript1.4",
  "text/javascript1.5",
  "text/jscript",
  "text/livescript",
  "text/x-ecmascript",
  "text/x-javascript",
  // Support modern javascript
  "module"
];
var Ep = "script";
var Ds = "scripts-root";
function Ut() {
  let t2 = Ae.createEvent("Event");
  t2.initEvent("DOMContentLoaded", true, true), Ae.dispatchEvent(t2);
}
n2(Ut, "simulateDOMContentLoaded");
function Ap(t2, e2, r2) {
  let o3 = Ae.createElement("script");
  o3.type = t2.type === "module" ? "module" : "text/javascript", t2.src ? (o3.onload = e2, o3.onerror = e2, o3.src = t2.src) : o3.textContent = t2.innerText, r2 ? r2.appendChild(o3) : Ae.head.appendChild(o3), t2.parentNode.removeChild(t2), t2.src || e2();
}
n2(Ap, "insertScript");
function Ms(t2, e2, r2 = 0) {
  t2[r2](() => {
    r2++, r2 === t2.length ? e2() : Ms(t2, e2, r2);
  });
}
n2(Ms, "insertScriptsSequentially");
function Ls(t2) {
  let e2 = Ae.getElementById(Ds);
  e2 ? e2.innerHTML = "" : (e2 = Ae.createElement("div"), e2.id = Ds, Ae.body.appendChild(e2));
  let r2 = Array.from(t2.querySelectorAll(Ep));
  if (r2.length) {
    let o3 = [];
    r2.forEach((i2) => {
      let s = i2.getAttribute("type");
      (!s || Rp.includes(s)) && o3.push((a) => Ap(i2, a, e2));
    }), o3.length && Ms(o3, Ut, void 0);
  } else
    Ut();
}
n2(Ls, "simulatePageLoad");
var _s = "storybook/docs";
var yS = `${_s}/panel`;
var js = `${_s}/snippet-rendered`;
async function Ns(t2, e2) {
  let r2 = e2.parameters?.docs?.source?.transform, { id: o3, unmappedArgs: i2 } = e2, s = r2 && t2 ? r2?.(t2, e2) : t2, a = s ? await s : void 0;
  z5.getChannel().emit(js, {
    id: o3,
    source: a,
    args: i2
  });
}
n2(Ns, "emitTransformCode");

export {
  oe,
  se,
  re,
  z5 as z,
  Ws,
  fi,
  Ct,
  Le,
  Vr,
  Zl,
  rc,
  bi,
  nc
};
//# sourceMappingURL=chunk-YHGJ2EU7.js.map
